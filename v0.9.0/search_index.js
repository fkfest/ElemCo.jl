var documenterSearchIndex = {"docs":
[{"location":"tensortools/#Tensor-tools","page":"Tensor tools","title":"Tensor tools","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"CurrentModule = ElemCo.TensorTools","category":"page"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"TensorTools","category":"page"},{"location":"tensortools/#ElemCo.TensorTools","page":"Tensor tools","title":"ElemCo.TensorTools","text":"tensor tools,      e.g., access to integrals, load/save intermediates... \n\n\n\n\n\n","category":"module"},{"location":"tensortools/#I/O-functions","page":"Tensor tools","title":"I/O functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"save!\nload\nmmap\nnewmmap\nclosemmap","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.save!","page":"Tensor tools","title":"ElemCo.TensorTools.save!","text":"save!(EC::ECInfo, fname::String, a::AbstractArray...; description=\"tmp\", overwrite=true)\n\nSave array or tuple of arrays a to file fname in EC.scr directory.   Add file to EC.files with description.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.load","page":"Tensor tools","title":"ElemCo.TensorTools.load","text":"load(EC::ECInfo, fname::String)\n\nLoad array from file fname in EC.scr directory.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.mmap","page":"Tensor tools","title":"ElemCo.TensorTools.mmap","text":"mmap(EC::ECInfo, fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.newmmap","page":"Tensor tools","title":"ElemCo.TensorTools.newmmap","text":"newmmap(EC::ECInfo, fname::String, Type, dims::Tuple{Vararg{Int}}; description=\"tmp\")\n\nCreate a new memory-map file for writing (overwrites existing file).   Add file to EC.files with description.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.closemmap","page":"Tensor tools","title":"ElemCo.TensorTools.closemmap","text":"closemmap(EC::ECInfo, file, array)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Integral-extraction","page":"Tensor tools","title":"Integral extraction","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ints1\nints2","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.ints1","page":"Tensor tools","title":"ElemCo.TensorTools.ints1","text":"ints1(EC::ECInfo, spaces::String, spincase = nothing)\n\nReturn subset of 1e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification. \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.ints2","page":"Tensor tools","title":"ElemCo.TensorTools.ints2","text":"ints2(EC::ECInfo, spaces::String, spincase = nothing, detri = true)\n\nReturn subset of 2e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification.   If the last two indices are stored as triangular and detri - make them full,   otherwise return as a triangular cut.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Tensor-manipulation","page":"Tensor tools","title":"Tensor manipulation","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"sqrtinvchol\ninvchol\nrotate_eigenvectors_to_real!","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.sqrtinvchol","page":"Tensor tools","title":"ElemCo.TensorTools.sqrtinvchol","text":"sqrtinvchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn NON-SYMMETRIC (pseudo)sqrt-inverse of a hermitian matrix using Cholesky decomposition.\n\nStarting from A^-1 = A^-1 L (A^-1 L)^ = M M^   with A = L L^.   By solving the equation L^ M = 1 (for low-rank: using QR decomposition).   Return M.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.invchol","page":"Tensor tools","title":"ElemCo.TensorTools.invchol","text":"invchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn (pseudo)inverse of a hermitian matrix using Cholesky decomposition .\n\nThe inverse is calculated as A^-1 = A^-1 L (A^-1 L)^ = M M^   with A = L L^.   By solving the equation L^ M = 1 (for low-rank: using QR decomposition) \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.rotate_eigenvectors_to_real!","page":"Tensor tools","title":"ElemCo.TensorTools.rotate_eigenvectors_to_real!","text":"rotate_eigenvectors_to_real!(evecs::AbstractMatrix, evals::AbstractVector)\n\nIn-place transform complex eigenvectors of a real matrix to a real space    such that they block-diagonalize the matrix.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Other-exported-functions","page":"Tensor tools","title":"Other exported functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"Modules = [TensorTools]\nPrivate = false\nOrder = [:function]\nFilter = t -> t ∉ [ElemCo.save!, ElemCo.load, ElemCo.mmap, ElemCo.newmmap, ElemCo.closemmap, ElemCo.ints1, ElemCo.ints2, ElemCo.sqrtinvchol, ElemCo.invchol, ElemCo.rotate_eigenvectors_to_real! ]","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.detri_int2-NTuple{6, Any}","page":"Tensor tools","title":"ElemCo.TensorTools.detri_int2","text":"detri_int2(allint2, norb, sp1, sp2, sp3, sp4)\n\nReturn full 2e⁻ integrals <sp1 sp2 | sp3 sp4> from allint2 with last two indices as a triangular index.\n\n\n\n\n\n","category":"method"},{"location":"tensortools/#ElemCo.TensorTools.get_spaceblocks","page":"Tensor tools","title":"ElemCo.TensorTools.get_spaceblocks","text":"get_spaceblocks(space, maxblocksize=100, strict=false)\n\nGenerate ranges for block indices for space (for loop over blocks).\n\nspace is a range or an array of indices.    Even if space is non-contiguous, the blocks will be contiguous.    If strict is true, the blocks will be of size maxblocksize (except for the last block and non-contiguous index-ranges).   Otherwise the actual block size will be as close as possible to blocksize such that   the resulting blocks are of similar size.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.print_nonzeros-Tuple{AbstractArray}","page":"Tensor tools","title":"ElemCo.TensorTools.print_nonzeros","text":"print_nonzeros(tensor::AbstractArray; ϵ=1.e-12, fname::String=\"\")\n\nPrint cartesian index alongside value of array for elements with absolute value greater or equal than ϵ   either to stdout or to a file.\n\n\n\n\n\n","category":"method"},{"location":"tensortools/#Internal-functions","page":"Tensor tools","title":"Internal functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"Modules = [TensorTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.triinds","page":"Tensor tools","title":"ElemCo.TensorTools.triinds","text":"triinds(norb, sp1::AbstractArray{Int}, sp2::AbstractArray{Int}, reverseCartInd = false)\n\nGenerate set of CartesianIndex for addressing the lhs and    a bitmask for the rhs for transforming a triangular index from 1:norb     to two original indices in spaces sp1 and sp2.   If reverse: the cartesian indices are reversed.\n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#Fock-builders","page":"Fock builders","title":"Fock builders","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"ElemCo.FockFactory","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory","page":"Fock builders","title":"ElemCo.FockFactory","text":"Fock builders (using FciDump or DF integrals) \n\n\n\n\n\n","category":"module"},{"location":"fockfactory/#Exported-functions","page":"Fock builders","title":"Exported functions","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"Modules = [ElemCo.FockFactory]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory.gen_density_matrix-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_density_matrix","text":"gen_density_matrix(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray, occvec)\n\nGenerate D_μν=C^l_μi C^r_νi with i defined by occvec.   Only real part of D_μν is kept.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_dffock","text":"gen_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute DF-HF Fock matrix (integral direct) in AO basis.\n\nIf cMO is unrestricted, α and β Fock matrices will be returned.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_dffock","text":"gen_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute DF-HF Fock matrix in AO basis   (using precalculated Cholesky-decomposed integrals).\n\nIf cMO is unrestricted, α and β Fock matrices will be returned.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate closed-shell fock matrix from FCIDump integrals and orbitals CMOl, CMOr. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, den::AbstractArray)\n\nCalculate closed-shell fock matrix from FCIDump integrals and density matrix den. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol, den::AbstractArray, denOS::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and density matrices den (for spincase)    and denOS (opposite spin to spincase). \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol, Vararg{AbstractArray, 4}}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β} and orbitals CMOl, CMOr and   orbitals for the opposite-spin CMOlOS and CMOrOS. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β}. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo)\n\nCalculate closed-shell fock matrix from FCIDump integrals. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_frac_density_matrix-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_frac_density_matrix","text":"gen_frac_density_matrix(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray, occupation)\n\nGenerate D_μν=C^l_μi C^r_νi n_i with n_i provided in occupation.   Only real part of D_μν is kept.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_ufock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_ufock","text":"gen_ufock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and orbitals cMOl, cMOr   with cMOl[1] and cMOr[1] - α-MO transformation coefficients and    cMOl[2] and cMOr[2] - β-MO transformation coefficients. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_ufock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_ufock","text":"gen_ufock(EC::ECInfo, den::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and density matrix den. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#Internal-functions","page":"Fock builders","title":"Internal functions","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"Modules = [ElemCo.FockFactory]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory.gen_closed_shell_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_closed_shell_dffock","text":"gen_closed_shell_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute closed-shell DF-HF Fock matrix (integral direct) in AO basis.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_closed_shell_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_closed_shell_dffock","text":"gen_closed_shell_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute closed-shell DF-HF Fock matrix in AO basis   (using precalculated Cholesky-decomposed integrals).\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_unrestricted_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_unrestricted_dffock","text":"gen_unrestricted_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute unrestricted DF-HF Fock matrices [Fα, Fβ] in AO basis (integral direct).\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_unrestricted_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_unrestricted_dffock","text":"gen_unrestricted_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute unrestricted DF-HF Fock matrices [Fα, Fβ] in AO basis   (using precalculated Cholesky-decomposed integrals).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#Coupled-cluster-tools","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"ElemCo.CCTools","category":"page"},{"location":"cctools/#ElemCo.CCTools","page":"Coupled-cluster tools","title":"ElemCo.CCTools","text":"CCTools\n\nA collection of tools for working with coupled cluster theory.\n\n\n\n\n\n","category":"module"},{"location":"cctools/#Exported-functions","page":"Coupled-cluster tools","title":"Exported functions","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"Modules = [ElemCo.CCTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"cctools/#ElemCo.CCTools.calc_HF_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_HF_energy","text":"calc_HF_energy(EC::ECInfo, closed_shell)\n\nCalculate HF energy from FCIDump and EC info. \n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_doubles_norm-Tuple{Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_doubles_norm","text":"calc_contra_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes   (the same as calc_doubles_norm)\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_doubles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_doubles_norm","text":"calc_contra_doubles_norm(T2)\n\nCalculate squared norm of closed-shell contravariant doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_singles_norm-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_singles_norm","text":"calc_contra_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes    (same as calc_singles_norm(T1a, T1b)).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_singles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_singles_norm","text":"calc_contra_singles_norm(T1)\n\nCalculate squared norm of closed-shell contravariant singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_deco_doubles_norm","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_deco_doubles_norm","text":"calc_deco_doubles_norm(T2, tT2=Float64[])\n\nCalculate squared norm of doubles (for decomposed doubles: without contravariant!)   T2 are decomposed doubles amplitudes T2[X,Y]=T_XY or   full doubles amplitudes T2[a,b,i,j]=T^ij_ab. \n\nIf the contravariant amplitude tT2 is provided,    the norm will be calculated as T_XY T_XY.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.calc_deco_triples_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_deco_triples_norm","text":"calc_deco_triples_norm(T3)\n\nCalculate a simple norm of triples (without contravariant!)\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_doubles_norm-Tuple{Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_doubles_norm","text":"calc_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_doubles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_doubles_norm","text":"calc_doubles_norm(T2)\n\nCalculate squared norm of closed-shell doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_fock_matrix-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_fock_matrix","text":"calc_fock_matrix(EC::ECInfo, closed_shell)\n\nCalculate fock matrix from FCIDump\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_energy_using_dfock-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_energy_using_dfock","text":"calc_singles_energy_using_dfock(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy    using dressed fock matrix.\n\nif fock_only is true, the energy will be calculated using only non-dressed fock matrix.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_norm-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_norm","text":"calc_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_norm","text":"calc_singles_norm(T1)\n\nCalculate squared norm of closed-shell singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.contra2covariant-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.contra2covariant","text":"contra2covariant(T2)\n\nTransform contravariant doubles amplitudes to covariant.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.read_starting_guess4amplitudes-Tuple{ElemCo.ECInfos.ECInfo, Int64, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.read_starting_guess4amplitudes","text":"read_starting_guess4amplitudes(EC::ECInfo, level::Int, spins...)\n\nRead starting guess for excitation level.\n\nThe guess will be read from T_vo, T_VO, T_vvoo etc files.   If the file does not exist, the guess will be a zeroed-vector.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_doubles","text":"save_current_doubles(EC::ECInfo, T2a, T2b, T2ab; prefix=\"T\")\n\nSave current doubles amplitudes T2a, T2b, and T2ab to files    prefix*\"_vvoo\", prefix*\"_VVOO\", and prefix*\"_vVoO\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_doubles","text":"save_current_doubles(EC::ECInfo, T2; prefix=\"T\")\n\nSave current doubles amplitudes T2 to file prefix*\"_vvoo\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_singles-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_singles","text":"save_current_singles(EC::ECInfo, T1a, T1b; prefix=\"T\")\n\nSave current singles amplitudes T1a and T1b to files prefix*\"_vo\" and prefix*\"_VO\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_singles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_singles","text":"save_current_singles(EC::ECInfo, T1; prefix=\"T\")\n\nSave current singles amplitudes T1 to file prefix*\"_vo\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.spin_project!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.spin_project!","text":"spin_project!(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab)\n\nSpin-project singles and doubles amplitudes/residuals.\n\nOnly possible for high-spin states.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.spin_project_amplitudes","page":"Coupled-cluster tools","title":"ElemCo.CCTools.spin_project_amplitudes","text":"spin_project_amplitudes(EC::ECInfo, with_singles=true)\n\nSpin-project singles (if withsingles) and doubles amplitudes    from files `\"Tvo\",\"TVO\",\"Tvvoo\",\"TVVOO\"and\"TvVoO\"`.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.starting_amplitudes-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.starting_amplitudes","text":"starting_amplitudes(EC::ECInfo, method::ECMethod)\n\nPrepare starting amplitudes for coupled cluster calculation.\n\nThe starting amplitudes are read from files T_vo, T_VO, T_vvoo, etc.   If the files do not exist, the amplitudes are initialized to zero.   The order of amplitudes is as follows:\n\nsingles: α, β\ndoubles: αα, ββ, αβ\ntriples: ααα, βββ, ααβ, αββ\n\nReturn a list of vectors of starting amplitudes    and a list of ranges for excitation levels.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.transform_amplitudes2lagrange_multipliers!-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.transform_amplitudes2lagrange_multipliers!","text":"transform_amplitudes2lagrange_multipliers!(Amps, exc_ranges)\n\nTransform amplitudes to first guess for Lagrange multipliers.\n\nThe amplitudes are transformed in-place. \n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_amps!-Tuple{ElemCo.ECInfos.ECInfo, AbstractString, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_amps!","text":"try2save_amps!(EC::ECInfo, excitation_level::AbstractString, amps...; type=\"T\")\n\nSave amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_\"*excitation_level.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_doubles!","text":"try2save_doubles!(EC::ECInfo, doubles...; type=\"T\")\n\nSave doubles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_doubles\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_singles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_singles!","text":"try2save_singles!(EC::ECInfo, singles...; type=\"T\")\n\nSave singles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_singles\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_amps-Tuple{ElemCo.ECInfos.ECInfo, AbstractString}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_amps","text":"try2start_amps(EC::ECInfo, excitation_level::AbstractString; type=\"T\")\n\nRead amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    from file EC.options.cc.start[_lm]*\"_\"*excitation_level.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_doubles","text":"try2start_doubles(EC::ECInfo; type=\"T\")\n\nRead doubles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")   from file EC.options.cc.start[_lm]*\"_doubles\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_singles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_singles","text":"try2start_singles(EC::ECInfo; type=\"T\")\n\nRead singles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")   from file EC.options.cc.start[_lm]*\"_singles\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_deco_doubles-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_deco_doubles","text":"update_deco_doubles(EC, R2; use_shift=true)\n\nUpdate decomposed doubles amplitudes.\n\nIf R2 is R^ij_ab, the update is calculated using   update_doubles(EC, R2, use_shift=use_shift).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_deco_triples","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_deco_triples","text":"update_deco_triples(EC, R3, use_shift=true)\n\nUpdate decomposed triples amplitudes.\n\nNote that the sign of the residual is opposite   to the usual definition of the triples residual   and therefore the update is calculated using    a positive denominator...\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.update_doubles","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles","text":"update_doubles(R2, ϵo1, ϵv1, ϵo2, ϵv2, shift)\n\nCalculate update for doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.update_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles!","text":"update_doubles!(EC::ECInfo, T2, R2)\n\nUpdate doubles amplitudes in T2 with R2.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 6}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles!","text":"update_doubles!(EC::ECInfo, T2a, T2b, T2ab, R2a, R2b, R2ab)\n\nUpdate doubles amplitudes in T2a, T2b, T2ab with R2a, R2b, R2ab.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles","text":"update_doubles(EC::ECInfo, R2; spincase::Symbol=:α, antisymmetrize=false, use_shift=true)\n\nCalculate update for doubles amplitudes for a given spincase∈{:α,:β,:αβ}.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles!-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles!","text":"update_singles!(EC::ECInfo, T1, R1)\n\nUpdate singles amplitudes in T1 with R1.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles!","text":"update_singles!(EC::ECInfo, T1a, T1b, R1a, R1b)\n\nUpdate singles amplitudes in T1a, T1b with R1a, R1b.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles-NTuple{4, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles","text":"update_singles(R1, ϵo, ϵv, shift)\n\nCalculate update for singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles","text":"update_singles(EC::ECInfo, R1; spincase::Symbol=:α, use_shift=true)\n\nCalculate update for singles amplitudes for a given spincase∈{:α,:β}.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#Internal-functions","page":"Coupled-cluster tools","title":"Internal functions","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"Modules = [ElemCo.CCTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cctools/#ElemCo.CCTools.add_singles2doubles!-NTuple{5, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.add_singles2doubles!","text":"add_singles2doubles!(T2aa, T2bb, T2ab, T1a, T1b)\n\nAdd singles to doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.add_singles2doubles!-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.add_singles2doubles!","text":"add_singles2doubles!(T2, T1; make_contravariant=true)\n\nAdd singles to doubles amplitudes.\n\nIf make_contravariant is true, the amplitudes will be made contravariant.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_or_start_file","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_or_start_file","text":"save_or_start_file(EC::ECInfo, type, save=true)\n\nReturn filename and description for saving or starting amplitudes/lagrange multipliers.\n\ntype is either \"T\" for amplitudes or \"LM\" for Lagrange multipliers.   If save is true, the filename for saving is returned, otherwise the filename for starting.\n\n\n\n\n\n","category":"function"},{"location":"elemco/#Calculations","page":"Running calculations","title":"Calculations","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"CurrentModule = ElemCo","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"ElemCo","category":"page"},{"location":"elemco/#ElemCo.ElemCo","page":"Running calculations","title":"ElemCo.ElemCo","text":"       ╭─────────────╮\nElectron Correlation methods\n       ╰─────────────╯\n\n\n\n\n\n","category":"module"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"The ElemCo module contains the main macros and functions for running electronic structure calculations. The methods are contained in various submodules and are described in the following sections.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Various macros are defined and exported to simplify running calculations. The macros use several reserved variable names. The following table lists the reserved variable names and their meanings.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Variable Meaning\nEC::ECInfo A global information object containing options, molecular system description, integrals and orbital spaces information, see ElemCo.ECInfo.\ngeometry::String Molecular coordinates, either in the xyz format or the file containing the xyz coordinates, see ElemCo.MSystem.\nbasis::Dict Basis set information, see ElemCo.MSystem\nfcidump::String File containing the integrals in the FCIDUMP format, see ElemCo.FciDump.","category":"page"},{"location":"elemco/#Macros","page":"Running calculations","title":"Macros","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPrivate = false\nOrder = [:macro]","category":"page"},{"location":"elemco/#ElemCo.@ECinit-Tuple{}","page":"Running calculations","title":"ElemCo.@ECinit","text":"@ECinit()\n\nInitialize EC::ECInfo and add molecular system and/or fcidump    if variables geometry::String and basis::Dict{String,Any}   and/or fcidump::String are defined.\n\nIf EC is already initialized, it will be overwritten.\n\nExamples\n\ngeometry=\"He 0.0 0.0 0.0\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@ECinit\n# output\nOccupied orbitals:[1]\n\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@bohf-Tuple{}","page":"Running calculations","title":"ElemCo.@bohf","text":"@bohf()\n\nRun bi-orthogonal HF calculation using FCIDUMP integrals.\n\nThe orbitals are stored to WfOptions.orb.   For open-shell systems (or UHF FCIDUMPs), the BO-UHF energy is calculated.\n\nExamples\n\nfcidump = \"FCIDUMP\"\n@bohf\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@bouhf-Tuple{}","page":"Running calculations","title":"ElemCo.@bouhf","text":"@bouhf()\n\nRun bi-orthogonal UHF calculation using FCIDUMP integrals.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@cc-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@cc","text":"@cc(method, kwargs...)\n\nRun coupled cluster calculation.\n\nThe type of the method is determined by the first argument (ccsd/ccsd(t)/dcsd etc).   The method can be specified as a string or as a variable, e.g.,    @cc CCSD or @cc \"CCSD\" or ccmethod=\"CCSD\";  @cc ccmethod.\n\nKeyword arguments\n\nfcidump::String: fcidump file (default: \"\", i.e., use integrals from EC).\nocca::String: occupied α orbitals (default: \"-\").\noccb::String: occupied β orbitals (default: \"-\").\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@dfhf\n@dfints\n@cc ccsd\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@copyfile-Tuple{Any, Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@copyfile","text":"@copyfile(from_file, to_file, kwargs...)\n\nCopy file from_file to to_file in EC.scr directory.\n\nKeyword arguments\n\noverwrite::Bool: overwrite existing file (default: false).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfhf-Tuple{}","page":"Running calculations","title":"ElemCo.@dfhf","text":"@dfhf()\n\nRun DF-HF calculation. The orbitals are stored to WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfints-Tuple{}","page":"Running calculations","title":"ElemCo.@dfints","text":"@dfints()\n\nGenerate 2 and 4-idx MO integrals using density fitting.   The MO coefficients are read from WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfuhf-Tuple{}","page":"Running calculations","title":"ElemCo.@dfuhf","text":"@dfuhf()\n\nRun DF-UHF calculation. The orbitals are stored to WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@freeze_orbs-Tuple{Any}","page":"Running calculations","title":"ElemCo.@freeze_orbs","text":"@freeze_orbs(freeze_orbs)\n\nFreeze orbitals in the integrals according to an array or range    freeze_orbs.\n\nExamples\n\nfcidump = \"FCIDUMP\"\n@freeze_orbs 1:5\n...\n@ECinit\n@freeze_orbs [1,2,20,21]\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@loadfile-Tuple{Any}","page":"Running calculations","title":"ElemCo.@loadfile","text":"@loadfile(filename)\n\nRead file filename from EC.scr directory.\n\nExample\n\nfock = @loadfile(\"f_mm\")\norbs = @loadfile(\"C_Am\")\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@mainname-Tuple{Any}","page":"Running calculations","title":"ElemCo.@mainname","text":"@mainname(file)\n\nReturn the main name of a file, i.e. the part before the last dot   and the extension.\n\nExamples\n\njulia> @mainname(\"~/test.xyz\")\n(\"test\", \"xyz\")\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@method2string","page":"Running calculations","title":"ElemCo.@method2string","text":"@method2string(method, strmethod=\"\")\n\nReturn string representation of method.\n\nIf method is a String variable, return the value of the variable.   Otherwise, return the string representation of method (or strmethod if provided).\n\nExamples\n\njulia> @method2string(CCSD)\n\"CCSD\"\njulia> CCSD = \"UCCSD\";\njulia> @method2string(CCSD)\n\"UCCSD\"\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@opt-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@opt","text":"@opt(what, kwargs...)\n\nSet options for EC::ECInfo. \n\nThe first argument what is the name of the option (e.g., scf, cc, cholesky), see ECInfos.Options.   The keyword arguments are the options to be set (e.g., thr=1.e-14, maxit=10).   The current state of the options can be stored in a variable, e.g., opt_cc = @opt cc.   The state can then be restored by @opt cc opt_cc.   If EC is not already initialized, it will be done. \n\nExamples\n\noptscf = @opt scf thr=1.e-14 maxit=10\n@opt cc maxit=100\n...\n@opt scf optscf\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@reset-Tuple{Any}","page":"Running calculations","title":"ElemCo.@reset","text":"@reset(opt)\n\nReset options for opt to default values.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@run-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@run","text":"general runner \n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@savefile-Tuple{Any, Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@savefile","text":"@savefile(filename, arr, kwargs...)\n\nSave array or tuple of arrays arr to file filename in EC.scr directory.\n\nKeyword arguments\n\ndescription::String: description of the file (default: \"tmp\").\noverwrite::Bool: overwrite existing file (default: false).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@svdcc","page":"Running calculations","title":"ElemCo.@svdcc","text":"@svdcc(method=\"dcsd\")\n\nRun coupled cluster calculation with SVD decomposition of the amplitudes.\n\nThe type of the method is determined by the first argument (dcsd/dcd)\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mp2fit\"=>\"cc-pvdz-rifit\")\n@dfhf\n@svdcc\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@transform_ints","page":"Running calculations","title":"ElemCo.@transform_ints","text":"@transform_ints(type=\"\")\n\nRotate FCIDump integrals using WfOptions.orb as transformation    matrices.\n\nThe orbitals are read from WfOptions.orb.   If type is one of [bo, BO, bi-orthogonal, Bi-orthogonal, biorth, biorthogonal, Biorthogonal],    the bi-orthogonal orbitals are used and the left transformation matrix is   read from WfOptions.orb*WfOptions.left.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@tryECinit-Tuple{}","page":"Running calculations","title":"ElemCo.@tryECinit","text":"@tryECinit()\n\nIf EC::ECInfo is not yet initialized, run @ECinit macro.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@write_ints","page":"Running calculations","title":"ElemCo.@write_ints","text":"@write_ints(file=\"FCIDUMP\", tol=-1.0)\n\nWrite FCIDump integrals to file file.\n\nIf tol is negative, all integrals are written, otherwise only integrals with absolute value larger than tol are written.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#Exported-functions","page":"Running calculations","title":"Exported functions","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"elemco/#ElemCo.ECdriver-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Running calculations","title":"ElemCo.ECdriver","text":"ECdriver(EC::ECInfo, methods; fcidump=\"FCIDUMP\", occa=\"-\", occb=\"-\")\n\nRun electronic structure calculation for EC::ECInfo using methods methods::String.\n\nThe integrals are read from fcidump::String (default: \"FCIDUMP\").   If fcidump::String is empty, the integrals from EC.fd are used.   The occupied α orbitals are given by occa::String (default: \"-\").   The occupied β orbitals are given by occb::String (default: \"-\").   If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).\n\n\n\n\n\n","category":"method"},{"location":"elemco/#Internal-functions","page":"Running calculations","title":"Internal functions","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfhf/#Density-fitted-Hartree-Fock","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"CurrentModule = ElemCo.DFHF","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"The density-fitted Hartree-Fock (DF-HF) method is a method for computing the Hartree-Fock energy using density fitting. The DF-HF method is implemented in ElemCo.jl using the @dfhf macro. Here's an example of how you can use this macro:","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF\n@dfhf","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, and calculates the DF-HF energy.","category":"page"},{"location":"dfhf/#Exported-functions-and-types","page":"Density-fitted Hartree-Fock","title":"Exported functions and types","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"Modules = [DFHF]\nPrivate = false","category":"page"},{"location":"dfhf/#ElemCo.DFHF.dfhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfhf","text":"dfhf(EC::ECInfo)\n\nPerform closed-shell DF-HF calculation.\n\n\n\n\n\n","category":"method"},{"location":"dfhf/#ElemCo.DFHF.dfuhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfuhf","text":"dfuhf(EC::ECInfo)\n\nPerform DF-UHF calculation.\n\n\n\n\n\n","category":"method"},{"location":"dfhf/#Internal-functions","page":"Density-fitted Hartree-Fock","title":"Internal functions","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"Modules = [DFHF]\nPublic = false","category":"page"},{"location":"dumptools/#Dump-tools","page":"Dump tools","title":"Dump tools","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"CurrentModule = ElemCo.DumpTools","category":"page"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"DumpTools","category":"page"},{"location":"dumptools/#ElemCo.DumpTools","page":"Dump tools","title":"ElemCo.DumpTools","text":"DumpTools module\n\nTools for manipulating FCIDump files.\n\n\n\n\n\n","category":"module"},{"location":"dumptools/#Exported-functions","page":"Dump tools","title":"Exported functions","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"Modules = [DumpTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dumptools/#ElemCo.DumpTools.freeze_orbs_in_dump-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Dump tools","title":"ElemCo.DumpTools.freeze_orbs_in_dump","text":"freeze_orbs_in_dump(EC::ECInfo, freeze_orbs)\n\nFreeze orbitals in FCIDump file EC.fd according to an array or range freeze_orbs.\n\n\n\n\n\n","category":"method"},{"location":"dumptools/#Internal-functions","page":"Dump tools","title":"Internal functions","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"Modules = [DumpTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#Orbital-tools","page":"Orbital tools","title":"Orbital tools","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"ElemCo.OrbTools","category":"page"},{"location":"orbtools/#ElemCo.OrbTools","page":"Orbital tools","title":"ElemCo.OrbTools","text":"OrbTools\n\nA collection of tools for working with orbitals\n\n\n\n\n\n","category":"module"},{"location":"orbtools/#Exported-functions","page":"Orbital tools","title":"Exported functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"Modules = [ElemCo.OrbTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_orb-Tuple{ElemCo.ECInfos.ECInfo, Symbol}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_orb","text":"guess_orb(EC::ECInfo, guess::Symbol)\n\nCalculate starting guess for MO coefficients.   Type of initial guess for MO coefficients is given by guess.\n\nSee ScfOptions.guess for possible values.\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.is_unrestricted_MO-Tuple{Any}","page":"Orbital tools","title":"ElemCo.OrbTools.is_unrestricted_MO","text":"is_unrestricted_MO(cMO)\n\nReturn true if cMO is unrestricted MO coefficients of the form    [CMOα, CMOβ].\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.load_orbitals","page":"Orbital tools","title":"ElemCo.OrbTools.load_orbitals","text":"load_orbitals(EC::ECInfo, orbsfile::String=\"\")\n\nLoad (last) orbitals.\n\nfrom file orbsfile if not empty\nfrom file WfOptions.orb if not empty\nerror if all files are empty\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.orbital_energies","page":"Orbital tools","title":"ElemCo.OrbTools.orbital_energies","text":"orbital_energies(EC::ECInfo, spincase::Symbol=:α)\n\nReturn orbital energies for a given spincase∈{:α,:β}.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#Internal-functions","page":"Orbital tools","title":"Internal functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"Modules = [ElemCo.OrbTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_hcore-Tuple{ElemCo.ECInfos.ECInfo}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_hcore","text":"guess_hcore(EC::ECInfo)\n\nGuess MO coefficients from core Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.guess_sad-Tuple{ElemCo.ECInfos.ECInfo}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_sad","text":"guess_sad(EC::ECInfo)\n\nGuess MO coefficients from atomic densities.\n\n\n\n\n\n","category":"method"},{"location":"diis/#DIIS-solver","page":"DIIS solver","title":"DIIS solver","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"CurrentModule = ElemCo.DIIS","category":"page"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"DIIS","category":"page"},{"location":"diis/#ElemCo.DIIS","page":"DIIS solver","title":"ElemCo.DIIS","text":"DIIS module for iterative solvers\n\n\n\n\n\n","category":"module"},{"location":"diis/#Main-structure","page":"DIIS solver","title":"Main structure","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Diis","category":"page"},{"location":"diis/#ElemCo.DIIS.Diis","page":"DIIS solver","title":"ElemCo.DIIS.Diis","text":"DIIS object\n\n\n\n\n\n","category":"type"},{"location":"diis/#Exported-functions","page":"DIIS solver","title":"Exported functions","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Modules = [DIIS]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"diis/#ElemCo.DIIS.perform-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.perform","text":"perform(diis::Diis, Amps, Res)\n\nPerform DIIS.\n\n\n\n\n\n","category":"method"},{"location":"diis/#Internal-functions","page":"DIIS solver","title":"Internal functions","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Modules = [DIIS]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"diis/#ElemCo.DIIS.combine-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.combine","text":"combine(diis::Diis, vecfiles, coeffs)\n\nCombine vectors from files with coefficients.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadamps-Tuple{ElemCo.DIIS.Diis, Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadamps","text":"loadamps(diis::Diis, ipos)\n\nLoad vectors from file at position ipos.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadres-Tuple{ElemCo.DIIS.Diis, Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadres","text":"loadres(diis::Diis, ipos)\n\nLoad residuals from file at position ipos.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadvecs-Tuple{Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadvecs","text":"loadvecs(file)\n\nLoad vectors from file.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.saveamps-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.saveamps","text":"saveamps(diis::Diis, vecs, ipos)\n\nSave vectors to file (replacing previous vectors at position ipos).\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.saveres-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.saveres","text":"saveres(diis::Diis, vecs, ipos)\n\nSave residuals to file (replacing previous residuals at position ipos).\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.weighted_dot-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.weighted_dot","text":"weighted_dot(diis::Diis, vecs1, vecs2)\n\nCompute weighted (with diis.weights) dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"dump/#FCIDump-files","page":"FCIDump files","title":"FCIDump files","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"CurrentModule = ElemCo.FciDump","category":"page"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"FciDump","category":"page"},{"location":"dump/#ElemCo.FciDump","page":"FCIDump files","title":"ElemCo.FciDump","text":"Read and write fcidump format integrals. Individual arrays of integrals can also be in *.npy format\n\n\n\n\n\n","category":"module"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"The FCIDump file format is a simple text file format for storing molecular integrals. It is used by many quantum chemistry programs. ","category":"page"},{"location":"dump/#Storage-of-molecular-integrals","page":"FCIDump files","title":"Storage of molecular integrals","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"FDump","category":"page"},{"location":"dump/#ElemCo.FciDump.FDump","page":"FCIDump files","title":"ElemCo.FciDump.FDump","text":"FDump\n\nMolecular integrals \n\nThe 2-e integrals are stored in the physicists' notation: int2[pqrs] = pqrs=v_pq^rs   and for triang the last two indices are stored as a single upper triangular index (r <= s)\n\nint2::Array{Float64}:  2-e⁻ integrals for restricted orbitals fcidump.\nint2aa::Array{Float64}:  αα 2-e⁻ integrals for unrestricted orbitals fcidump.\nint2bb::Array{Float64}:  ββ 2-e⁻ integrals for unrestricted orbitals fcidump.\nint2ab::Array{Float64}:  αβ 2-e⁻ integrals for unrestricted orbitals fcidump.\nint1::Array{Float64}:  1-e⁻ integrals for restricted orbitals fcidump.\nint1a::Array{Float64}:  α 1-e⁻ integrals for unrestricted orbitals fcidump.\nint1b::Array{Float64}:  β 1-e⁻ integrals for unrestricted orbitals fcidump.\nint0::Float64:  core energy\nhead::Dict:  header of fcidump file, a dictionary of arrays.\ntriang::Bool: ⟨true⟩ use an upper triangular index for last two indices of 2e⁻ integrals.\nuhf::Bool: ⟨false⟩ a convinience variable, has to coincide with head[\"IUHF\"][1] > 0.\n\n\n\n\n\n","category":"type"},{"location":"dump/#Exported-functions","page":"FCIDump files","title":"Exported functions","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"Modules = [FciDump]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dump/#ElemCo.FciDump.fd_exists-Tuple{ElemCo.FciDump.FDump}","page":"FCIDump files","title":"ElemCo.FciDump.fd_exists","text":"fd_exists(fd::FDump)\n\nReturn true if the object is a non-empty FDump\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.headvar-Tuple{Dict, String}","page":"FCIDump files","title":"ElemCo.FciDump.headvar","text":"headvar(head::Dict, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.headvar-Tuple{ElemCo.FciDump.FDump, String}","page":"FCIDump files","title":"ElemCo.FciDump.headvar","text":"headvar(fd::FDump, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.integ1","page":"FCIDump files","title":"ElemCo.FciDump.integ1","text":"integ1(fd::FDump, spincase::Symbol=:α)\n\nReturn 1-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α or :β.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.integ2","page":"FCIDump files","title":"ElemCo.FciDump.integ2","text":"integ2(fd::FDump, spincase::Symbol=:α)\n\nReturn 2-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α, :β or :αβ.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.modify_header!-Tuple{ElemCo.FciDump.FDump, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.modify_header!","text":"modify_header!(fd::FDump, norb, nelec; ms2=-1, isym=-1, orbsym=[])\n\nModify header of FDump object\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_fcidump-Tuple{String}","page":"FCIDump files","title":"ElemCo.FciDump.read_fcidump","text":"read_fcidump(fcidump::String)\n\nRead ascii file (possibly with integrals in npy files).\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.reorder_orbs_int2-Tuple{AbstractArray, Any}","page":"FCIDump files","title":"ElemCo.FciDump.reorder_orbs_int2","text":"reorder_orbs_int2(int2::AbstractArray, orbs)\n\nReorder orbitals in 2-e integrals according to orbs.\n\norbscan be a subset of orbitals or a permutation of orbitals.   Return int2[orbs[p],orbs[q],orbs[r],orbs[s]] or the triangular version.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_fcidump-Tuple{ElemCo.FciDump.FDump, AbstractArray, AbstractArray}","page":"FCIDump files","title":"ElemCo.FciDump.transform_fcidump","text":"transform_fcidump(fd::FDump, Tl::AbstractArray, Tr::AbstractArray)\n\nTransform integrals to new basis using Tl and Tr transformation matrices.    For UHF fcidump, Tl and Tr are arrays of matrices for α and β spin.   If Tl and Tr are arrays of arrays, then the function transforms rhf fcidump to uhf fcidump.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular-Tuple{Any, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular","text":"uppertriangular(i1, i2, i3)\n\nReturn upper triangular index from three indices i1 <= i2 <= i3.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular-Tuple{Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular","text":"uppertriangular(i1, i2)\n\nReturn upper triangular index from two indices i1 <= i2.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular_range-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular_range","text":"uppertriangular_range(i2)\n\nReturn range for the upper triangular index (i1 <= i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_fcidump","page":"FCIDump files","title":"ElemCo.FciDump.write_fcidump","text":"write_fcidump(fd::FDump, fcidump::String, tol=1e-12)\n\nWrite fcidump file.\n\n\n\n\n\n","category":"function"},{"location":"dump/#Internal-functions","page":"FCIDump files","title":"Internal functions","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"Modules = [FciDump]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dump/#ElemCo.FciDump.mmap_integrals-Tuple{ElemCo.FciDump.FDump, AbstractString, AbstractString}","page":"FCIDump files","title":"ElemCo.FciDump.mmap_integrals","text":"mmap_integrals(fd::FDump, dir::AbstractString, key::AbstractString)\n\nMemory-map integral file (from head[key])\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.print_int_value-NTuple{6, Any}","page":"FCIDump files","title":"ElemCo.FciDump.print_int_value","text":"print_int_value(fdf, integ, i1, i2, i3, i4)\n\nPrint integral value to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_header-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.read_header","text":"read_header(fdfile::IOStream)\n\nRead header of fcidump file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_integrals!-Tuple{ElemCo.FciDump.FDump, AbstractString}","page":"FCIDump files","title":"ElemCo.FciDump.read_integrals!","text":"read_integrals!(fd::FDump, dir::AbstractString)\n\nRead integrals from npy files.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_integrals!-Tuple{ElemCo.FciDump.FDump, IOStream}","page":"FCIDump files","title":"ElemCo.FciDump.read_integrals!","text":"read_integrals!(fd::FDump, fdfile::IOStream)\n\nRead integrals from fcidump file\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.set_int2!-Tuple{AbstractArray, Vararg{Any, 8}}","page":"FCIDump files","title":"ElemCo.FciDump.set_int2!","text":"set_int2!(int2::AbstractArray, i1, i2, i3, i4, integ, triang, simtra, ab)\n\nSet 2-e integral in int2 array to integ considering permutational symmetries.\n\nFor not ab: particle symmetry is assumed.   Integrals are stored in physicists' notation.   If triang: the last two indices are stored as a single upper triangular index.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.strict_uppertriangular_range-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.strict_uppertriangular_range","text":"strict_uppertriangular_range(i2)\n\nReturn range for the upper triangular index (i1 <= i2) without diagonal (i1 < i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_int1-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"FCIDump files","title":"ElemCo.FciDump.transform_int1","text":"transform_int1(int1::AbstractArray, Tl::AbstractArray,  Tr::AbstractArray)\n\nTransform 1-e integrals to new basis using Tl and Tr transformation matrices.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_int2-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.transform_int2","text":"transform_int2(int2::AbstractArray, Tl::AbstractArray, Tl2::AbstractArray, \n               Tr::AbstractArray, Tr2::AbstractArray, triang_in, triang_out)\n\nTransform 2-e integrals to new basis using Tl/Tl2 and Tr/Tr2 transformation matrices.\n\nv_pq^rs = v_pq^rs* Tl[p',p] * Tl2[q',q] * Tr[r',r] * Tr2[s',s]\n\nIf triang: the last two indices are stored as a single upper triangular index.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular_diagonal-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular_diagonal","text":"uppertriangular_diagonal(i2)\n\nReturn index of diagonal of upper triangular index (i1 <= i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_header-Tuple{ElemCo.FciDump.FDump, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_header","text":"write_header(fd::FDump, fdf)\n\nWrite header of fcidump file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals-Tuple{ElemCo.FciDump.FDump, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals","text":"write_integrals(fd::FDump, fdf, tol)\n\nWrite integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals1-NTuple{4, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals1","text":"write_integrals1(int1, fdf, tol, simtra)\n\nWrite 1-e integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals2-NTuple{5, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals2","text":"write_integrals2(int2, fdf, tol, triang, simtra)\n\nWrite 2-e integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#Generation-of-integrals-using-density-fitting","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"CurrentModule = ElemCo.DfDump","category":"page"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"DfDump","category":"page"},{"location":"dfdump/#ElemCo.DfDump","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump","text":"generate fcidump using df integrals and store in dumpfile \n\n\n\n\n\n","category":"module"},{"location":"dfdump/#Exported-functions","page":"Generation of integrals using density fitting","title":"Exported functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"Modules = [DfDump]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfdump/#ElemCo.DfDump.dfdump-Tuple{ElemCo.ECInfos.ECInfo}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.dfdump","text":"dfdump(EC::ECInfo)\n\nGenerate fcidump using df integrals and store in IntOptions.fcidump.   If IntOptions.fcidump is empty, don't write to fcidump file, store in EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#Internal-functions","page":"Generation of integrals using density fitting","title":"Internal functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"Modules = [DfDump]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfdump/#ElemCo.DfDump.generate_integrals-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.FciDump.FDump, Any, Any, Any}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.generate_integrals","text":"generate_integrals(EC::ECInfo, fdump::FDump, cMOa, cMOb, full_spaces)\n\nGenerate int2aa, int2bb, int2ab, int1a, int1b and int0 integrals for fcidump using density fitting.\n\nmp2fit basis is used for int2 integrals, and jkfit basis-correction is   used for int1 and int0 integrals.    full_spaces is a dictionary with spaces without frozen orbitals.\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#ElemCo.DfDump.generate_integrals-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.FciDump.FDump, Any, Any}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.generate_integrals","text":"generate_integrals(EC::ECInfo, fdump::FDump, cMO, full_spaces)\n\nGenerate int2, int1 and int0 integrals for fcidump using density fitting.\n\nmp2fit basis is used for int2 integrals, and jkfit basis-correction is   used for int1 and int0 integrals.    full_spaces is a dictionary with spaces without frozen orbitals.\n\n\n\n\n\n","category":"method"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"CurrentModule = ElemCo.Utils","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"Utils","category":"page"},{"location":"utils/#ElemCo.Utils","page":"Utils","title":"ElemCo.Utils","text":"various utilities \n\n\n\n\n\n","category":"module"},{"location":"utils/#Exported-functions","page":"Utils","title":"Exported functions","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"utils/#ElemCo.Utils.draw_endline","page":"Utils","title":"ElemCo.Utils.draw_endline","text":"draw_endline()\n\nPrint a line of ═.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.draw_line","page":"Utils","title":"ElemCo.Utils.draw_line","text":"draw_line(n = 63)\n\nPrint a thick line of n characters.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.kwarg_provided_in_macro-Tuple{Any, Symbol}","page":"Utils","title":"ElemCo.Utils.kwarg_provided_in_macro","text":"kwarg_provided_in_macro(kwargs, key::Symbol)\n\nCheck whether key is in kwargs. \n\nThis is used in macros to check whether a keyword argument is passed.   The keyword argument in question key is passed as a symbol, e.g. :thr.   kwargs is the keyword argument list passed to the macro.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.mainname-Tuple{String}","page":"Utils","title":"ElemCo.Utils.mainname","text":"mainname(file::String)\n\nReturn the main name of a file, i.e. the part before the last dot and the extension.\n\nExamples:\n\njulia> mainname(\"~/test.xyz\")\n(\"test\", \"xyz\")\n\njulia> mainname(\"test\")\n(\"test\", \"\")\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.print_info","page":"Utils","title":"ElemCo.Utils.print_info","text":"print_info(info::AbstractString, additional_info::AbstractString=\"\")\n\nPrint info between two lines.\n\nIf additional not empty: additional info after main.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.print_time-Tuple{ElemCo.AbstractEC.AbstractECInfo, Any, AbstractString, Int64}","page":"Utils","title":"ElemCo.Utils.print_time","text":"print_time(EC::AbstractECInfo, t1, info::AbstractString, verb::Int)\n\nPrint time with message info if verbosity verb is smaller than EC.verbosity.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.subspace_in_space-Tuple{Any, Any}","page":"Utils","title":"ElemCo.Utils.subspace_in_space","text":"subspace_in_space(subspace, space)\n\nReturn the positions of subspace in space    (with respect to space)\n\nsubspace and space are lists of indices    with respect to the full space (e.g., 1:norb).\n\nExamples\n\njulia> get_subspace_of_space([1,3,5], [1,3,4,5])\n3-element Array{Int64,1}:\n  1\n  2 \n  4\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.substr","page":"Utils","title":"ElemCo.Utils.substr","text":"substr(string::AbstractString, start::Int, len::Int=-1)\n\nReturn substring of string  starting at start spanning len characters    (including unicode).   If len is not given, the substring spans to the end of string.\n\nExample:   julia   julia> substr(\"λabδcd\", 2, 3)   \"abδ\"\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.substr-Tuple{AbstractString, UnitRange{Int64}}","page":"Utils","title":"ElemCo.Utils.substr","text":"substr(string::AbstractString, range::UnitRange{Int})\n\nReturn substring of string defined by range (including unicode).\n\nExample:   julia   julia> substr(\"λabδcd\", 2:4)   \"abδ\"\n\n\n\n\n\n","category":"method"},{"location":"utils/#Internal-functions","page":"Utils","title":"Internal functions","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"utils/#ElemCo.Utils.draw_thin_line","page":"Utils","title":"ElemCo.Utils.draw_thin_line","text":"draw_thin_line(n = 63)\n\nPrint a thin line of n characters.\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#Density-fitted-Coupled-Cluster-methods","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"ElemCo.DFCoupledCluster","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster","text":"DFCoupledCluster\n\nDensity-fitted coupled-cluster methods.\n\n\n\n\n\n","category":"module"},{"location":"dfcc/#Exported-functions","page":"Density-fitted Coupled Cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"Modules = [ElemCo.DFCoupledCluster]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_dressed_3idx-Tuple{Any, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_dressed_3idx","text":"calc_dressed_3idx(EC, T1)\n\nCalculate dressed integrals for 3-index integrals from file mmL.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dc-Tuple{ElemCo.ECInfos.ECInfo, AbstractString}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dc","text":"calc_svd_dc(EC::ECInfo, method::AbstractString)\n\nCalculate decomposed closed-shell DCSD or DCD with   T^ij_ab=U^iX_a U^jY_b T_XY.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dc","text":"calc_svd_dc(EC::ECInfo, method::ECMethod)\n\nCalculate decomposed closed-shell DCSD or DCD with   T^ij_ab=U^iX_a U^jY_b T_XY.\n\nCurrently only DC methods are supported.    The integrals are calculated using density fitting.   The starting guess for SVD-coefficients is calculated without doubles,   see calc_doubles_decomposition_without_doubles.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#Internal-functions","page":"Density-fitted Coupled Cluster methods","title":"Internal functions","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"Modules = [ElemCo.DFCoupledCluster]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_3idx_svd_decomposition-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_3idx_svd_decomposition","text":"calc_3idx_svd_decomposition(EC::ECInfo, full_voL::AbstractArray)\n\nCalculate U^iX_a from v_a^iL using SVD.\n\nVersion without holding all v_a^iL integrals in memory.   full_voL is the full 3-index integral v_a^iL (can be mmaped).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_MP2_amplitudes_from_3idx-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_MP2_amplitudes_from_3idx","text":"calc_MP2_amplitudes_from_3idx(EC::ECInfo, voL::AbstractArray, ishift)\n\nCalculate MP2 amplitudes from v_a^iL.\n\nThe imaginary shift ishift is used in the denominator in the calculation of the MP2 amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_MP2_from_3idx-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_MP2_from_3idx","text":"calc_MP2_from_3idx(EC::ECInfo, voL::AbstractArray, ishift)\n\nCalculate MP2 energy from v_a^iL.\n\nThe imaginary shift ishift is used in the denominator in the calculation of the MP2 amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_deco_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_deco_doubles_energy","text":"calc_deco_doubles_energy(EC::ECInfo, T2)\n\nCalculate closed-shell doubles energy   using decomposed doubles amplitudes T2=T_XY   or T2=T^ij_ab using density-fitted integrals.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_deco_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_deco_hylleraas","text":"calc_deco_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy   using contravariant decomposed doubles amplitudes T2=T_XY   or full contravariant doubles amplitude T2=T^ij_ab.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_df_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_df_doubles_energy","text":"calc_df_doubles_energy(EC::ECInfo, T2)\n\nCalculate closed-shell doubles energy using DF integrals    and T2[a,b,i,j] = T^ij_ab.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition","text":"calc_doubles_decomposition(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition_with_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition_with_doubles","text":"calc_doubles_decomposition_with_doubles(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY using explicit doubles amplitudes T^ij_ab.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition_without_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition_without_doubles","text":"calc_doubles_decomposition_without_doubles(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY without explicit   calculation of T^ij_ab.\n\nThe decomposition is done in two steps:\n\nbar U^ibar X_a is calculated from v_a^iL using SVD (with threshold CcOptions.ampsvdtol×CcOptions.ampsvdfac);\nMP2 doubles T^i_aX are calculated from v_a^iL and U^iX_a and again decomposed using SVD and threshold CcOptions.ampsvdtol.\n\nThe SVD-basis is rotated to pseudocanonical basis to diagonalize    orbital-energy differences, ϵ_X = U^iX_a(ϵ_a-ϵ_i)U^iX_a.   The imaginary shift CcOptions.deco_ishiftp is used in the denominator in the calculation of the MP2 amplitudes.   The orbital energy differences are saved in file e_X.   The SVD-coefficients U^iX_a are saved in file C_voX.   The starting guess for doubles T_XY is saved in file T_XX.   Return full MP2 correlation energy (using the imaginary shift).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dcsd_residual-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dcsd_residual","text":"calc_svd_dcsd_residual(EC::ECInfo, T1, T2)\n\nCalculate decomposed closed-shell DCSD residual with   T^ij_ab=U^iX_a U^jY_b T_XY and   R_XY=U^iX_a U^jY_b R^ij_ab.   T2 contains decomposed amplitudes T_XY or full amplitudes T^ij_ab.\n\nIf T2 is T^ij_ab, the residual is also returned in full form.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_vᵥᵒˣ-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_vᵥᵒˣ","text":"calc_vᵥᵒˣ(EC::ECInfo)\n\nCalculate hat v_a^iX = hat v_ak^ci U^kX_c    with hat v_ak^ci = hat v_a^cL hat v_k^iL    and U^kX_c from file C_voX.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.contravariant_deco_doubles","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.contravariant_deco_doubles","text":"contravariant_deco_doubles(EC::ECInfo, T2, projx=false)\n\nCalculate contravariant doubles amplitudes   T^ij_ab = 2T^ij_ab - T^ij_ba    with   T^ij_ab = U^iX_a U^jY_b T_XY.   If projx is true, the projected exchange is returned:   T_XY = U^a_iX U^b_jY T^ij_ab\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#ElemCo.DFCoupledCluster.dress_df_fock-Tuple{Any, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.dress_df_fock","text":"dress_df_fock(EC, T1)\n\nDress DF fock matrix with DF 3-index integrals.\n\nThe dress-contribution is added to the original fock matrix   from file f_mm. The dressed fock matrix is stored in file df_mm.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.get_tildevˣˣ-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.get_tildevˣˣ","text":"get_tildevˣˣ(EC::ECInfo)\n\nReturn tilde v^XY = U^kX_c U^lX_d (2 v_kl^cd - v_lk^cd )   with v_kl^cd = v_k^cL v_l^dLδ_LL. \n\nThe integrals will be read from file td_^XX.    If the file does not exist, the integrals will be calculated   and stored in file td_^XX.    vk^{cL} and U^{kX}c are read from files d_ovL and C_voX.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.save_pseudo_dress_df_fock-Tuple{Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.save_pseudo_dress_df_fock","text":"save_pseudo_dress_df_fock(EC)\n\nSave non-dressed DF fock matrix from file f_mm to dressed file df_mm.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.save_pseudodressed_3idx-Tuple{Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.save_pseudodressed_3idx","text":"save_pseudodressed_3idx(EC)\n\nSave non-dressed 3-index integrals from file mmL to dressed files.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#Molecular-system","page":"Molecular system","title":"Molecular system","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"CurrentModule = ElemCo.MSystem","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"MSystem","category":"page"},{"location":"msystem/#ElemCo.MSystem","page":"Molecular system","title":"ElemCo.MSystem","text":"Info about molecular system (geometry/basis).\n\n\n\n\n\n","category":"module"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The molecular system is the core of the simulation. It contains all the information about the molecule, including the geometry and basis sets The molecular system is defined using the MSys function:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"MSys(geometry, basis)","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"where geometry is a string containing the molecular geometry in the XYZ format, and basis is a dictionary containing the basis set information.","category":"page"},{"location":"msystem/#Geometry","page":"Molecular system","title":"Geometry","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The geometry of the molecule is defined using the geometry argument of the MSys function. The geometry is defined in the XYZ format. Here's an example of how you can define the geometry of a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"geometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The first line of the geometry string contains the units of the coordinates. The supported units are bohr and angstrom. The coordinates of the atoms are specified in the following lines. Each line contains the atomic symbol and the coordinates of the atom. The coordinates are separated by spaces or tabs.","category":"page"},{"location":"msystem/#Basis-set","page":"Molecular system","title":"Basis set","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set is defined using the basis argument of the MSys function. The basis set is defined as a dictionary, where the keys are the names of the basis sets, and the values are the basis set definitions. Here's an example of how you can define the basis set for a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"basis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set dictionary contains three keys: ao, jkfit, and mp2fit. The ao key contains the basis set for the AO integrals, the jkfit key contains the basis set for the density fitting integrals in the Hartree-Fock calculations, and the mp2fit key contains the fitting basis set for the correlated calculations.","category":"page"},{"location":"msystem/#Exported-functions-and-types","page":"Molecular system","title":"Exported functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"Modules = [MSystem]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"msystem/#ElemCo.MSystem.ACenter","page":"Molecular system","title":"ElemCo.MSystem.ACenter","text":"Atomic center\n\nname: name (as defined in input).\nnuccharge: nuclear charge (can be changed...).\ncoord: coordinates in bohr.\nbasis: various basis sets (\"ao\", \"mp2fit\", \"jkfit\").\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.Basis","page":"Molecular system","title":"ElemCo.MSystem.Basis","text":"Basis set\n\nname:  e.g., vdz, cc-pvdz, aug-cc-pvdz, cc-pvdz-jkfit.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.MSys","page":"Molecular system","title":"ElemCo.MSystem.MSys","text":"Geometry and basis set for each element name in the geometry\n\natoms: array of atomic centers.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.bond_length-Tuple{ElemCo.MSystem.ACenter, ElemCo.MSystem.ACenter}","page":"Molecular system","title":"ElemCo.MSystem.bond_length","text":"bond_length(cen1::ACenter, cen2::ACenter)\n\nCalculate bond length between two centers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.electron_distribution-Tuple{AbstractString, Vector{Int64}}","page":"Molecular system","title":"ElemCo.MSystem.electron_distribution","text":"electron_distribution(elem::AbstractString, nsh4l::Vector{Int})\n\nDistribute electrons among first atomic orbitals in nsh4l[1]s nsh4l[2]p nsh4l[3]d nsh4l[4]f... order   considering the Hund's rule and electron configuration of the atom.   Average occupations to account for the spin degeneracy and hybridization.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.electron_distribution-Tuple{ElemCo.MSystem.MSys, AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.electron_distribution","text":"electron_distribution(elnam::AbstractString, minbas::AbstractString)\n\nReturn the averaged number of electrons in the orbitals in the minimal basis set.\n\nNumber of orbitals in the minimal basis set has to be specified in minbas.jl.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.generate_basis","page":"Molecular system","title":"ElemCo.MSystem.generate_basis","text":"generate_basis(ms::MSys, type = \"ao\")\n\nGenerate basis sets for integral calculations.   type can be \"ao\", \"mp2fit\" or \"jkfit\".\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.genxyz-Tuple{ElemCo.MSystem.ACenter}","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ac::ACenter; bohr=true)\n\nGenerate xyz string with element without numbers.   If bohr: return in coordinates in bohr.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.genxyz-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ms::MSys; bohr=true)\n\nGenerate xyz string with elements without numbers.   If bohr: return in coordinates in bohr\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_ncore","page":"Molecular system","title":"ElemCo.MSystem.guess_ncore","text":"guess_ncore(ms::MSys, coretype::Symbol=:large)\n\nGuess the number of core orbitals in the system.\n\ncoretype as in ncoreorbs.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_nelec-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.guess_nelec","text":"guess_nelec(ms::MSys)\n\nGuess the number of electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_norb-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.guess_norb","text":"guess_norb(ms::MSys)\n\nGuess the number of orbitals in the system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.ms_exists-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.ms_exists","text":"ms_exists(ms::MSys)\n\nCheck whether the system is not empty.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.nuclear_repulsion-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.nuclear_repulsion","text":"nuclear_repulsion(ms::MSys)\n\nCalculate nuclear repulsion energy.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#Internal-functions-and-types","page":"Molecular system","title":"Internal functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"Modules = [MSystem]\nPublic = false\nOrder = [:type, :function]","category":"page"},{"location":"msystem/#ElemCo.MSystem.SubShell","page":"Molecular system","title":"ElemCo.MSystem.SubShell","text":"Occupation of the subshell with quantum numbers n and l.\n\nn::Int64:  n-quantum number of the subshell.\nl::Int64:  l-quantum number of the subshell.\nnel::Int64:  Number of electrons in the subshell.\n\n\n\n\n\n","category":"type"},{"location":"msystem/#ElemCo.MSystem.a2b-Tuple{Any, Any}","page":"Molecular system","title":"ElemCo.MSystem.a2b","text":"a2b(vals,skip)\n\nTransform from angstrom to bohr (if skip: no transformation). \n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.b2a-Tuple{Any, Any}","page":"Molecular system","title":"ElemCo.MSystem.b2a","text":"b2a(vals,skip)\n\nTransform from bohr to angstrom (if skip: no transformation). \n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_NAME-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.element_NAME","text":"element_NAME(name::AbstractString)\n\nReturn element name in all caps and without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_name-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.element_name","text":"element_name(name::AbstractString)\n\nReturn element name without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.genbasis4element-Tuple{Dict, AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.genbasis4element","text":"genbasis4element(basis::Dict,elem::AbstractString)\n\nSet element specific basis from, e.g., Dict(\"ao\"=>\"cc-pVDZ; o=aug-cc-pVDZ\",\"jkfit\"=>\"cc-pvdz-jkfit\")\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nalpha-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.guess_nalpha","text":"guess_nalpha(ms::MSys)\n\nGuess the number of alpha electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nbeta-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.guess_nbeta","text":"guess_nbeta(ms::MSys)\n\nGuess the number of beta electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nocc-Tuple{ElemCo.MSystem.MSys}","page":"Molecular system","title":"ElemCo.MSystem.guess_nocc","text":"guess_nocc(ms::MSys)\n\nGuess the number of alpha and beta occupied orbitals in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.n_orbitals_in_subshell-Tuple{Char}","page":"Molecular system","title":"ElemCo.MSystem.n_orbitals_in_subshell","text":"n_orbitals_in_subshell(shell::Char)\n\nReturn the number of orbitals in the subshell.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.ncoreorbs","page":"Molecular system","title":"ElemCo.MSystem.ncoreorbs","text":"ncoreorbs(elem::AbstractString, coretype::Symbol=:large)\n\nGuess the number of core orbitals in the element.\n\ncoretype:\n\n:large - large core (w/o semi-core)\n:small - small core (w/ semi-core)\n:none - no core\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.nshell4l_minbas-Tuple{Any, String}","page":"Molecular system","title":"ElemCo.MSystem.nshell4l_minbas","text":"nshell4l_minbas(nnum, basis::String)\n\nReturn the number of shells for each angular momentum in the minimal basis set. \n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.nuclear_charge_of_center-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.nuclear_charge_of_center","text":"nuclear_charge_of_center(elem::AbstractString)\n\nReturn the nuclear charge of the element.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.parse_electron_configuration-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.parse_electron_configuration","text":"parse_electron_configuration(e::AbstractString)\n\nParse the electron configuration string and return the number of electrons in each subshell.   e.g. \"[He] 2s^2 2p^6 3s^2 3p^6\" -> [SubShell(1,0,2), SubShell(2,0,2), SubShell(2,1,6), SubShell(3,0,2), SubShell(3,1,6)] \n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.parse_xyz_geometry-Tuple{AbstractArray, Dict}","page":"Molecular system","title":"ElemCo.MSystem.parse_xyz_geometry","text":"parse_xyz_geometry(xyz_lines::AbstractArray, basis::Dict)\n\nParse xyz geometry xyz_lines stored as a vector of strings.   Return array of atomic centers and an empty string in case of success.\n\nEmpty lines are skipped.   If the line is bohr or angstrom: change the units.   If the first line is a number: assume xyz format and skip the second line.   If parsing fails: return empty array and the line that failed.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.try2create_acenter","page":"Molecular system","title":"ElemCo.MSystem.try2create_acenter","text":"try2create_acenter(line::AbstractString, basis::Dict, bohr = true)\n\nCreate ACenter from a line <Atom> x y z. \n\nIf !bohr: coords are in angstrom.   Returns the center and a bool success variable.    If the line has a different format: return dummy center and false.\n\n\n\n\n\n","category":"function"},{"location":"mnpy/#Memory-maping-of-NPY-files","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"CurrentModule = ElemCo.MNPY","category":"page"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"MNPY","category":"page"},{"location":"mnpy/#ElemCo.MNPY","page":"Memory-maping of NPY files","title":"ElemCo.MNPY","text":"A simplified version of NPZ.jl for mmaping npy files\n\nNPY file format is described in https://github.com/numpy/numpy/blob/v1.7.0/numpy/lib/format.py\n\n\n\n\n\n","category":"module"},{"location":"mnpy/#Exported-functions","page":"Memory-maping of NPY files","title":"Exported functions","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"Modules = [MNPY]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"mnpy/#ElemCo.MNPY.mnpymmap-Tuple{AbstractString}","page":"Memory-maping of NPY files","title":"ElemCo.MNPY.mnpymmap","text":"mnpymmap(filename::AbstractString)\n\nMmap a variable from filename.  The input needs to be an npy file.\n\nnote: Zero-dimensional arrays\nZero-dimensional arrays are stripped while being read in, and the values that they contain are returned. This is a notable difference from numpy, where  numerical values are written out and read back in as zero-dimensional arrays.\n\nExamples\n\njulia> using NPZ\njulia> npzwrite(\"temp.npy\", ones(3))\njulia> mnpymmap(\"temp.npy\") # Mmaps the variable\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"mnpy/#Internal-functions","page":"Memory-maping of NPY files","title":"Internal functions","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"Modules = [MNPY]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"mnpy/#ElemCo.MNPY.readheader-Tuple{AbstractString}","page":"Memory-maping of NPY files","title":"ElemCo.MNPY.readheader","text":"readheader(filename)\n\nReturn a header corresponding to the variable contained in filename.  The header contains information about the eltype and size of the array that may be extracted using  the corresponding accessor functions.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#Bi-orthogonal-Hartree-Fock","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"CurrentModule = ElemCo.BOHF","category":"page"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"BOHF","category":"page"},{"location":"bohf/#ElemCo.BOHF","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF","text":"bi-orthogonal Hartree-Fock method     (using a similarity-transformed FciDump)\n\n\n\n\n\n","category":"module"},{"location":"bohf/#Exported-functions","page":"Bi-orthogonal Hartree-Fock","title":"Exported functions","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"Modules = [BOHF]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"bohf/#ElemCo.BOHF.bohf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bohf","text":"bohf(EC::ECInfo)\n\nPerform BO-HF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#ElemCo.BOHF.bouhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bouhf","text":"bouhf(EC::ECInfo)\n\nPerform BO-UHF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#ElemCo.BOHF.guess_boorb","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.guess_boorb","text":"guess_boorb(EC::ECInfo, guess::Symbol, uhf=false)\n\nCalculate starting guess for BO-MO coefficients (left and right).   Type of initial guess for MO coefficients is given by guess.   uhf indicates whether the calculation is restricted or unrestricted.\n\nSee ScfOptions.guess for possible values.   (Note: :SAD` is not possible here and will be replaced by identity matrix!)\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.jl-global-information","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"CurrentModule = ElemCo.ECInfos","category":"page"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ECInfos","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos","page":"ElemCo.jl global information","title":"ElemCo.ECInfos","text":"Various global infos \n\n\n\n\n\n","category":"module"},{"location":"ecinfos/#Main-structure","page":"ElemCo.jl global information","title":"Main structure","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ECInfo","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.ECInfo","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.ECInfo","text":"ECInfo\n\nGlobal information for ElemCo.\n\nscr::String: ⟨\"system-tmpdir/elemcojlscr/jl_*\"⟩ path to scratch directory.\next::String: ⟨\".bin\"⟩ extension of temporary files.\nverbosity::Int64: ⟨2⟩ verbosity level.\noptions::ElemCo.ECInfos.Options:  options.\nms::ElemCo.MSystem.MSys:  molecular system.\nfd::ElemCo.FciDump.FDump:  fcidump.\nfiles::Dict{String, String}:  information about (temporary) files. The naming convention is: prefix_ + name (+extension EC.ext added automatically). prefix can be:\nd for dressed integrals\nS for overlap matrix\nf for Fock matrix\ne for orbital energies\nD for density matrix\nh for core Hamiltonian\nC for transformation from one basis to another\nT for amplitudes\nU for trial vectors or Lagrange multipliers\nname is given by the subspaces involved:\no for occupied\nv for virtual\nO for occupied-β\nV for virtual-β\nm for (full) MO space\nM for (full) β-MO space\nA for AO basis\na for active orbitals\nd for doubly-occupied (closed-shell) orbitals\ns for singly-occupied (open-shell) orbitals\nS for singly-occupied with β electron (open-shell) orbitals\nP for auxiliary orbitals (fitting basis)\nL for auxiliary orbitals (Cholesky decomposition, orthogonal)\nX for auxiliary orbitals (amplitudes decomposition)\nThe order of subspaces is important, e.g., ov is occupied-virtual, vo is virtual-occupied. Normally, the first subspaces correspond to subscripts of the tensor. For example, T_vo contains the singles amplitudes T_a^i. Disambiguity can be resolved by introducing ^ to separate the subscripts from the superscripts, e.g., d_XX contains hat v_XY and d_^XX contains hat v^XY integrals.\n\nignore_error::Bool: ⟨false⟩ ignore various errors.\nspace::Dict{Char, Any}:  subspaces: 'o'ccupied, 'v'irtual, 'O'ccupied-β, 'V'irtual-β, ':'/'m'/'M' full MO.\n\n\n\n\n\n","category":"type"},{"location":"ecinfos/#Exported-functions","page":"ElemCo.jl global information","title":"Exported functions","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"Modules = [ECInfos]\nPrivate = false\nOrder = [:function]\nFilter = t -> t ∉ [ElemCo.file_exists, ElemCo.add_file!, ElemCo.copy_file!, ElemCo.delete_file!, ElemCo.delete_files!, ElemCo.delete_temporary_files!]","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_core!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_core!","text":"freeze_core!(EC::ECInfo, core::Symbol, freeze_nocc::Int, freeze_orbs=[])\n\nFreeze freeze_nocc occupied orbitals or orbitals on the freeze_orbs list.    If freeze_nocc is negative and freeze_orbs is empty: guess the number of core orbitals.\n\ncore as in MSystem.guess_ncore.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_nocc!-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_nocc!","text":"freeze_nocc!(EC::ECInfo, freeze)\n\nFreeze occupied orbitals from the freeze list.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_nvirt!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_nvirt!","text":"freeze_nvirt!(EC::ECInfo, nfreeze::Int, freeze_orbs=[])\n\nFreeze nfreeze virtual orbitals or orbitals on the freeze_orbs list.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.get_occvirt-Tuple{ElemCo.ECInfos.ECInfo, String, String, Any, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.get_occvirt","text":"get_occvirt(EC::ECInfo, occas::String, occbs::String, norb, nelec; ms2=0, orbsym=Vector{Int})\n\nUse a +/- string to specify the occupation. If occbs==\"-\", the occupation from occas is used (closed-shell).   If both are \"-\", the occupation is deduced from nelec and ms2.   The optional argument orbsym is a vector with length norb of orbital symmetries (1 to 8) for each orbital.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.is_closed_shell-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.is_closed_shell","text":"is_closed_shell(EC::ECInfo)\n\nCheck if the system is closed-shell    according the to the reference occupation and FCIDump.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.isalphaspin-Tuple{Char, Char}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.isalphaspin","text":"isalphaspin(sp1::Char,sp2::Char)\n\nTry to guess spin of an electron: lowcase α, uppercase β, non-letters skipped.   Return true for α spin.  Throws an error if cannot decide.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.len_spaces-Tuple{ElemCo.ECInfos.ECInfo, String}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.len_spaces","text":"len_spaces(EC::ECInfo, spaces::String)\n\nReturn lengths of spaces (e.g., \"vo\" for occupied and virtual orbitals).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_occ_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occ_orbs","text":"n_occ_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (for UHF: α).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_occb_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occb_orbs","text":"n_occb_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (β).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_orbs","text":"n_orbs(EC::ECInfo)\n\nReturn number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_virt_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virt_orbs","text":"n_virt_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (for UHF: α).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_virtb_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virtb_orbs","text":"n_virtb_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (β).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.parse_orbstring-Tuple{String}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.parse_orbstring","text":"parse_orbstring(orbs::String; orbsym=Vector{Int})\n\nParse a string specifying some list of orbitals, e.g.,    -3+5-8+10-12 → [1 2 3 5 6 7 8 10 11 12]   or use ':' and ';' instead of '-' and '+', respectively.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.reset_wf_info!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.reset_wf_info!","text":"reset_wf_info!(EC::ECInfo)\n\nReset ECInfos.WfOptions to default.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.restore_space!-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.restore_space!","text":"restore_space!(EC::ECInfo, space)\n\nRestore the space.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.save_space-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.save_space","text":"save_space(EC::ECInfo)\n\nSave the current subspaces of space.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!-Tuple{Any, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt, allopts)\n\nSet options for option opt from allopts.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!-Tuple{Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt; kwargs...)\n\nSet options for option opt using keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space!","text":"setup_space!(EC::ECInfo, norb, nelec, ms2, orbsym)\n\nSetup EC.space from norb, nelec, ms2, orbsym or occa/occb.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space_fd!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space_fd!","text":"setup_space_fd!(EC::ECInfo)\n\nSetup EC.space from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space_ms!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space_ms!","text":"setup_space_ms!(EC::ECInfo)\n\nSetup EC.space from molecular system EC.ms.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.space4spin-Tuple{Char, Bool}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.space4spin","text":"space4spin(sp::Char, alpha::Bool)\n\nReturn the space character for a given spin.   sp on input has to be lowercase.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#File-management","page":"ElemCo.jl global information","title":"File management","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"file_exists\nadd_file!\ncopy_file!\ndelete_file!\ndelete_files!\ndelete_temporary_files!","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.file_exists","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.file_exists","text":"file_exists(EC::ECInfo, name::String)\n\nCheck if file name exists in ECInfo.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.add_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.add_file!","text":"add_file!(EC::ECInfo, name::String, descr::String; overwrite=false)\n\nAdd file name to ECInfo with (space-separated) descriptions descr.   Possible description: tmp (temporary).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.copy_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.copy_file!","text":"copy_file!(EC::ECInfo, from::AbstractString, to::AbstractString; overwrite=false)\n\nCopy file from to to.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_file!","text":"delete_file!(EC::ECInfo, name::AbstractString)\n\nDelete file name from ECInfo.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_files!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_files!","text":"delete_files!(EC::ECInfo, which::AbstractString)\n\nDelete files in ECInfo which match description in which.\n\nwhich can be a space-separated string of descriptions (then all descriptions have to match)   Examples: \n\ndelete_files!(EC, \"tmp\") deletes all temporary files.\ndelete_files!(EC, \"tmp orbs\") deletes all temporary files with additional description \"orbs\"\n\n\n\n\n\ndelete_files!(EC::ECInfo, which::AbstractArray{String})\n\nDelete files in ECInfo which match any description in array which.\n\nExamples: \n\ndelete_files!(EC, [\"tmp\",\"orbs\"]) deletes all temporary files and all files with description \"orbs\".\ndelete_files!(EC, [\"tmp orbs\",\"tmp2\"]) deletes all temporary files with description \"orbs\" and all files with description \"tmp2\".\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_temporary_files!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_temporary_files!","text":"delete_temporary_files!(EC::ECInfo)\n\nDelete all temporary files in ECInfo.  \n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#Internal-functions","page":"ElemCo.jl global information","title":"Internal functions","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"Modules = [ECInfos]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.symorb2orb-Tuple{SubString, Vector{Int64}}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.symorb2orb","text":"symorb2orb(symorb::SubString, symoffset::Vector{Int})\n\nConvert a symorb (like 1.3 [orb.sym]) to an orbital number.   If no sym given, just return the orbital number converted to Int.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#Abstract-types","page":"ElemCo.jl global information","title":"Abstract types","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"CurrentModule = ElemCo.AbstractEC","category":"page"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"AbstractEC","category":"page"},{"location":"ecinfos/#ElemCo.AbstractEC","page":"ElemCo.jl global information","title":"ElemCo.AbstractEC","text":"Abstract types to resolve circular dependencies\n\n\n\n\n\n","category":"module"},{"location":"decomptools/#Tensor-decomposition-tools","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"ElemCo.DecompTools","category":"page"},{"location":"decomptools/#ElemCo.DecompTools","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools","text":"This module contains functions for tensor decomposition methods.\n\n\n\n\n\n","category":"module"},{"location":"decomptools/#Exported-functions","page":"Tensor-decomposition tools","title":"Exported functions","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"Modules = [ElemCo.DecompTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"decomptools/#ElemCo.DecompTools.calc_integrals_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.calc_integrals_decomposition","text":"calc_integrals_decomposition(EC::ECInfo)\n\nDecompose v_pr^qs as v_p^qL v_r^sL and store as mmL.\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.eigen_decompose","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.eigen_decompose","text":"eigen_decompose(T2mat, nvirt, nocc, tol=1e-6)\n\nEigenvector-decompose symmetric doubles T2[ai,bj] matrix:    T^ij_ab = U^iX_a T_XY U^jY_b δ_XY.   Return U^iX_a as U[a,i,X] for T_XX > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#ElemCo.DecompTools.iter_svd_decompose-NTuple{4, Any}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.iter_svd_decompose","text":"iter_svd_decompose(Amat, nvirt, nocc, naux)\n\nIteratively decompose A[ai,ξ] as U^iX_a Σ_X δ_XY V^Y_ξ.   Return U^iX_a as U[a,i,X] for first naux Σ_X\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.rotate_U2pseudocanonical-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.rotate_U2pseudocanonical","text":"rotate_U2pseudocanonical(EC::ECInfo, UaiX)\n\nDiagonalize ϵv - ϵo transformed with UaiX (for update).   Return eigenvalues and rotated UaiX\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.svd_decompose","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.svd_decompose","text":"svd_decompose(Amat, tol=1e-6)\n\nSVD-decompose A[ξ,ξ'] as U^X_ξ Σ_X δ_XY V^Y_ξ.   Return U^X_ξ as U[ξ,X] for Σ_X > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#ElemCo.DecompTools.svd_decompose-2","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.svd_decompose","text":"svd_decompose(Amat, nvirt, nocc, tol=1e-6)\n\nSVD-decompose A[ai,ξ] as U^iX_a Σ_X δ_XY V^Y_ξ.   Return U^iX_a as U[a,i,X] for Σ_X > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#Internal-functions","page":"Tensor-decomposition tools","title":"Internal functions","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"Modules = [ElemCo.DecompTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#MCSCF-program","page":"MCSCF program","title":"MCSCF program","text":"","category":"section"},{"location":"dfmcscf/#Exported-functions","page":"MCSCF program","title":"Exported functions","text":"","category":"section"},{"location":"dfmcscf/","page":"MCSCF program","title":"MCSCF program","text":"Modules = [ElemCo.DFMCSCF]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#ElemCo.DFMCSCF.davidson","page":"MCSCF program","title":"ElemCo.DFMCSCF.davidson","text":"davidson(H::Matrix, N::Integer, n::Integer, thres::Number, convTrack::Bool=false)\n\nCalculate one of the eigenvalues and corresponding eigenvector of the matrix H (usually the lowest eigenvalue),  N is the size of the matrix H,  n is the maximal size of projected matrix,  thres is the criterion of convergence,  convTrack is to decide whether the tracking of eigenvectors is used\n\n\n\n\n\n","category":"function"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dfmcscf-Tuple{ElemCo.ECInfos.ECInfo}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dfmcscf","text":"dfmcscf(EC::ECInfo; direct = false, guess=:SAD, IterMax=50)\n\nMain body of Density-Fitted Multi-Configurational Self-Consistent-Field method\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#Internal-functions","page":"MCSCF program","title":"Internal functions","text":"","category":"section"},{"location":"dfmcscf/","page":"MCSCF program","title":"MCSCF program","text":"Modules = [ElemCo.DFMCSCF]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_U-Tuple{ElemCo.ECInfos.ECInfo, Integer, Vector}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_U","text":"calc_U(EC::ECInfo, N_MO::Integer, x::Vector)\n\ncalculate orbital-rotational matrix U (approximately unitary because of the anti-hermitian property of the R which is constructed from x).\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_g-Tuple{Matrix, ElemCo.ECInfos.ECInfo}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_g","text":"calc_g(A::Matrix, EC::ECInfo)\n\nCalculate the orbital gradient g by antisymmetrizing the matrix A and rearranging the elements. The order of the elements in g[r,k] is (active|virtual) × (closed-shell|active) \n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_h-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix, Any, Matrix, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_h","text":"calc_h(EC::ECInfo, cMO::Matrix, D1::Matrix, D2, fock::Matrix, fockClosed::Matrix, A::Matrix)\n\nCalculate Hessian matrix h[rk,sl]. rk and sl are combined indices of r,k and s,l, where indexes r,s refer to open orbitals reordered as (active|virtual),  and indexes k,l refer to occupied orbitals reordered as (closed-shell|active).\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_realE-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix, Any, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_realE","text":"calc_realE(EC::ECInfo, fockClosed::Matrix, D1::Matrix, D2, cMO::Matrix)\n\nCalculate the energy with the given density matrices and (updated) cMO,  E = (h_i^i + ^cf_i^i) + ^1D^t_u ^cf_t^u + 05 ^2D^tv_uw v_tv^uw.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.checkE_modifyTrust-NTuple{4, Any}","page":"MCSCF program","title":"ElemCo.DFMCSCF.checkE_modifyTrust","text":"checkE_modifyTrust(E::Number, E_former::Number, E_2o::Number, trust::Number)\n\nCheck if the energy E is lower than the former energy E_former, if not, reject the update of coefficients and modify the trust region. Return reject::Bool and trust.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.denMatCreate-Tuple{ElemCo.ECInfos.ECInfo}","page":"MCSCF program","title":"ElemCo.DFMCSCF.denMatCreate","text":"denMatCreate(EC::ECInfo)\n\nCalculate the one particle density matrix and two particle density matrix of active electrons for high-spin determinant. D1[t,u] = ^1D^t_u = ΨhatE^t_uΨ  =  Ψ _σ hata^_tσ hata_uσΨ,  D2[t,u,v,w] = =^2D^tv_uw=05 ΨhatE^tv_uw+hatE^uv_twΨ,  in which hatE_tuvw = hatE^t_u hatE^v_w - δ_uv hatE^t_w = _στhata^_tσ hata^_vτ hata_wτ hata_uσ. Return D1 and D2.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dfACAS-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix, Any, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dfACAS","text":"dfACAS(EC::ECInfo, cMO::Matrix, D1::Matrix, D2, fock::Matrix, fockClosed::Matrix)\n\nCalculate the A-intermediate matrix in molecular orbital basis. return matrix A[p,q]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dffockCAS-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dffockCAS","text":"dffockCAS(EC::ECInfo, cMO::Matrix, D1::Matrix)\n\nCalculate fock matrices in atomic orbital basis.      Return matrix fock and fockClosed. fockClosed[μ,ν] = ^cf_μ^ν = h_μ^ν + 2v_μi^νi - v_μi^iν,  fock[μ,ν] = f_μ^ν = ^cf_μ^ν + D^t_u (v_μt^νu - 05 v_μt^uν).\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.projDenFitInt-Tuple{ElemCo.ECInfos.ECInfo, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.projDenFitInt","text":"projDenFitInt(EC::ECInfo, cMO::Matrix)\n\nRead the μνL density fitting integral,  project to μjL and μuL with the coefficients cMO,  j -> doubly occupied orbital, u -> active orbital,  save in \"AcL\" and \"AaL\" on disk. \n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.λTuning-Tuple{Number, Integer, Number, Number, Matrix, Vector}","page":"MCSCF program","title":"ElemCo.DFMCSCF.λTuning","text":"λTuning(trust::Number, maxit::Integer, λmax::Number, λ::Number, h::Matrix, g::Vector)\n\nFind the rotation parameters as the vector x in trust region, tuning λ with the norm of x in the iterations. Return λ and x.\n\n\n\n\n\n","category":"method"},{"location":"constants/#Constants-and-transformations-between-units","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"","category":"section"},{"location":"constants/","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"CurrentModule = ElemCo.Constants","category":"page"},{"location":"constants/","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"Modules = [Constants]","category":"page"},{"location":"constants/#ElemCo.Constants","page":"Constants and transformations between units","title":"ElemCo.Constants","text":"Various constants for the package.\n\nIndividual constants are not exported. Use Constants.<name> to access them.\n\n\n\n\n\n","category":"module"},{"location":"constants/#ElemCo.Constants.A0","page":"Constants and transformations between units","title":"ElemCo.Constants.A0","text":"Bohr radius [m]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AMU","page":"Constants and transformations between units","title":"ElemCo.Constants.AMU","text":"atomic mass unit [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AMU2KG","page":"Constants and transformations between units","title":"ElemCo.Constants.AMU2KG","text":"atomic mass unit to kg [kgu^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AU2DEBYE","page":"Constants and transformations between units","title":"ElemCo.Constants.AU2DEBYE","text":"au to Debye [Dau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.BOHR2ANGSTROM","page":"Constants and transformations between units","title":"ElemCo.Constants.BOHR2ANGSTROM","text":"Bohr to angstrom [AAau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.BOHR2METER","page":"Constants and transformations between units","title":"ElemCo.Constants.BOHR2METER","text":"Bohr to meter [mau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.C","page":"Constants and transformations between units","title":"ElemCo.Constants.C","text":"speed of light in vacuum [ms^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.DEBYE","page":"Constants and transformations between units","title":"ElemCo.Constants.DEBYE","text":"Debye [Cm]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.E","page":"Constants and transformations between units","title":"ElemCo.Constants.E","text":"elementary charge [C]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.EPS0","page":"Constants and transformations between units","title":"ElemCo.Constants.EPS0","text":"vacuum electric permittivity [Fm^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.H","page":"Constants and transformations between units","title":"ElemCo.Constants.H","text":"Planck constant [Js]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE","text":"Hartree energy [J]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2CM","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2CM","text":"Hartree to cm^{-1} [cm^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2EV","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2EV","text":"Hartree to eV [eVE_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2K","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2K","text":"Hartree to Kelvin [KE_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2KCAL","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2KCAL","text":"Hartree to kcal/mol [kcalmol^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2KJ","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2KJ","text":"Hartree to kJ/mol [kJmol^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HBAR","page":"Constants and transformations between units","title":"ElemCo.Constants.HBAR","text":"reduced Planck constant [Js]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.KB","page":"Constants and transformations between units","title":"ElemCo.Constants.KB","text":"Boltzmann constant [JK^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.KCAL","page":"Constants and transformations between units","title":"ElemCo.Constants.KCAL","text":"kcal/mol [Jmol^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.ME","page":"Constants and transformations between units","title":"ElemCo.Constants.ME","text":"electron mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MN","page":"Constants and transformations between units","title":"ElemCo.Constants.MN","text":"neutron mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MP","page":"Constants and transformations between units","title":"ElemCo.Constants.MP","text":"proton mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MU0","page":"Constants and transformations between units","title":"ElemCo.Constants.MU0","text":"vacuum magnetic permeability [NA^-2]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.NA","page":"Constants and transformations between units","title":"ElemCo.Constants.NA","text":"Avogadro constant [mol^-1]\n\n\n\n\n\n","category":"constant"},{"location":"mio/#I/O-routines","page":"I/O routines","title":"I/O routines","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"CurrentModule = ElemCo.MIO","category":"page"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"MIO","category":"page"},{"location":"mio/#ElemCo.MIO","page":"I/O routines","title":"ElemCo.MIO","text":"EC-specific IO routines\n\nUse to store arrays in a file, and to load them back.   Use memory-maps to store and load large arrays.\n\n\n\n\n\n","category":"module"},{"location":"mio/#Exported-functions","page":"I/O routines","title":"Exported functions","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"Modules = [MIO]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"mio/#ElemCo.MIO.mioclosemmap-Tuple{IO, AbstractArray}","page":"I/O routines","title":"ElemCo.MIO.mioclosemmap","text":"mioclosemmap(io::IO, array::AbstractArray)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.mioload-Tuple{String}","page":"I/O routines","title":"ElemCo.MIO.mioload","text":"mioload(fname::String; array_of_arrays = false)\n\nLoad arrays from a file fname.\n\nReturn an array of arrays.   If there is only one array - return array itself   (unless array_of_arrays is set to true).\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.miommap-Tuple{String}","page":"I/O routines","title":"ElemCo.MIO.miommap","text":"miommap(fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.mionewmmap-Tuple{String, Any, Tuple{Vararg{Int64}}}","page":"I/O routines","title":"ElemCo.MIO.mionewmmap","text":"mionewmmap(fname::String, Type, dims::Tuple{Vararg{Int}})\n\nCreate a new memory-map file for writing (overwrites existing file).   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.miosave-Union{Tuple{T}, Tuple{String, Vararg{AbstractArray{T}}}} where T","page":"I/O routines","title":"ElemCo.MIO.miosave","text":"miosave(fname::String,arrs::AbstractArray{T}...) where T\n\nSave arrays arrs in a file fname.\n\n\n\n\n\n","category":"method"},{"location":"mio/#Internal-functions","page":"I/O routines","title":"Internal functions","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"Modules = [MIO]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cc/#Coupled-cluster-methods","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"CurrentModule = ElemCo.CoupledCluster","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"CoupledCluster","category":"page"},{"location":"cc/#ElemCo.CoupledCluster","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster","text":"Coupled-cluster methods \n\nThe following coupled-cluster methods are implemented in ElemCo.jl:\n\nccsd - closed-shell implementation, for open-shell systems defaults to uccsd, \nuccsd - unrestricted implementation,\nrccsd - restricted implementation (for high-spin RHF reference only),\nccsd(t) - closed-shell implementation,\ndcsd - closed-shell implementation, for open-shell systems defaults to udcsd,\nudcsd - unrestricted implementation,\nrdcsd - restricted implementation (for high-spin RHF reference only),\nλccsd - calculation of Lagrange multipliers, closed-shell implementation,\nλccsd(t) - closed-shell implementation,\nλdcsd - calculation of Lagrange multipliers, closed-shell implementation.\n\nThe most efficient version of closed-shell CCSD/DCSD in ElemCo.jl combines the dressed factorization from [Kats2013] with  the cckext type of factorization from [Hampel1992] and is given by\n\nbeginalign*\nmathcalL = v_kl^cd tilde T^kl_cd + left(hat f_k^c + f_k^cright) T^k_c\n+ Λ_ij^ab left(hat v_kl^ij red+ v_kl^cd T^ij_cdright) T^kl_ab\n+ Λ_ij^ab R^ij_pq δ_a^p δ_b^q \nred+Λ_ij^ab v_kl^cdT^kj_adT^il_cb\n+ Λ_ij^ab mathcalP(aibj)leftleft(hat f_a^c - red2timesfrac12v_kl^cd tilde T^kl_adright)T^ij_cb\n- left(hat f_k^i + red2timesfrac12v_kl^cdtilde T^il_cdright)T^kj_ab right\n+ left(hat v_al^id\n+ frac12 v_kl^cdtilde T^ik_acright)tilde T^lj_db\n- hat v_ka^ic T^kj_cb -hat v_kb^ic T^kj_ac\nred-v_kl^cdT^ki_daleft(T^lj_cb-T^lj_bcright)\nleft- R^ij_pq left(δ_k^p δ_b^q - frac12 δ_k^p δ_l^q T^l_bright) T^k_a right\n+Λ_i^a R^ij_pqleft( 2δ_a^p δ_j^q - δ_j^p δ_a^q right)\n-Λ_i^a T^k_a R^ij_pqleft( 2δ_k^p δ_j^q - δ_j^p δ_k^q right)\n+Λ_i^a hat h_a^i + Λ_i^a hat f_j^b tilde T^ij_ab \n- Λ_i^a hat v_jk^ic tilde T^kj_ca\nendalign*\n\nwhere\n\nR^ij_pq = v_pq^rs left(left(T^ij_ab+T^i_a T^j_bright)δ_r^a δ_s^b \n+δ_r^i T^j_b δ_s^b + T^i_a δ_r^a δ_s^j + δ_r^i δ_s^j right) \n\nThe DCSD Lagrangian is obtained by removing terms in red. Integrals with hats are dressed integrals, i.e. they are obtained by dressing the integrals with the singles amplitudes, e.g., hat v_kl^id = v_kl^id + v_kl^cd T^i_c.\n\n[Kats2013]: D. Kats, and F.R. Manby, Sparse tensor framework for implementation of general local correlation methods, J. Chem. Phys. 138 (2013) 144101. doi:10.1063/1.4798940.\n\n[Hampel1992]: C. Hampel, K.A. Peterson, and H.-J. Werner, A comparison of the efficiency and accuracy of the quadratic configuration interaction (QCISD), coupled cluster (CCSD), and Brueckner coupled cluster (BCCD) methods, Chem. Phys. Lett. 190 (1992) 1. doi:10.1016/0009-2614(92)86093-W.\n\n\n\n\n\n","category":"module"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Lagrange multiplier equations for coupled cluster singles/doubles methods:","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nfracpartialmathcalLpartial T^m_e=\nleft(2 v_qm^pe - v_qm^epright) hat D_p^q + 2f_m^e \n- 2 Λ_ij^eb hat v_mb^ij\n+ 2 K_mj^rs delta_r^e left(delta_s^j + delta_s^b T^j_b right) \n+2 D_mj^kl hat v_kl^ej  \n- 2 Λ_ij^eb left(hat v_mb^cd T^ij_cdright)\n- D_d^e hat f_m^d + D_m^k hat f_k^e \n- 2 D_id^el hat v_ml^id \n+ 2 D_md^al hat v_al^ed\n+ 2bar D_ic^ek hat v_km^ic \n- 2bar D_mc^ak hat v_ka^ec \n- Λ_i^e hat f_m^i\n+ Λ_m^a hat f_a^e\n- Λ_i^e x_m^i - Λ_m^a x_a^e\nendaligned","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nfracpartialmathcalLpartial T^mn_ef=\ntilde v_mn^ef \n+ Λ_ij^ef left(hat v_mn^ij red+ v_mn^cd T^ij_cdright) \nred+ D_mn^kl v_kl^ef  + K_mn^rs delta_r^e delta_s^f\n+ mathcalP(emfn)left \nΛ_mn^af left(hat f_a^e - red2timesfrac12 x_a^eright)\n- Λ_in^ef left(hat f_m^i + red2timesfrac12 x_m^iright)\nright \n+ mathcalT(mn) leftred2timesfrac14 v_kn^ef D_m^k \n- red2timesfrac14 v_mn^cf D_c^e\n+ Λ_in^afleft(hat v_am^ie + v_km^cetilde T^ik_acright)right\nleft+ frac12 left(\n  Λ_m^e hat f_n^f \n+ Λ_n^a hat v_am^fe - Λ_i^f hat v_nm^ie right) right \n\nleft- Λ_in^af hat v_ma^ie - Λ_in^eb hat v_mb^if\nred-D_nc^fl v_ml^ce +bar D_nd^ekv_km^fd right\nendaligned","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"with","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nK_mn^rs = hat Lambda_mn^pq v_pq^rs \nhat Lambda_mn^pq = Λ_mn^abdelta_a^pdelta_b^q \n- Λ_mn^ab T^i_a  delta_i^p delta_b^q\n- Λ_mn^ab delta_a^p T^j_b delta_j^q\n+ Λ_mn^ab T^i_a T^j_b delta_i^p delta_j^q\nx_m^i = tilde T^il_cd v_ml^cd qquadqquad\nx_a^e = tilde T^kl_ac v_kl^ec\nmathcalT(mn) X_mn^ef = 2X_mn^ef - X_nm^ef\nD_ij^kl = Lambda_ij^cd T^kl_cd \nD_ib^aj = Lambda_ik^ac tilde T^kj_cb \nbar D_ib^aj = Lambda_ik^ac T^kj_cb + Lambda_ik^ca T^kj_bc \nendaligned","category":"page"},{"location":"cc/#Exported-functions","page":"Coupled-cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Modules = [CoupledCluster]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.calc_MP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_MP2","text":"calc_MP2(EC::ECInfo, addsingles=true)\n\nCalculate closed-shell MP2 energy and amplitudes.    The amplitudes are stored in T_vvoo file.   If addsingles: singles are also calculated and stored in T_vo file.   Return EMp2 \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2","text":"calc_UMP2(EC::ECInfo, addsingles=true)\n\nCalculate unrestricted MP2 energy and amplitudes.    The amplitudes are stored in T_vvoo, T_VVOO, and T_vVoO files.   If addsingles: singles are also calculated and stored in T_vo and T_VO files.   Return EMp2\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2_energy","text":"calc_UMP2_energy(EC::ECInfo, addsingles=true)\n\nCalculate open-shell MP2 energy from precalculated amplitudes.    If addsingles: singles energy is also calculated.   Return EMp2 \n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc","text":"calc_cc(EC::ECInfo, method::ECMethod)\n\nCalculate coupled cluster amplitudes.\n\nExact specification of the method is given by method.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_lm_cc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_lm_cc","text":"calc_lm_cc(EC::ECInfo, method::ECMethod)\n\nCalculate coupled cluster Lagrange multipliers.\n\nExact specification of the method is given by method.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT","text":"calc_pertT(EC::ECInfo; save_t3=false)\n\nCalculate (T) correction for closed-shell CCSD.\n\nReturn ( (T)-energy, [T]-energy))\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ΛpertT-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ΛpertT","text":"calc_ΛpertT(EC::ECInfo)\n\nCalculate (T) correction for closed-shell ΛCCSD(T).\n\nThe amplitudes are stored in T_vvoo file,    and the Lagrangian multipliers are stored in U_vvoo file.   Return ( (T) energy, [T] energy)\n\n\n\n\n\n","category":"method"},{"location":"cc/#Internal-functions","page":"Coupled-cluster methods","title":"Internal functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Modules = [CoupledCluster]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.add_to_singles_and_doubles_residuals-Tuple{Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.add_to_singles_and_doubles_residuals","text":"add_to_singles_and_doubles_residuals(EC, R1, R2)\n\nAdd contributions from triples to singles and doubles residuals.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_1RDM-NTuple{4, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_1RDM","text":"calc_1RDM(U1, U2, T1, T2)\n\nCalculate the 1RDM for the closed-shell CCSD or DCSD equations.\n\nReturn D1[p,q]=D_p^q, the 1RDM without T1 singles terms,  and dD1[p,q]=hat D_p^q, the 1RDM with all T1 terms included.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_3ext_times_T2-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_3ext_times_T2","text":"calc_3ext_times_T2(EC::ECInfo)\n\nCalculate hat v_mb^cd T^ij_cd intermediate    required in calc_ccsd_vector_times_Jacobian    and store as vT_ovoo[m,b,i,j].\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_4idx_T3T3_XY-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_4idx_T3T3_XY","text":"calc_4idx_T3T3_XY(EC::ECInfo, T2, UvoX, ϵX)\n\nCalculate D^ij_ab = T^i_aXY T^j_bXY using half-decomposed imaginary-shifted perturbative triple amplitudes    T^i_aXY from T2 (and UvoX)\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, scalepp=false)\n\nCalculate D^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl.   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, spin::Symbol)\n\nCalculate ^σσD^ij_pq = T^ij_cd + P_ij(T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl)   with P_ij X_ij = X_ij - X_ji.   Return as D[pqij] \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2ab","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2ab","text":"calc_D2ab(EC::ECInfo, T1a, T1b, T2ab, scalepp=false)\n\nCalculate ^αβD^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_resid-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_resid","text":"calc_ccsd_resid(EC::ECInfo, T1, T2; dc=false, tworef=false, fixref=false)\n\nCalculate CCSD or DCSD closed-shell residual.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_resid-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_resid","text":"calc_ccsd_resid(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab; dc=false, tworef=false, fixref=false)\n\nCalculate UCCSD or UDCSD residual.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian","text":"calc_ccsd_vector_times_Jacobian(EC::ECInfo, U1, U2; dc=false)\n\nCalculate the vector times the Jacobian for the closed-shell CCSD or DCSD equations.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsdt","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsdt","text":"calc_ccsdt(EC::ECInfo, useT3=false, cc3=false)\n\nCalculate decomposed closed-shell DC-CCSDT amplitudes.\n\nIf useT3: (T) amplitudes from a preceding calculations will be used as starting guess.   If cc3: calculate CC3 amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_correlation_norm-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_correlation_norm","text":"calc_correlation_norm(EC::ECInfo, U1, U2)\n\nCalculate the norm of the correlation part of the CCSD or DCSD equations   using Lagrange multipliers and amplitudes.\n\nReturn ΛΨ = Λ_1T_1 + Λ_2T_2+frac12T_1 T_1.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_dU2-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dU2","text":"calc_dU2(EC::ECInfo, T1, U2)\n\nCalculate the \"dressed\" Λ_2 for the closed-shell CCSD/DCSD.\n\nReturn dU2[p,q,m,n]=Λ_mn^abδ_a^p δ_b^q - Λ_mn^abT^i_a δ_i^p δ_b^q - Λ_mn^abδ_a^p T^j_b δ_j^q + Λ_mn^abT^i_a T^j_b δ_i^p δ_j^q.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2a, T2b, T2ab; fock_only=false)\n\nCalculate energy for αα (T2a), ββ (T2b) and αβ (T2ab) doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2; fock_only=false)\n\nCalculate coupled-cluster closed-shell doubles energy.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1a, T1b=Float64[];\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nDress integrals with singles.\n\nhat v_ab^cd, hat v_ab^ci, hat v_ak^cd and hat v_ab^ij are only    calculated if requested in EC.options.cc or using keyword-arguments.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Vararg{Char, 4}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1, T12, o1::Char, v1::Char, o2::Char, v2::Char;\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nDress integrals with singles amplitudes. \n\nThe singles and orbspaces for first and second electron are T1, o1, v1 and T12, o2, v2, respectively.   The integrals from EC.fd are used and dressed integrals are stored as d_????.   hat v_ab^cd, hat v_ab^ci, hat v_ak^cd and hat v_ab^ij are only    calculated if requested in EC.options.cc or using keyword-arguments.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 10}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, R1a, R1b, R2a, R2b, R2ab)\n\nCalculate singles and doubles Hylleraas energy.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas4spincase-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 9}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas4spincase","text":"calc_hylleraas4spincase(EC::ECInfo, o1, v1, o2, v2, T1, T2, R1, R2, fov)\n\nCalculate singles and doubles Hylleraas energy for one spin case.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1a, T1b; fock_only=false)\n\nCalculate energy for α (T1a) and β (T1b) singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_decomposition","text":"calc_triples_decomposition(EC::ECInfo)\n\nDecompose T^ijk_abc as U^iX_a U^jY_b U^kZ_c T_XYZ.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_decomposition_without_triples-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_decomposition_without_triples","text":"calc_triples_decomposition_without_triples(EC::ECInfo, T2)\n\nDecompose T^ijk_abc as U^iX_a U^jY_b U^kZ_c T_XYZ    without explicit calculation of T^ijk_abc.\n\nCompute perturbative T^i_aXY and decompose D^ij_ab = (T^i_aXY T^j_bXY) to get U^iX_a.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_residuals","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_residuals","text":"calc_triples_residuals(EC::ECInfo, T1, T2, cc3 = false)\n\nCalculate decomposed triples DC-CCSDT or CC3 residuals.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_closedshell-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_closedshell","text":"dress_fock_closedshell(EC::ECInfo, T1)\n\nDress the fock matrix (closed-shell). The dressed fock matrix is stored as df_mm.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_oppositespin-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_oppositespin","text":"dress_fock_oppositespin(EC::ECInfo)\n\nAdd the dressed opposite-spin part to the dressed Fock matrix. \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_samespin-Tuple{ElemCo.ECInfos.ECInfo, Any, Char, Char}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_samespin","text":"dress_fock_samespin(EC::ECInfo, T1, o1::Char, v1::Char)\n\nDress the fock matrix (same-spin part). \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.pseudo_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.pseudo_dressed_ints","text":"pseudo_dressed_ints(EC::ECInfo, unrestricted=false;\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nSave non-dressed integrals in files instead of dressed integrals.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.test_UaiX-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_UaiX","text":"test_UaiX(EC, UaiX)\n\nTest UaiX\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_add_to_singles_and_doubles_residuals-NTuple{4, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_add_to_singles_and_doubles_residuals","text":"test_add_to_singles_and_doubles_residuals(R1, R2, T1, T2)\n\nTest R1(T3) and R2(T3)\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_calc_pertT_from_T3-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_calc_pertT_from_T3","text":"test_calc_pertT_from_T3(EC, T3)\n\nTest [T]\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_dressed_ints-Tuple{Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_dressed_ints","text":"test_dressed_ints(EC, T1)\n\nCompare 3-idx dressed integrals to 4-idx dressed integrals.\n\n\n\n\n\n","category":"method"},{"location":"options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"CurrentModule = ElemCo.ECInfos","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"Options","category":"page"},{"location":"options/#ElemCo.ECInfos.Options","page":"Options","title":"ElemCo.ECInfos.Options","text":"Options for ElemCo.jl.\n\nwf::ElemCo.ECInfos.WfOptions:  Wavefunction options (WfOptions).\nscf::ElemCo.ECInfos.ScfOptions:  SCF options (ScfOptions).\nint::ElemCo.ECInfos.IntOptions:  Integral options (IntOptions).\ncc::ElemCo.ECInfos.CcOptions:  Coupled-Cluster options (CcOptions).\ncholesky::ElemCo.ECInfos.CholeskyOptions:  Cholesky options (CholeskyOptions).\ndiis::ElemCo.ECInfos.DiisOptions:  DIIS options (DiisOptions).\n\n\n\n\n\n","category":"type"},{"location":"options/","page":"Options","title":"Options","text":"Modules = [ECInfos]\nPages = [\"options.jl\"]\nFilter = t -> typeof(t) !== DataType || !(t <: ElemCo.ECInfos.Options)","category":"page"},{"location":"options/#ElemCo.ECInfos.CcOptions","page":"Options","title":"ElemCo.ECInfos.CcOptions","text":"Options for Coupled-Cluster calculation.\n\nthr::Float64: ⟨1.e-10⟩ convergence threshold.\nmaxit::Int64: ⟨50⟩ maximum number of iterations.\nshifts::Float64: ⟨0.15⟩ level shift for singles.\nshiftp::Float64: ⟨0.2⟩ level shift for doubles.\nshiftt::Float64: ⟨0.2⟩ level shift for triples.\nproperties::Bool: ⟨false⟩ calculate properties.\nampsvdtol::Float64: ⟨1.e-3⟩ amplitude decomposition threshold.\nampsvdfac::Float64: ⟨1.e-2⟩ tightening amplitude decomposition factor (for the two-step decomposition).\nuse_kext::Bool: ⟨true⟩ use kext for doubles residual.\ncalc_d_vvvv::Bool: ⟨false⟩ calculate dressed <vv|vv>.\ncalc_d_vvvo::Bool: ⟨false⟩ calculate dressed <vv|vo>.\ncalc_d_vovv::Bool: ⟨false⟩ calculate dressed <vo|vv>.\ncalc_d_vvoo::Bool: ⟨false⟩ calculate dressed <vv|oo>.\ntriangular_kext::Bool: ⟨true⟩ use a triangular kext if possible.\ncalc_t3_for_decomposition::Bool: ⟨false⟩ calculate (T) for decomposition.\ndeco_ishiftp::Float64: ⟨0.0⟩ imaginary shift for denominator in doubles decomposition.\ndeco_ishiftt::Float64: ⟨0.0⟩ imaginary shift for denominator in triples decomposition.\nuse_projx::Bool: ⟨false⟩ use a projected exchange for contravariant doubles amplitudes in SVD-DCSD, tilde T_XY = U^a_iX U^b_jY tilde T^ij_ab.\nuse_full_t2::Bool: ⟨false⟩ use full doubles amplitudes in SVD-DCSD. The decomposition is used only for N^6 scaling terms.\nproject_vovo_t2::Int64: ⟨2⟩ what to project in v_ak^ci T^kj_cb in SVD-DCSD: 0: both, 1: amplitudes, 2: residual, 3: robust fit.\ndecompose_full_doubles::Bool: ⟨false⟩ decompose full doubles amplitudes in SVD-DCSD (slow).\nstart::String: ⟨\"cc_amplitudes\"⟩ main part of filename for start amplitudes. For example, the singles amplitudes are read from start*\"_singles\"\nsave::String: ⟨\"cc_amplitudes\"⟩ main part of filename to save amplitudes. For example, the singles amplitudes are saved to save*\"_singles\"\nstart_lm::String: ⟨\"cc_multipliers\"⟩ main part of filename for start Lagrange multipliers. For example, the singles Lagrange multipliers are read from start_lm*\"_singles\"\nsave_lm::String: ⟨\"cc_multipliers\"⟩ main part of filename to save Lagrange multipliers. For example, the singles Lagrange multipliers are saved to save_lm*\"_singles\"\nnomp2::Int64: ⟨0⟩ Don't use MP2 amplitudes as starting guess for the CC amplitudes\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CholeskyOptions","page":"Options","title":"ElemCo.ECInfos.CholeskyOptions","text":"Options for Cholesky decomposition.\n\nthr::Float64: ⟨1.e-6⟩ cholesky threshold.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.DiisOptions","page":"Options","title":"ElemCo.ECInfos.DiisOptions","text":"Options for DIIS.\n\nmaxdiis::Int64: ⟨6⟩ maximum number of DIIS vectors.\nresthr::Float64: ⟨10.0⟩ DIIS residual threshold.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.IntOptions","page":"Options","title":"ElemCo.ECInfos.IntOptions","text":"Options for integral calculation.\n\ndf::Bool: ⟨true⟩ use density-fitted integrals.\nfcidump::String: ⟨\"\"⟩ store integrals in FCIDump format.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.ScfOptions","page":"Options","title":"ElemCo.ECInfos.ScfOptions","text":"Options for SCF calculation.\n\nthr::Float64: ⟨1.e-10⟩ convergence threshold.\nthren::Float64: ⟨sqrt(thr)*0.1⟩ energy convergence threshold (used additionally to thr).\nmaxit::Int64: ⟨50⟩ maximum number of iterations.\nimagtol::Float64: ⟨1.e-8⟩ tolerance for imaginary part of MO coefs (for biorthogonal).\ndirect::Bool: ⟨false⟩ direct calculation without storing integrals.\nguess::Symbol: ⟨:SAD⟩ orbital guess:\n:HCORE from core Hamiltonian\n:SAD from atomic densities\n:GWH not implemented yet\n:ORB from previous orbitals stored in file WfOptions.orb\n\ntemperature_guess::Float64:  ⟨0.0⟩ Fermi-Dirac temperature for starting guess (at the moment works only for BO-HF).\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.WfOptions","page":"Options","title":"ElemCo.ECInfos.WfOptions","text":"Options for wavefunction/orbitals.\n\nms2::Int64: ⟨-1⟩ spin magnetic quantum number times two (2×mₛ) of the system.\nnelec::Int64: ⟨-1⟩ number of electrons. If < 0, the number of electrons is read from the FCIDump file or guessed for the neutral system.\ncharge::Int64: ⟨0⟩ charge of the system (relative to nelec/FCIDump/neutral system!).\norb::String: ⟨\"C_Am\"⟩ filename of MO coefficients. Used by all programs to read and write orbitals from/to file.\nleft::String: ⟨\"-left\"⟩ addition to the filename for left orbitals (for biorthogonal calculations).\ncore::Symbol: ⟨:large⟩ core type for frozen-core approximation:\n:none no frozen-core approximation,\n:small semi-core orbitals correlated,\n:large semi-core orbitals frozen.\nfreeze_nocc::Int64: ⟨-1⟩ number of occupied (core) orbitals to freeze (overwrites core).\nfreeze_nvirt::Int64: ⟨0⟩ number of virtual (highest) orbitals to freeze.\nocca::String: ⟨\"-\"⟩ occupied α (or closed-shell) orbitals.\noccb::String: ⟨\"-\"⟩ occupied β orbitals. If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).\n\n\n\n\n\n","category":"type"},{"location":"#ElemCo.jl-Documentation","page":"Home","title":"ElemCo.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ElemCo.jl is a Julia package for computing electronic structure properties of molecules and materials. It provides a set of tools for performing quantum chemical calculations, including Hartree-Fock and post-HF methods.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install ElemCo.jl using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ElemCo\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Computing-density-fitted-Hartree-Fock-and-Coupled-Cluster-methods","page":"Home","title":"Computing density-fitted Hartree-Fock and Coupled Cluster methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To compute density-fitted Hartree-Fock (DF-HF) using ElemCo.jl, you can use the @dfhf macro. In order to run post-HF calculations, the integrals have to be transformed to the MO basis (using the @dfints macro), and the coupled cluster calculations can be performed using @cc macro. Here's an example of how you can use these macros:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mp2fit\"=>\"cc-pvdz-rifit\")\n\n# Compute DF-HF \n@dfhf\n# Calculate MO integrals \n@dfints\n# Run CCSD(T) calculation\n@cc ccsd(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, calculates integrals using density fitting (mp2fit basis) and computes CCSD(T) energy.","category":"page"},{"location":"#Setting-options","page":"Home","title":"Setting options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To set options (ElemCo.ECInfos.Options) for the DF-HF, CC, etc calculations, you can use the @opt macro. Here's an example of how you can use this macro:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the maximum number of iterations to 10\n@opt scf maxit=10\n\n# Compute DF-HF using the new options\n@dfhf","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code sets the maximum number of iterations for the SCF procedure to 10 using the @opt macro, and then computes DF-HF using the new options using the @dfhf macro.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equations for the methods implemented in ElemCo.jl.","category":"page"},{"location":"dftools/#Density-fitting-tools","page":"Density-fitting tools","title":"Density-fitting tools","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"ElemCo.DFTools","category":"page"},{"location":"dftools/#ElemCo.DFTools","page":"Density-fitting tools","title":"ElemCo.DFTools","text":"This module contains various utils for density fitting.\n\n\n\n\n\n","category":"module"},{"location":"dftools/#Exported-functions","page":"Density-fitting tools","title":"Exported functions","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"Modules = [ElemCo.DFTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dftools/#ElemCo.DFTools.generate_AO_DF_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_AO_DF_integrals","text":"generate_AO_DF_integrals(EC::ECInfo, fitbasis=\"mp2fit\"; save3idx=true)\n\nGenerate AO integrals using DF + Cholesky.   If save3idx is true, save Cholesky-decomposed 3-index integrals,    otherwise save pseudo-square-root-inverse Cholesky decomposition.\n\n\n\n\n\n","category":"function"},{"location":"dftools/#ElemCo.DFTools.generate_DF_integrals-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_DF_integrals","text":"generate_DF_integrals(EC::ECInfo, cMO)\n\nGenerate v_p^qL and f_p^q with   v_pr^qs = v_p^qL δ_LL v_r^sL.   The v_p^qL are generated using mp2fit fitting basis, and   the f_p^q are generated using jkfit fitting basis.   The integrals are stored in files mmL and f_mm.\n\nReturn reference energy (calculated using jkfit fitting basis).\n\n\n\n\n\n","category":"method"},{"location":"dftools/#ElemCo.DFTools.get_auxblks","page":"Density-fitting tools","title":"ElemCo.DFTools.get_auxblks","text":"get_auxblks(naux, maxblocksize=100, strict=false)\n\nGenerate ranges for block indices for auxiliary basis (for loop over blocks).\n\nIf strict is true, the blocks will be of size maxblocksize (except for the last block).   Otherwise the actual block size will be as close as possible to blocksize such that   the resulting blocks are of similar size.\n\n\n\n\n\n","category":"function"},{"location":"dftools/#Internal-functions","page":"Density-fitting tools","title":"Internal functions","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"Modules = [ElemCo.DFTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dftools/#ElemCo.DFTools.generate_3idx_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_3idx_integrals","text":"generate_3idx_integrals(EC::ECInfo, cMO, fitbasis=\"mp2fit\")\n\nGenerate v_p^qL with   v_pr^qs = v_p^qL δ_LL v_r^sL   and store in file mmL.\n\n\n\n\n\n","category":"function"},{"location":"ecmethod/#ElemCo.jl-methods","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"CurrentModule = ElemCo.ECMethods","category":"page"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ECMethods","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods","page":"ElemCo.jl methods","title":"ElemCo.ECMethods","text":"Specify methods available for electron-correlation calculations\n\n\n\n\n\n","category":"module"},{"location":"ecmethod/#Main-structure","page":"ElemCo.jl methods","title":"Main structure","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ECMethod","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods.ECMethod","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.ECMethod","text":"ECMethod\n\nDescription of the electron-correlation method\n\ntheory: theory level: \"MP\", \"CC\", \"DC\".\nprefix: prefix of the methods, e.g., \"EOM\", \"U\", \"R\", \"2D\", \"FRS\", \"FRT\".\nsuffix: suffix of the methods.\nexclevel:  excitation level for each class (exclevel[1] for singles etc.). Possible values: :none, :full, :pert, :pertiter.\npertlevel:  perturbation theory level (relevant for MP methods).\n\n\n\n\n\n","category":"type"},{"location":"ecmethod/#Exported-functions","page":"ElemCo.jl methods","title":"Exported functions","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"Modules = [ECMethods]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods.has_prefix-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.has_prefix","text":"has_prefix(method::ECMethod, spec::AbstractString)\n\nReturn true if method has prefix spec, e.g., \"EOM\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.has_suffix-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.has_suffix","text":"has_suffix(method::ECMethod, spec::AbstractString)\n\nReturn true if method has suffix spec, e.g., \"F12\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.is_unrestricted-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.is_unrestricted","text":"is_unrestricted(method::ECMethod)\n\nReturn true if method is unrestricted.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.max_full_exc-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.max_full_exc","text":"max_full_exc(method::ECMethod)\n\nReturn the highest full excitation level of the method.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.method_name","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.method_name","text":"method_name(method::ECMethod, main::Bool = true)\n\nReturn string representation of method.   If main is true, return only the main part of the name, i.e., without   perturbative corrections.\n\n\n\n\n\n","category":"function"},{"location":"ecmethod/#ElemCo.ECMethods.set_prefix!-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_prefix!","text":"set_prefix!(method::ECMethod, spec::AbstractString)\n\nSet method to have prefix spec, e.g., \"EOM\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.set_suffix!-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_suffix!","text":"set_suffix!(method::ECMethod, spec::AbstractString)\n\nSet method to have suffix spec, e.g., \"F12\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.set_unrestricted!-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_unrestricted!","text":"set_unrestricted!(method::ECMethod)\n\nSet method to unrestricted.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#Internal-functions","page":"ElemCo.jl methods","title":"Internal functions","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"Modules = [ECMethods]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"ecmethod/#Base.show-Tuple{IO, ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"Base.show","text":"show(io::IO, method::ECMethod)\n\nPrint method to io.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.check_specs-Tuple{AbstractString, Any, Vector}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.check_specs","text":"check_specs(mname::AbstractString, pos, specs::Vector)\n\nCheck if starting from position pos, mname contains any of specs   and return a list of the matching ones (without dashes for multiple-letter specs!)    and the final position after specs.\n\n\n\n\n\n","category":"method"}]
}
