var documenterSearchIndex = {"docs":
[{"location":"tensortools/#Tensor-tools","page":"Tensor tools","title":"Tensor tools","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"CurrentModule = ElemCo.TensorTools","category":"page"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"TensorTools","category":"page"},{"location":"tensortools/#ElemCo.TensorTools","page":"Tensor tools","title":"ElemCo.TensorTools","text":"tensor tools,      e.g., access to integrals, load/save intermediates... \n\n\n\n\n\n","category":"module"},{"location":"tensortools/#I/O-functions","page":"Tensor tools","title":"I/O functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"save!\nload\nmmap\nnewmmap\nclosemmap","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.save!","page":"Tensor tools","title":"ElemCo.TensorTools.save!","text":"save!(EC::ECInfo, fname::String, a::AbstractArray...; description=\"tmp\", overwrite=true)\n\nSave array or tuple of arrays a to file fname in EC.scr directory.   Add file to EC.files with description.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.load","page":"Tensor tools","title":"ElemCo.TensorTools.load","text":"load(EC::ECInfo, fname::String)\n\nLoad array from file fname in EC.scr directory.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.mmap","page":"Tensor tools","title":"ElemCo.TensorTools.mmap","text":"mmap(EC::ECInfo, fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.newmmap","page":"Tensor tools","title":"ElemCo.TensorTools.newmmap","text":"newmmap(EC::ECInfo, fname::String, Type, dims::Tuple{Vararg{Int}}; description=\"tmp\")\n\nCreate a new memory-map file for writing (overwrites existing file).   Add file to EC.files with description.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.closemmap","page":"Tensor tools","title":"ElemCo.TensorTools.closemmap","text":"closemmap(EC::ECInfo, file, array)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Integral-extraction","page":"Tensor tools","title":"Integral extraction","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"ints1\nints2","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.ints1","page":"Tensor tools","title":"ElemCo.TensorTools.ints1","text":"ints1(EC::ECInfo, spaces::String, spincase = nothing)\n\nReturn subset of 1e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification. \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.ints2","page":"Tensor tools","title":"ElemCo.TensorTools.ints2","text":"ints2(EC::ECInfo, spaces::String, spincase = nothing, detri = true)\n\nReturn subset of 2e⁻ integrals according to spaces. \n\nThe spincase∈{:α,:β} can explicitly be given, or will be deduced    from upper/lower case of spaces specification.   If the last two indices are stored as triangular and detri - make them full,   otherwise return as a triangular cut.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Tensor-manipulation","page":"Tensor tools","title":"Tensor manipulation","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"sqrtinvchol\ninvchol\nrotate_eigenvectors_to_real!","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.sqrtinvchol","page":"Tensor tools","title":"ElemCo.TensorTools.sqrtinvchol","text":"sqrtinvchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn NON-SYMMETRIC (pseudo)sqrt-inverse of a hermitian matrix using Cholesky decomposition.\n\nStarting from A^-1 = A^-1 L (A^-1 L)^ = M M^   with A = L L^.   By solving the equation L^ M = 1 (for low-rank: using QR decomposition).   Return M.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.invchol","page":"Tensor tools","title":"ElemCo.TensorTools.invchol","text":"invchol(A::AbstractMatrix; tol = 1e-8, verbose = false)\n\nReturn (pseudo)inverse of a hermitian matrix using Cholesky decomposition .\n\nThe inverse is calculated as A^-1 = A^-1 L (A^-1 L)^ = M M^   with A = L L^.   By solving the equation L^ M = 1 (for low-rank: using QR decomposition) \n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.rotate_eigenvectors_to_real!","page":"Tensor tools","title":"ElemCo.TensorTools.rotate_eigenvectors_to_real!","text":"rotate_eigenvectors_to_real!(evecs::AbstractMatrix, evals::AbstractVector)\n\nIn-place transform complex eigenvectors of a real matrix to a real space    such that they block-diagonalize the matrix.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Other-exported-functions","page":"Tensor tools","title":"Other exported functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"Modules = [TensorTools]\nPrivate = false\nOrder = [:function]\nFilter = t -> t ∉ [ElemCo.save!, ElemCo.load, ElemCo.mmap, ElemCo.newmmap, ElemCo.closemmap, ElemCo.ints1, ElemCo.ints2, ElemCo.sqrtinvchol, ElemCo.invchol, ElemCo.rotate_eigenvectors_to_real! ]","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.detri_int2-NTuple{6, Any}","page":"Tensor tools","title":"ElemCo.TensorTools.detri_int2","text":"detri_int2(allint2, norb, sp1, sp2, sp3, sp4)\n\nReturn full 2e⁻ integrals <sp1 sp2 | sp3 sp4> from allint2 with last two indices as a triangular index.\n\n\n\n\n\n","category":"method"},{"location":"tensortools/#ElemCo.TensorTools.get_spaceblocks","page":"Tensor tools","title":"ElemCo.TensorTools.get_spaceblocks","text":"get_spaceblocks(space, maxblocksize=100, strict=false)\n\nGenerate ranges for block indices for space (for loop over blocks).\n\nspace is a range or an array of indices.    Even if space is non-contiguous, the blocks will be contiguous.    If strict is true, the blocks will be of size maxblocksize (except for the last block and non-contiguous index-ranges).   Otherwise the actual block size will be as close as possible to blocksize such that   the resulting blocks are of similar size.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#ElemCo.TensorTools.print_nonzeros-Tuple{AbstractArray}","page":"Tensor tools","title":"ElemCo.TensorTools.print_nonzeros","text":"print_nonzeros(tensor::AbstractArray; ϵ=1.e-12, fname::String=\"\")\n\nPrint cartesian index alongside value of array for elements with absolute value greater or equal than ϵ   either to stdout or to a file.\n\n\n\n\n\n","category":"method"},{"location":"tensortools/#ElemCo.TensorTools.svd_thr","page":"Tensor tools","title":"ElemCo.TensorTools.svd_thr","text":"svd_thr(Amat::AbstractMatrix, thr=1.e-12)\n\nReturn SVD of a matrix with singular values below thr set to zero.\n\n\n\n\n\n","category":"function"},{"location":"tensortools/#Internal-functions","page":"Tensor tools","title":"Internal functions","text":"","category":"section"},{"location":"tensortools/","page":"Tensor tools","title":"Tensor tools","text":"Modules = [TensorTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"tensortools/#ElemCo.TensorTools.triinds","page":"Tensor tools","title":"ElemCo.TensorTools.triinds","text":"triinds(norb, sp1::AbstractArray{Int}, sp2::AbstractArray{Int}, reverseCartInd = false)\n\nGenerate set of CartesianIndex for addressing the lhs and    a bitmask for the rhs for transforming a triangular index from 1:norb     to two original indices in spaces sp1 and sp2.   If reverse: the cartesian indices are reversed.\n\n\n\n\n\n","category":"function"},{"location":"fockfactory/#Fock-builders","page":"Fock builders","title":"Fock builders","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"ElemCo.FockFactory","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory","page":"Fock builders","title":"ElemCo.FockFactory","text":"Fock builders (using FciDump or DF integrals) \n\n\n\n\n\n","category":"module"},{"location":"fockfactory/#Exported-functions","page":"Fock builders","title":"Exported functions","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"Modules = [ElemCo.FockFactory]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory.gen_density_matrix-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_density_matrix","text":"gen_density_matrix(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray, occvec)\n\nGenerate D_μν=C^l_μi C^r_νi with i defined by occvec.   Only real part of D_μν is kept.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_dffock","text":"gen_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute DF-HF Fock matrix (integral direct) in AO basis.\n\nIf cMO is unrestricted, α and β Fock matrices will be returned.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_dffock","text":"gen_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute DF-HF Fock matrix in AO basis   (using precalculated Cholesky-decomposed integrals).\n\nIf cMO is unrestricted, α and β Fock matrices will be returned.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate closed-shell fock matrix from FCIDump integrals and orbitals CMOl, CMOr. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, den::AbstractArray)\n\nCalculate closed-shell fock matrix from FCIDump integrals and density matrix den. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol, den::AbstractArray, denOS::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and density matrices den (for spincase)    and denOS (opposite spin to spincase). \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol, Vararg{AbstractArray, 4}}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β} and orbitals CMOl, CMOr and   orbitals for the opposite-spin CMOlOS and CMOrOS. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo, Symbol}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo, spincase::Symbol)\n\nCalculate UHF fock matrix from FCIDump integrals for spincase∈{:α,:β}. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_fock-Tuple{ElemCo.ECInfos.ECInfo}","page":"Fock builders","title":"ElemCo.FockFactory.gen_fock","text":"gen_fock(EC::ECInfo)\n\nCalculate closed-shell fock matrix from FCIDump integrals. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_frac_density_matrix-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_frac_density_matrix","text":"gen_frac_density_matrix(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray, occupation)\n\nGenerate D_μν=C^l_μi C^r_νi n_i with n_i provided in occupation.   Only real part of D_μν is kept.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_ufock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_ufock","text":"gen_ufock(EC::ECInfo, CMOl::AbstractArray, CMOr::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and orbitals cMOl, cMOr   with cMOl[1] and cMOr[1] - α-MO transformation coefficients and    cMOl[2] and cMOr[2] - β-MO transformation coefficients. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_ufock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_ufock","text":"gen_ufock(EC::ECInfo, den::AbstractArray)\n\nCalculate UHF fock matrix from FCIDump integrals and density matrix den. \n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#Internal-functions","page":"Fock builders","title":"Internal functions","text":"","category":"section"},{"location":"fockfactory/","page":"Fock builders","title":"Fock builders","text":"Modules = [ElemCo.FockFactory]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"fockfactory/#ElemCo.FockFactory.gen_closed_shell_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_closed_shell_dffock","text":"gen_closed_shell_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute closed-shell DF-HF Fock matrix (integral direct) in AO basis.\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_closed_shell_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_closed_shell_dffock","text":"gen_closed_shell_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute closed-shell DF-HF Fock matrix in AO basis   (using precalculated Cholesky-decomposed integrals).\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_unrestricted_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any, Any}","page":"Fock builders","title":"ElemCo.FockFactory.gen_unrestricted_dffock","text":"gen_unrestricted_dffock(EC::ECInfo, cMO::AbstractArray, bao, bfit)\n\nCompute unrestricted DF-HF Fock matrices [Fα, Fβ] in AO basis (integral direct).\n\n\n\n\n\n","category":"method"},{"location":"fockfactory/#ElemCo.FockFactory.gen_unrestricted_dffock-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Fock builders","title":"ElemCo.FockFactory.gen_unrestricted_dffock","text":"gen_unrestricted_dffock(EC::ECInfo, cMO::AbstractArray)\n\nCompute unrestricted DF-HF Fock matrices [Fα, Fβ] in AO basis   (using precalculated Cholesky-decomposed integrals).\n\n\n\n\n\n","category":"method"},{"location":"molpro/#Molpro-Interface","page":"Molpro Interface","title":"Molpro Interface","text":"","category":"section"},{"location":"molpro/","page":"Molpro Interface","title":"Molpro Interface","text":"ElemCo.MolproInterface","category":"page"},{"location":"molpro/#ElemCo.MolproInterface","page":"Molpro Interface","title":"ElemCo.MolproInterface","text":"MolproInterface\n\nThis module provides an interface to Molpro to read and write orbitals and other data.\n\n\n\n\n\n","category":"module"},{"location":"molpro/#Exported-functions-and-types","page":"Molpro Interface","title":"Exported functions and types","text":"","category":"section"},{"location":"molpro/","page":"Molpro Interface","title":"Molpro Interface","text":"Modules = [ElemCo.MolproInterface]\nPrivate = false\nOrder = [:function, :type, :macro, :constant]","category":"page"},{"location":"molpro/#ElemCo.MolproInterface.import_orbitals-Tuple{ElemCo.ECInfos.ECInfo, AbstractString}","page":"Molpro Interface","title":"ElemCo.MolproInterface.import_orbitals","text":"import_orbitals(EC::ECInfo, filename::AbstractString)\n\nImport an orbital coefficient matrix from a Molpro matrop file.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.import_overlap-Tuple{ElemCo.ECInfos.ECInfo, AbstractString}","page":"Molpro Interface","title":"ElemCo.MolproInterface.import_overlap","text":"import_overlap(EC::ECInfo, filename::AbstractString)\n\nImport the overlap matrix from a Molpro matrop file.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.is_matrop_file-Tuple{AbstractString}","page":"Molpro Interface","title":"ElemCo.MolproInterface.is_matrop_file","text":"is_matrop_file(filename::AbstractString)\n\nCheck if a file is a Molpro matrop file and return the type of the matrix.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.read_matrop_matrix-Tuple{AbstractString}","page":"Molpro Interface","title":"ElemCo.MolproInterface.read_matrop_matrix","text":"read_matrop_matrix(filename::AbstractString)\n\nRead a square matrix from a Molpro matrop file.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#Internal-functions-and-types","page":"Molpro Interface","title":"Internal functions and types","text":"","category":"section"},{"location":"molpro/","page":"Molpro Interface","title":"Molpro Interface","text":"Modules = [ElemCo.MolproInterface]\nPublic = false\nOrder = [:function, :type, :macro, :constant]","category":"page"},{"location":"molpro/#ElemCo.MolproInterface.ao_permutation-Tuple{ElemCo.ECInfos.ECInfo}","page":"Molpro Interface","title":"ElemCo.MolproInterface.ao_permutation","text":"ao_permutation(EC::ECInfo)\n\nReturn the permutation of the atomic orbitals from the Molpro to the libcint order    such that μ(molpro)[ao_permutation(EC)] = μ(libcint).\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.read_numbers_in_line-Tuple{IOStream}","page":"Molpro Interface","title":"ElemCo.MolproInterface.read_numbers_in_line","text":"read_numbers_in_line(f::IOStream)\n\nRead a line from a file and return the numbers in it.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.skip_comment_lines-Tuple{IOStream}","page":"Molpro Interface","title":"ElemCo.MolproInterface.skip_comment_lines","text":"skip_comment_lines(f::IOStream)\n\nSkip lines which do not start with a number or a minus.\n\n\n\n\n\n","category":"method"},{"location":"molpro/#ElemCo.MolproInterface.MOLPRO2LIBCINT_PERMUTATION","page":"Molpro Interface","title":"ElemCo.MolproInterface.MOLPRO2LIBCINT_PERMUTATION","text":"MOLPRO2LIBCINT_PERMUTATION\n\nPermutation of the atomic orbitals from the Molpro to the libcint order.\n\n\n\n\n\n","category":"constant"},{"location":"cctools/#Coupled-cluster-tools","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"ElemCo.CCTools","category":"page"},{"location":"cctools/#ElemCo.CCTools","page":"Coupled-cluster tools","title":"ElemCo.CCTools","text":"CCTools\n\nA collection of tools for working with coupled cluster theory.\n\n\n\n\n\n","category":"module"},{"location":"cctools/#Exported-functions","page":"Coupled-cluster tools","title":"Exported functions","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"Modules = [ElemCo.CCTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"cctools/#ElemCo.CCTools.calc_HF_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_HF_energy","text":"calc_HF_energy(EC::ECInfo, closed_shell)\n\nCalculate HF energy from FCIDump and EC info. \n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_doubles_norm-Tuple{Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_doubles_norm","text":"calc_contra_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes   (the same as calc_doubles_norm)\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_doubles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_doubles_norm","text":"calc_contra_doubles_norm(T2)\n\nCalculate squared norm of closed-shell contravariant doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_singles_norm-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_singles_norm","text":"calc_contra_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes    (same as calc_singles_norm(T1a, T1b)).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_contra_singles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_contra_singles_norm","text":"calc_contra_singles_norm(T1)\n\nCalculate squared norm of closed-shell contravariant singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_deco_doubles_norm","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_deco_doubles_norm","text":"calc_deco_doubles_norm(T2, tT2=Float64[])\n\nCalculate squared norm of doubles (for decomposed doubles: without contravariant!)   T2 are decomposed doubles amplitudes T2[X,Y]=T_XY or   full doubles amplitudes T2[a,b,i,j]=T^ij_ab. \n\nIf the contravariant amplitude tT2 is provided,    the norm will be calculated as T_XY T_XY.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.calc_deco_triples_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_deco_triples_norm","text":"calc_deco_triples_norm(T3)\n\nCalculate a simple norm of triples (without contravariant!)\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_doubles_norm-Tuple{Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_doubles_norm","text":"calc_doubles_norm(T2a, T2b, T2ab)\n\nCalculate squared norm of unrestricted doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_doubles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_doubles_norm","text":"calc_doubles_norm(T2)\n\nCalculate squared norm of closed-shell doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_fock_matrix-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_fock_matrix","text":"calc_fock_matrix(EC::ECInfo, closed_shell)\n\nCalculate fock matrix from FCIDump\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_energy_using_dfock-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_energy_using_dfock","text":"calc_singles_energy_using_dfock(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy    using dressed fock matrix.\n\nif fock_only is true, the energy will be calculated using only non-dressed fock matrix.   Returns total energy, SS, OS, and Openshell (0.0) contributions   as a NamedTuple (E, ESS, EOS, EO).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_norm-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_norm","text":"calc_singles_norm(T1a, T1b)\n\nCalculate squared norm of unrestricted singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_singles_norm-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_singles_norm","text":"calc_singles_norm(T1)\n\nCalculate squared norm of closed-shell singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.calc_triples_norm-NTuple{4, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.calc_triples_norm","text":"calc_triples_norm(T3aaa, T3bbb, T3abb, T3aab)\n\nCalculate squared norm of unrestricted triples amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.contra2covariant-Tuple{Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.contra2covariant","text":"contra2covariant(T2)\n\nTransform contravariant doubles amplitudes to covariant.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.read_starting_guess4amplitudes-Tuple{ElemCo.ECInfos.ECInfo, Int64, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.read_starting_guess4amplitudes","text":"read_starting_guess4amplitudes(EC::ECInfo, level::Int, spins...)\n\nRead starting guess for excitation level.\n\nThe guess will be read from T_vo, T_VO, T_vvoo etc files.   If the file does not exist, the guess will be a zeroed-vector.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_doubles","text":"save_current_doubles(EC::ECInfo, T2a, T2b, T2ab; prefix=\"T\")\n\nSave current doubles amplitudes T2a, T2b, and T2ab to files    prefix*\"_vvoo\", prefix*\"_VVOO\", and prefix*\"_vVoO\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_doubles","text":"save_current_doubles(EC::ECInfo, T2; prefix=\"T\")\n\nSave current doubles amplitudes T2 to file prefix*\"_vvoo\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_singles-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_singles","text":"save_current_singles(EC::ECInfo, T1a, T1b; prefix=\"T\")\n\nSave current singles amplitudes T1a and T1b to files prefix*\"_vo\" and prefix*\"_VO\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_current_singles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_current_singles","text":"save_current_singles(EC::ECInfo, T1; prefix=\"T\")\n\nSave current singles amplitudes T1 to file prefix*\"_vo\"\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.spin_project!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.spin_project!","text":"spin_project!(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab)\n\nSpin-project singles and doubles amplitudes/residuals.\n\nOnly possible for high-spin states.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.spin_project_amplitudes","page":"Coupled-cluster tools","title":"ElemCo.CCTools.spin_project_amplitudes","text":"spin_project_amplitudes(EC::ECInfo, with_singles=true)\n\nSpin-project singles (if withsingles) and doubles amplitudes    from files `\"Tvo\",\"TVO\",\"Tvvoo\",\"TVVOO\"and\"TvVoO\"`.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.starting_amplitudes-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.starting_amplitudes","text":"starting_amplitudes(EC::ECInfo, method::ECMethod)\n\nPrepare starting amplitudes for coupled cluster calculation.\n\nThe starting amplitudes are read from files T_vo, T_VO, T_vvoo, etc.   If the files do not exist, the amplitudes are initialized to zero.   The order of amplitudes is as follows:\n\nsingles: α, β\ndoubles: αα, ββ, αβ\ntriples: ααα, βββ, ααβ, αββ\n\nReturn a list of vectors of starting amplitudes    and a list of ranges for excitation levels.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.transform_amplitudes2lagrange_multipliers!-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.transform_amplitudes2lagrange_multipliers!","text":"transform_amplitudes2lagrange_multipliers!(Amps, exc_ranges)\n\nTransform amplitudes to first guess for Lagrange multipliers.\n\nThe amplitudes are transformed in-place. \n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_amps!-Tuple{ElemCo.ECInfos.ECInfo, Any, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_amps!","text":"try2save_amps!(EC::ECInfo, excitation_level, amps...; type=\"T\")\n\nSave amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_excitation_level\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_doubles!","text":"try2save_doubles!(EC::ECInfo, doubles...; type=\"T\")\n\nSave doubles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_2\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2save_singles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2save_singles!","text":"try2save_singles!(EC::ECInfo, singles...; type=\"T\")\n\nSave singles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    to file EC.options.cc.save[_lm]*\"_1\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_amps-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_amps","text":"try2start_amps(EC::ECInfo, excitation_level; type=\"T\")\n\nRead amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")    from file EC.options.cc.start[_lm]*\"_excitation_level\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_doubles","text":"try2start_doubles(EC::ECInfo; type=\"T\")\n\nRead doubles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")   from file EC.options.cc.start[_lm]*\"_2\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.try2start_singles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.try2start_singles","text":"try2start_singles(EC::ECInfo; type=\"T\")\n\nRead singles amplitudes (type=\"T\") or Lagrange multipliers (type=\"LM\")   from file EC.options.cc.start[_lm]*\"_1\".\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_deco_doubles-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_deco_doubles","text":"update_deco_doubles(EC, R2; use_shift=true)\n\nUpdate decomposed doubles amplitudes.\n\nIf R2 is R^ij_ab, the update is calculated using   update_doubles(EC, R2, use_shift=use_shift).\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_deco_triples","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_deco_triples","text":"update_deco_triples(EC, R3, use_shift=true)\n\nUpdate decomposed triples amplitudes.\n\nNote that the sign of the residual is opposite   to the usual definition of the triples residual   and therefore the update is calculated using    a positive denominator...\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.update_doubles","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles","text":"update_doubles(R2, ϵo1, ϵv1, ϵo2, ϵv2, shift)\n\nCalculate update for doubles amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.update_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles!","text":"update_doubles!(EC::ECInfo, T2, R2)\n\nUpdate doubles amplitudes in T2 with R2.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_doubles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 6}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles!","text":"update_doubles!(EC::ECInfo, T2a, T2b, T2ab, R2a, R2b, R2ab)\n\nUpdate doubles amplitudes in T2a, T2b, T2ab with R2a, R2b, R2ab.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_doubles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_doubles","text":"update_doubles(EC::ECInfo, R2; spincase::Symbol=:α, antisymmetrize=false, use_shift=true)\n\nCalculate update for doubles amplitudes for a given spincase∈{:α,:β,:αβ}.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles!-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles!","text":"update_singles!(EC::ECInfo, T1, R1)\n\nUpdate singles amplitudes in T1 with R1.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles!","text":"update_singles!(EC::ECInfo, T1a, T1b, R1a, R1b)\n\nUpdate singles amplitudes in T1a, T1b with R1a, R1b.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles-NTuple{4, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles","text":"update_singles(R1, ϵo, ϵv, shift)\n\nCalculate update for singles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_singles-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_singles","text":"update_singles(EC::ECInfo, R1; spincase::Symbol=:α, use_shift=true)\n\nCalculate update for singles amplitudes for a given spincase∈{:α,:β}.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_triples!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 8}}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_triples!","text":"update_triples!(EC::ECInfo, T3a, T3b, T3aab, T3abb, R3a, R3b, R3aab, R3abb)\n\nUpdate triples amplitudes in T3a, T3b, T3aab and T3abb with R3a, R3b, R3aab and R3abb.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#Internal-functions","page":"Coupled-cluster tools","title":"Internal functions","text":"","category":"section"},{"location":"cctools/","page":"Coupled-cluster tools","title":"Coupled-cluster tools","text":"Modules = [ElemCo.CCTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cctools/#ElemCo.CCTools.add_singles2doubles!-NTuple{5, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.add_singles2doubles!","text":"add_singles2doubles!(T2aa, T2bb, T2ab, T1a, T1b)\n\nAdd singles to doubles amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.add_singles2doubles!-Tuple{Any, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.add_singles2doubles!","text":"add_singles2doubles!(T2, T1; make_contravariant=true)\n\nAdd singles to doubles amplitudes.\n\nIf make_contravariant is true, the amplitudes will be made contravariant.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.save_or_start_file","page":"Coupled-cluster tools","title":"ElemCo.CCTools.save_or_start_file","text":"save_or_start_file(EC::ECInfo, type, excitation_level, save=true)\n\nReturn filename and description for saving or starting amplitudes/lagrange multipliers.\n\ntype is either \"T\" for amplitudes or \"LM\" for Lagrange multipliers.   excitation_level is the excitation level of the amplitudes (1, 2 etc.)   If save is true, the filename for saving is returned, otherwise the filename for starting.\n\n\n\n\n\n","category":"function"},{"location":"cctools/#ElemCo.CCTools.update_triples-NTuple{8, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_triples","text":"update_triples(R3, ϵo1, ϵv1, ϵo2, ϵv2, ϵo3, ϵv3, shift)\n\nCalculate update for triples amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"cctools/#ElemCo.CCTools.update_triples-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster tools","title":"ElemCo.CCTools.update_triples","text":"update_triples(EC::ECInfo, R3; spincase::Symbol=:α, antisymmetrize=false, use_shift=true)\n\nCalculate update for triples amplitudes for a given spincase∈{:α,:β,:ααβ,:αββ}.\n\n\n\n\n\n","category":"method"},{"location":"elemco/#Calculations","page":"Running calculations","title":"Calculations","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"CurrentModule = ElemCo","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"ElemCo","category":"page"},{"location":"elemco/#ElemCo.ElemCo","page":"Running calculations","title":"ElemCo.ElemCo","text":"       ╭─────────────╮\nElectron Correlation methods\n       ╰─────────────╯\n\n\n\n\n\n","category":"module"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"The ElemCo module contains the main macros and functions for running electronic structure calculations. The methods are contained in various submodules and are described in the following sections.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Various macros are defined and exported to simplify running calculations. The macros use several reserved variable names. The following table lists the reserved variable names and their meanings.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Variable Meaning\nEC::ECInfo A global information object containing options, molecular system description, integrals and orbital spaces information, see ElemCo.ECInfo.\ngeometry::String Molecular coordinates, either in the xyz format or the file containing the xyz coordinates, see ElemCo.MSystem.\nbasis::Dict Basis set information, see ElemCo.MSystem\nfcidump::String File containing the integrals in the FCIDUMP format, see ElemCo.FciDump.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"The driver routines and macros return energies as NamedTuple. The last energy is always the total energy (can be accessed using last(energies)). The following table lists the keys and their meanings.","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Key Meaning\n:HF Hartree-Fock energy\n:MP2 MP2 energy\n:CCSD CCSD energy\n:DCSD DCSD energy\n:SING2D_DCSD singlet 2D-DCSD energy\n:TRIP2D_DCSD triplet 2D-DCSD energy\netc. ","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"One can print the keys of the returned NamedTuple to see all the available keys:","category":"page"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"julia> println(keys(energies))","category":"page"},{"location":"elemco/#list_of_macros","page":"Running calculations","title":"Macros","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPrivate = false\nOrder = [:macro]","category":"page"},{"location":"elemco/#ElemCo.@ECinit-Tuple{}","page":"Running calculations","title":"ElemCo.@ECinit","text":"@ECinit()\n\nInitialize EC::ECInfo and add molecular system and/or fcidump    if variables geometry::String and basis::Dict{String,Any}   and/or fcidump::String are defined.\n\nIf EC is already initialized, it will be overwritten.\n\nExamples\n\ngeometry=\"He 0.0 0.0 0.0\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mpfit\"=>\"cc-pvdz-mpfit\")\n@ECinit\n# output\nOccupied orbitals:[1]\n\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@bohf-Tuple{}","page":"Running calculations","title":"ElemCo.@bohf","text":"@bohf()\n\nRun bi-orthogonal HF calculation using FCIDUMP integrals.\n\nThe orbitals are stored to WfOptions.orb.   For open-shell systems (or UHF FCIDUMPs), the BO-UHF energy is calculated.\n\nExamples\n\nfcidump = \"FCIDUMP\"\n@bohf\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@bouhf-Tuple{}","page":"Running calculations","title":"ElemCo.@bouhf","text":"@bouhf()\n\nRun bi-orthogonal UHF calculation using FCIDUMP integrals.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@cc-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@cc","text":"@cc(method, kwargs...)\n\nRun coupled cluster calculation.\n\nThe type of the method is determined by the first argument (ccsd/ccsd(t)/dcsd etc).   The method can be specified as a string or as a variable, e.g.,    @cc CCSD or @cc \"CCSD\" or ccmethod=\"CCSD\";  @cc ccmethod.\n\nKeyword arguments\n\nfcidump::String: fcidump file (default: \"\", i.e., use integrals from EC).\nocca::String: occupied α orbitals (default: \"-\").\noccb::String: occupied β orbitals (default: \"-\").\n\nThe occupation strings can be given as a + separated list, e.g. occa = 1+2+3 or equivalently 1-3.    Additionally, the spatial symmetry of the orbitals can be specified with the syntax orb.sym, e.g. occa = \"-5.1+-2.2+-4.3\".\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mpfit\"=>\"cc-pvdz-mpfit\")\n@dfhf\n@dfints\n@cc ccsd\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@copyfile-Tuple{Any, Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@copyfile","text":"@copyfile(from_file, to_file, kwargs...)\n\nCopy file from_file to to_file in EC.scr directory.\n\nKeyword arguments\n\noverwrite::Bool: overwrite existing file (default: false).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfcc","page":"Running calculations","title":"ElemCo.@dfcc","text":"@dfcc(method=\"svd-dcsd\")\n\nRun coupled cluster calculation using density fitted integrals.\n\nThe type of the method is determined by the first argument.   The method can be specified as a string or as a variable, e.g.,    @dfcc SVD-DCSD or @dfcc \"SVD-DCSD\" or ccmethod=\"SVD-DCSD\";  @dfcc ccmethod.\n\nExamples\n\ngeometry=\"bohr\nO      0.000000000    0.000000000   -0.130186067\nH1     0.000000000    1.489124508    1.033245507\nH2     0.000000000   -1.489124508    1.033245507\"\nbasis = Dict(\"ao\"=>\"cc-pVDZ\", \"jkfit\"=>\"cc-pvtz-jkfit\", \"mpfit\"=>\"cc-pvdz-mpfit\")\n@dfhf\n@dfcc svd-dcsd\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfhf-Tuple{}","page":"Running calculations","title":"ElemCo.@dfhf","text":"@dfhf()\n\nRun DF-HF calculation. The orbitals are stored to WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfints-Tuple{}","page":"Running calculations","title":"ElemCo.@dfints","text":"@dfints()\n\nGenerate 2 and 4-idx MO integrals using density fitting.   The MO coefficients are read from WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@dfuhf-Tuple{}","page":"Running calculations","title":"ElemCo.@dfuhf","text":"@dfuhf()\n\nRun DF-UHF calculation. The orbitals are stored to WfOptions.orb.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@freeze_orbs-Tuple{Any}","page":"Running calculations","title":"ElemCo.@freeze_orbs","text":"@freeze_orbs(freeze_orbs)\n\nFreeze orbitals in the integrals according to an array or range    freeze_orbs.\n\nExamples\n\nfcidump = \"FCIDUMP\"\n@freeze_orbs 1:5\n...\n@ECinit\n@freeze_orbs [1,2,20,21]\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@import_matrix-Tuple{Any}","page":"Running calculations","title":"ElemCo.@import_matrix","text":"@import_matrix(file)\n\nImport matrix from file file.\n\nThe type of the matrix is determined automatically.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@loadfile-Tuple{Any}","page":"Running calculations","title":"ElemCo.@loadfile","text":"@loadfile(filename)\n\nRead file filename from EC.scr directory.\n\nExample\n\nfock = @loadfile(\"f_mm\")\norbs = @loadfile(\"C_Am\")\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@mainname-Tuple{Any}","page":"Running calculations","title":"ElemCo.@mainname","text":"@mainname(file)\n\nReturn the main name of a file, i.e. the part before the last dot   and the extension.\n\nExamples\n\njulia> @mainname(\"~/test.xyz\")\n(\"test\", \"xyz\")\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@method2string","page":"Running calculations","title":"ElemCo.@method2string","text":"@method2string(method, strmethod=\"\")\n\nReturn string representation of method.\n\nIf method is a String variable, return the value of the variable.   Otherwise, return the string representation of method (or strmethod if provided).\n\nExamples\n\njulia> @method2string(CCSD)\n\"CCSD\"\njulia> CCSD = \"UCCSD\";\njulia> @method2string(CCSD)\n\"UCCSD\"\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@opt","page":"Running calculations","title":"ElemCo.@opt","text":"@opt(opt, kwargs...)\n\nAlias for @set.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@print_input","page":"Running calculations","title":"ElemCo.@print_input","text":"@print_input(print_init=false)\n\nPrint the input file content. \n\nCan be used to print the input file content to the output.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@reset-Tuple{Any}","page":"Running calculations","title":"ElemCo.@reset","text":"@reset(opt)\n\nReset options for opt to default values.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@rotate_orbs-Tuple{Any, Any, Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@rotate_orbs","text":"@rotate_orbs(orb1, orb2, angle, kwargs...)\n\nRotate orbitals orb1 and orb2 from WfOptions.orb    by angle (in degrees). For UHF, spin can be :α or :β (keyword argument).\n\nThe orbitals are stored to WfOptions.orb.\n\nKeyword arguments\n\nspin::Symbol: spin of the orbitals (default: :α).\n\nExamples\n\n@dfhf\n# swap orbitals 1 and 2\n@rotate_orbs 1, 2, 90\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@run-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@run","text":"general runner \n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@savefile-Tuple{Any, Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@savefile","text":"@savefile(filename, arr, kwargs...)\n\nSave array or tuple of arrays arr to file filename in EC.scr directory.\n\nKeyword arguments\n\ndescription::String: description of the file (default: \"tmp\").\noverwrite::Bool: overwrite existing file (default: false).\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@set-Tuple{Any, Vararg{Any}}","page":"Running calculations","title":"ElemCo.@set","text":"@set(opt, kwargs...)\n\nSet options for EC::ECInfo. \n\nThe first argument opt is the name of the option (e.g., scf, cc, cholesky), see ECInfos.Options.   The keyword arguments are the options to be set (e.g., thr=1.e-14, maxit=10).   The current state of the options can be stored in a variable, e.g., opt_cc = @set cc.   The state can then be restored by @set cc opt_cc.   If EC is not already initialized, it will be done. \n\nExamples\n\noptscf = @set scf thr=1.e-14 maxit=10\n@set cc maxit=100\n...\n@set scf optscf\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@show_orbs","page":"Running calculations","title":"ElemCo.@show_orbs","text":"@show_orbs(range=nothing)\n\nShow orbitals in the integrals according to an array or range    range.\n\nExamples\n\n@dfhf\n@show_orbs 1:5\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@transform_ints","page":"Running calculations","title":"ElemCo.@transform_ints","text":"@transform_ints(type=\"\")\n\nRotate FCIDump integrals using WfOptions.orb as transformation    matrices.\n\nThe orbitals are read from WfOptions.orb.   If type is one of [bo, BO, bi-orthogonal, Bi-orthogonal, biorth, biorthogonal, Biorthogonal],    the bi-orthogonal orbitals are used and the left transformation matrix is   read from WfOptions.orb*WfOptions.left.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@tryECinit-Tuple{}","page":"Running calculations","title":"ElemCo.@tryECinit","text":"@tryECinit()\n\nIf EC::ECInfo is not yet initialized, run @ECinit macro.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#ElemCo.@write_ints","page":"Running calculations","title":"ElemCo.@write_ints","text":"@write_ints(file=\"FCIDUMP\", tol=-1.0)\n\nWrite FCIDump integrals to file file.\n\nIf tol is negative, all integrals are written, otherwise only integrals with absolute value larger than tol are written.\n\n\n\n\n\n","category":"macro"},{"location":"elemco/#Exported-functions","page":"Running calculations","title":"Exported functions","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"elemco/#Internal-functions","page":"Running calculations","title":"Internal functions","text":"","category":"section"},{"location":"elemco/","page":"Running calculations","title":"Running calculations","text":"Modules = [ElemCo]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"elemco/#ElemCo.__init__-Tuple{}","page":"Running calculations","title":"ElemCo.__init__","text":"__init__()\n\nPrint the header with the version and the git hash of the current commit.\n\n\n\n\n\n","category":"method"},{"location":"dfhf/#Density-fitted-Hartree-Fock","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"CurrentModule = ElemCo.DFHF","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"The density-fitted Hartree-Fock (DF-HF) method is a method for computing the Hartree-Fock energy using density fitting. The DF-HF method is implemented in ElemCo.jl using the @dfhf macro. Here's an example of how you can use this macro:","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"using ElemCo\n\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mpfit\"=>\"cc-pvdz-mpfit\")\n\n# Compute DF-HF\n@dfhf","category":"page"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, and calculates the DF-HF energy.","category":"page"},{"location":"dfhf/#Exported-functions-and-types","page":"Density-fitted Hartree-Fock","title":"Exported functions and types","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"Modules = [DFHF]\nPrivate = false","category":"page"},{"location":"dfhf/#ElemCo.DFHF.dfhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfhf","text":"dfhf(EC::ECInfo)\n\nPerform closed-shell DF-HF calculation.   Returns the energy as the :HF field in a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"dfhf/#ElemCo.DFHF.dfuhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Hartree-Fock","title":"ElemCo.DFHF.dfuhf","text":"dfuhf(EC::ECInfo)\n\nPerform DF-UHF calculation.   Returns the energy as the :UHF and :HF field in a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"dfhf/#Internal-functions","page":"Density-fitted Hartree-Fock","title":"Internal functions","text":"","category":"section"},{"location":"dfhf/","page":"Density-fitted Hartree-Fock","title":"Density-fitted Hartree-Fock","text":"Modules = [DFHF]\nPublic = false","category":"page"},{"location":"dumptools/#Dump-tools","page":"Dump tools","title":"Dump tools","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"CurrentModule = ElemCo.DumpTools","category":"page"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"DumpTools","category":"page"},{"location":"dumptools/#ElemCo.DumpTools","page":"Dump tools","title":"ElemCo.DumpTools","text":"DumpTools module\n\nTools for manipulating FCIDump files.\n\n\n\n\n\n","category":"module"},{"location":"dumptools/#Exported-functions","page":"Dump tools","title":"Exported functions","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"Modules = [DumpTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dumptools/#ElemCo.DumpTools.freeze_orbs_in_dump-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Dump tools","title":"ElemCo.DumpTools.freeze_orbs_in_dump","text":"freeze_orbs_in_dump(EC::ECInfo, freeze_orbs)\n\nFreeze orbitals in FCIDump file EC.fd according to an array or range freeze_orbs.\n\n\n\n\n\n","category":"method"},{"location":"dumptools/#Internal-functions","page":"Dump tools","title":"Internal functions","text":"","category":"section"},{"location":"dumptools/","page":"Dump tools","title":"Dump tools","text":"Modules = [DumpTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#Orbital-tools","page":"Orbital tools","title":"Orbital tools","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"ElemCo.OrbTools","category":"page"},{"location":"orbtools/#ElemCo.OrbTools","page":"Orbital tools","title":"ElemCo.OrbTools","text":"OrbTools\n\nA collection of tools for working with orbitals\n\n\n\n\n\n","category":"module"},{"location":"orbtools/#Exported-functions","page":"Orbital tools","title":"Exported functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"Modules = [ElemCo.OrbTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_orb-Tuple{ElemCo.ECInfos.ECInfo, Symbol}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_orb","text":"guess_orb(EC::ECInfo, guess::Symbol)\n\nCalculate starting guess for MO coefficients.   Type of initial guess for MO coefficients is given by guess.\n\nSee ScfOptions.guess for possible values.\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.is_unrestricted_MO-Tuple{Any}","page":"Orbital tools","title":"ElemCo.OrbTools.is_unrestricted_MO","text":"is_unrestricted_MO(cMO)\n\nReturn true if cMO is unrestricted MO coefficients of the form    [CMOα, CMOβ].\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.load_orbitals","page":"Orbital tools","title":"ElemCo.OrbTools.load_orbitals","text":"load_orbitals(EC::ECInfo, orbsfile::String=\"\")\n\nLoad (last) orbitals.\n\nfrom file orbsfile if not empty\nfrom file WfOptions.orb if not empty\nerror if all files are empty\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.normalize_phase!-Tuple{Any}","page":"Orbital tools","title":"ElemCo.OrbTools.normalize_phase!","text":"normalize_phase!(cMO)\n\nNormalize the phase of the MO coefficients in cMO.\n\nThe phase is chosen such that the first largest coefficient is positive.\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.orbital_energies","page":"Orbital tools","title":"ElemCo.OrbTools.orbital_energies","text":"orbital_energies(EC::ECInfo, spincase::Symbol=:α)\n\nReturn orbital energies for a given spincase∈{:α,:β}.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.rotate_orbs","page":"Orbital tools","title":"ElemCo.OrbTools.rotate_orbs","text":"rotate_orbs(EC::ECInfo, orb1, orb2, angle=90; spin::Symbol=:α)\n\nRotate orbitals orb1 and orb2 from WfOptions.orb    by angle degrees. For unrestricted orbitals, spin can be :α or :β.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.rotate_orbs!","page":"Orbital tools","title":"ElemCo.OrbTools.rotate_orbs!","text":"rotate_orbs!(cMO::AbstractArray, orb1, orb2, angle=90)\n\nRotate orbitals orb1 and orb2 from cMO by angle degrees.\n\ncMO is a matrix of MO coefficients.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.show_orbitals","page":"Orbital tools","title":"ElemCo.OrbTools.show_orbitals","text":"show_orbitals(EC::ECInfo, cMO::AbstractArray, basis::BasisSet, range=1:size(cMO,2)\n\nPrint the MO coefficients in cMO with respect to the atomic orbitals in basis.\n\nrange is a range of molecular orbitals to be printed.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#ElemCo.OrbTools.show_orbitals-2","page":"Orbital tools","title":"ElemCo.OrbTools.show_orbitals","text":"show_orbitals(EC::ECInfo, range=nothing)\n\nPrint the MO coefficients in WfOptions.orb    with respect to the atomic orbitals.\n\nrange is a range of molecular orbitals to be printed.\n\n\n\n\n\n","category":"function"},{"location":"orbtools/#Internal-functions","page":"Orbital tools","title":"Internal functions","text":"","category":"section"},{"location":"orbtools/","page":"Orbital tools","title":"Orbital tools","text":"Modules = [ElemCo.OrbTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"orbtools/#ElemCo.OrbTools.guess_hcore-Tuple{ElemCo.ECInfos.ECInfo}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_hcore","text":"guess_hcore(EC::ECInfo)\n\nGuess MO coefficients from core Hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"orbtools/#ElemCo.OrbTools.guess_sad-Tuple{ElemCo.ECInfos.ECInfo}","page":"Orbital tools","title":"ElemCo.OrbTools.guess_sad","text":"guess_sad(EC::ECInfo)\n\nGuess MO coefficients from atomic densities.\n\n\n\n\n\n","category":"method"},{"location":"diis/#DIIS-solver","page":"DIIS solver","title":"DIIS solver","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"CurrentModule = ElemCo.DIIS","category":"page"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"DIIS","category":"page"},{"location":"diis/#ElemCo.DIIS","page":"DIIS solver","title":"ElemCo.DIIS","text":"DIIS module for iterative solvers\n\n\n\n\n\n","category":"module"},{"location":"diis/#Main-structure","page":"DIIS solver","title":"Main structure","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Diis","category":"page"},{"location":"diis/#ElemCo.DIIS.Diis","page":"DIIS solver","title":"ElemCo.DIIS.Diis","text":"DIIS object\n\n\n\n\n\n","category":"type"},{"location":"diis/#Exported-functions","page":"DIIS solver","title":"Exported functions","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Modules = [DIIS]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"diis/#ElemCo.DIIS.perform-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.perform","text":"perform(diis::Diis, Amps, Res)\n\nPerform DIIS.\n\n\n\n\n\n","category":"method"},{"location":"diis/#Internal-functions","page":"DIIS solver","title":"Internal functions","text":"","category":"section"},{"location":"diis/","page":"DIIS solver","title":"DIIS solver","text":"Modules = [DIIS]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"diis/#ElemCo.DIIS.combine-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.combine","text":"combine(diis::Diis, vecfiles, coeffs)\n\nCombine vectors from files with coefficients.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadamps-Tuple{ElemCo.DIIS.Diis, Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadamps","text":"loadamps(diis::Diis, ipos)\n\nLoad vectors from file at position ipos.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadres-Tuple{ElemCo.DIIS.Diis, Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadres","text":"loadres(diis::Diis, ipos)\n\nLoad residuals from file at position ipos.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.loadvecs-Tuple{Any}","page":"DIIS solver","title":"ElemCo.DIIS.loadvecs","text":"loadvecs(file)\n\nLoad vectors from file.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.saveamps-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.saveamps","text":"saveamps(diis::Diis, vecs, ipos)\n\nSave vectors to file (replacing previous vectors at position ipos).\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.saveres-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.saveres","text":"saveres(diis::Diis, vecs, ipos)\n\nSave residuals to file (replacing previous residuals at position ipos).\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.update_Bmat-Tuple{ElemCo.DIIS.Diis, Any, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.update_Bmat","text":"update_Bmat(diis::Diis, nDim, Res, ithis)\n\nUpdate B matrix with new residual (at the position ithis).\n\nB matrix is defined as:\n\nbf B = beginpmatrix\nlangle bf R_1 bf R_1 rangle  langle bf R_1 bf R_2 rangle  cdots  langle bf R_1 bf R_rm nDim rangle  -1 \nlangle bf R_2 bf R_1 rangle  langle bf R_2 bf R_2 rangle  cdots  langle bf R_2 bf R_rm nDim rangle  -1 \nvdots  vdots  ddots  vdots  vdots \nlangle bf R_rm nDim bf R_1 rangle  langle bf R_rm nDim bf R_2 rangle  cdots  langle bf R_rm nDim bf R_rm nDim rangle  -1 \n-1  -1  cdots  -1  0\nendpmatrix\n\nReturns the dot product of the new residual with itself, langle bf R_rm ithis bf R_rm ithis rangle.\n\n\n\n\n\n","category":"method"},{"location":"diis/#ElemCo.DIIS.weighted_dot-Tuple{ElemCo.DIIS.Diis, Any, Any}","page":"DIIS solver","title":"ElemCo.DIIS.weighted_dot","text":"weighted_dot(diis::Diis, vecs1, vecs2)\n\nCompute weighted (with diis.weights) dot product of vectors.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#Integrals","page":"Integrals","title":"Integrals","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"ElemCo.Integrals","category":"page"},{"location":"integrals/#ElemCo.Integrals","page":"Integrals","title":"ElemCo.Integrals","text":"Electron-repulsion (and other) integrals \n\n\n\n\n\n","category":"module"},{"location":"integrals/#Exported-functions","page":"Integrals","title":"Exported functions","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"Modules = [ElemCo.Integrals]\nPrivate = false\nPages = [\"integrals.jl\"]\nOrder = [:constant, :type, :function]","category":"page"},{"location":"integrals/#ElemCo.Integrals.n_ao4cartshell-Tuple{Integer, ElemCo.BasisSets.ILibcint5}","page":"Integrals","title":"ElemCo.Integrals.n_ao4cartshell","text":"n_ao4cartshell(id::Integer, info::ILibcint5)\n\nReturn the number of AOs for a given cartesian shell id.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.n_ao4sphshell-Tuple{Integer, ElemCo.BasisSets.ILibcint5}","page":"Integrals","title":"ElemCo.Integrals.n_ao4sphshell","text":"n_ao4sphshell(id::Integer, info::ILibcint5)\n\nReturn the number of AOs for a given spherical shell id.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#Two-index-integrals","page":"Integrals","title":"Two-index integrals","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"Modules = [ElemCo.Integrals]\nPrivate = false\nPages = [\"integrals_2idx.jl\"]\nOrder = [:constant, :type, :function]","category":"page"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx!-Tuple{Any, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx!","text":"eri_2e2idx!(out, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral matrix.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx!-Tuple{Any, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx!","text":"eri_2e2idx!(out, ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx!-Tuple{Any, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx!","text":"eri_2e2idx!(out, ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx-Tuple{ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx","text":"eri_2e2idx(basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral matrix.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx-Tuple{ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx","text":"eri_2e2idx(ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx-Tuple{ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx","text":"eri_2e2idx(ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic!-Tuple{Any, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic!","text":"kinetic!(out, basis::BasisSet)\n\nCompute the kinetic integral matrix.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic!-Tuple{Any, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic!","text":"kinetic!(out, ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic!-Tuple{Any, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic!","text":"kinetic!(out, ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic-Tuple{ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic","text":"kinetic(basis::BasisSet)\n\nCompute the kinetic integral matrix.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic-Tuple{ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic","text":"kinetic(ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic-Tuple{ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic","text":"kinetic(ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear!-Tuple{Any, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear!","text":"nuclear!(out, basis::BasisSet)\n\nCompute the nuclear integral matrix.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear!-Tuple{Any, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear!","text":"nuclear!(out, ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear!-Tuple{Any, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear!","text":"nuclear!(out, ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear-Tuple{ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear","text":"nuclear(basis::BasisSet)\n\nCompute the nuclear integral matrix.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear-Tuple{ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear","text":"nuclear(ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear-Tuple{ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear","text":"nuclear(ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap!-Tuple{Any, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap!","text":"overlap!(out, basis::BasisSet)\n\nCompute the overlap integral matrix.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap!-Tuple{Any, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap!","text":"overlap!(out, ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap!-Tuple{Any, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap!","text":"overlap!(out, ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap-Tuple{ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap","text":"overlap(basis::BasisSet)\n\nCompute the overlap integral matrix.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap-Tuple{ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap","text":"overlap(ash1::ElemCo.BasisSets.CartesianAngularShell, ash2::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap-Tuple{ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap","text":"overlap(ash1::ElemCo.BasisSets.SphericalAngularShell, ash2::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#Three-index-integrals","page":"Integrals","title":"Three-index integrals","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"Modules = [ElemCo.Integrals]\nPrivate = false\nPages = [\"integrals_2e3idx.jl\"]\nOrder = [:constant, :type, :function]","category":"page"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx!-Tuple{Any, ElemCo.BasisSets.BasisSet, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx!","text":"eri_2e3idx!(out, ao_basis::BasisSet, fit_basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx!-Tuple{Any, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx!","text":"eri_2e3idx!(out, ash1ao::ElemCo.BasisSets.CartesianAngularShell, ash2ao::ElemCo.BasisSets.CartesianAngularShell, ashfit::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_a_1^a_2 P for given angular shells.   basis has to contain ao and fit bases.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx!-Tuple{Any, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx!","text":"eri_2e3idx!(out, ash1ao::ElemCo.BasisSets.SphericalAngularShell, ash2ao::ElemCo.BasisSets.SphericalAngularShell, ashfit::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_a_1^a_2 P for given angular shells.   basis has to contain ao and fit bases.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx-Tuple{ElemCo.BasisSets.BasisSet, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx","text":"eri_2e3idx(ao_basis::BasisSet, fit_basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx-Tuple{ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.CartesianAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx","text":"eri_2e3idx(ash1ao::ElemCo.BasisSets.CartesianAngularShell, ash2ao::ElemCo.BasisSets.CartesianAngularShell, ashfit::ElemCo.BasisSets.CartesianAngularShell, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_a_1^a_2 P for given angular shells.   basis has to contain ao and fit bases.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx-Tuple{ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.SphericalAngularShell, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx","text":"eri_2e3idx(ash1ao::ElemCo.BasisSets.SphericalAngularShell, ash2ao::ElemCo.BasisSets.SphericalAngularShell, ashfit::ElemCo.BasisSets.SphericalAngularShell, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_a_1^a_2 P for given angular shells.   basis has to contain ao and fit bases.\n\n\n\n\n\n","category":"method"},{"location":"integrals/#Internal-functions","page":"Integrals","title":"Internal functions","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"Modules = [ElemCo.Integrals]\nPublic = false\nOrder = [:type, :function]","category":"page"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx_cart!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx_cart!","text":"eri_2e2idx_cart!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e2idx_sph!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e2idx_sph!","text":"eri_2e2idx_sph!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the two-electron 2-index electron-repulsion integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx_cart!-Tuple{Any, Int64, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx_cart!","text":"eri_2e3idx_cart!(out, i::Int, j::Int, P::Int, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_i^j P for given angular shells.   basis has to contain ao and fit bases.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.eri_2e3idx_sph!-Tuple{Any, Int64, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.eri_2e3idx_sph!","text":"eri_2e3idx_sph!(out, i::Int, j::Int, P::Int, basis::BasisSet)\n\nCompute the two-electron three-index electron-repulsion integral v_i^j P for given angular shells.   basis has to contain ao and fit bases.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic_cart!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic_cart!","text":"kinetic_cart!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.kinetic_sph!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.kinetic_sph!","text":"kinetic_sph!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the kinetic integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear_cart!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear_cart!","text":"nuclear_cart!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.nuclear_sph!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.nuclear_sph!","text":"nuclear_sph!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the nuclear integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap_cart!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap_cart!","text":"overlap_cart!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#ElemCo.Integrals.overlap_sph!-Tuple{Any, Int64, Int64, ElemCo.BasisSets.BasisSet}","page":"Integrals","title":"ElemCo.Integrals.overlap_sph!","text":"overlap_sph!(out, i::Int, j::Int, basis::BasisSet)\n\nCompute the overlap integral between two angular shells.   The result is stored in out. \n\n\n\n\n\n","category":"method"},{"location":"integrals/#Integral-libraries","page":"Integrals","title":"Integral libraries","text":"","category":"section"},{"location":"integrals/","page":"Integrals","title":"Integrals","text":"ElemCo.Libcint5","category":"page"},{"location":"integrals/#ElemCo.Libcint5","page":"Integrals","title":"ElemCo.Libcint5","text":"Libcint 5\n\nMinimal wrap around the integral library libcint. This module exposes libcint functions to the Julia interface. \n\n(adapted from GaussianBasis.jl) \n\n\n\n\n\n","category":"module"},{"location":"interfaces/#Interfaces","page":"Interfaces","title":"Interfaces","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"ElemCo.Interfaces","category":"page"},{"location":"interfaces/#ElemCo.Interfaces","page":"Interfaces","title":"ElemCo.Interfaces","text":"Interfaces module\n\nThis module provides functions to import (export) matrices from (to) external programs.\n\nSee also: MolproInterface\n\n\n\n\n\n","category":"module"},{"location":"interfaces/#Exported-functions-and-types","page":"Interfaces","title":"Exported functions and types","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"Modules = [ElemCo.Interfaces]\nPrivate = false\nOrder = [:function, :type, :macro, :constant]","category":"page"},{"location":"interfaces/#ElemCo.Interfaces.import_matrix-Tuple{ElemCo.ECInfos.ECInfo, String}","page":"Interfaces","title":"ElemCo.Interfaces.import_matrix","text":"import_matrix(EC::ECInfo, filename::String)\n\nImport a matrix from an external program.\n\nThe type of the matrix is determined automatically.\n\n\n\n\n\n","category":"method"},{"location":"interfaces/#Internal-functions-and-types","page":"Interfaces","title":"Internal functions and types","text":"","category":"section"},{"location":"interfaces/","page":"Interfaces","title":"Interfaces","text":"Modules = [ElemCo.Interfaces]\nPublic = false\nOrder = [:function, :type, :macro, :constant]","category":"page"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"EditURL = \"https://github.com/fkfest/ElemCo.jl/blob/master/CHANGELOG.md\"","category":"page"},{"location":"release-notes/#Release-notes","page":"Release notes","title":"Release notes","text":"","category":"section"},{"location":"release-notes/#Version-[v0.12.0](https://github.com/fkfest/ElemCo.jl/releases/tag/v0.12.0)-2024.05.28","page":"Release notes","title":"Version v0.12.0 - 2024.05.28","text":"","category":"section"},{"location":"release-notes/#Breaking","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"the mp2fit (rifit) basis sets have been renamed to mpfit. \nERI_?e?c routines have been renamed to eri_?e?idx.","category":"page"},{"location":"release-notes/#Changed","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"use SVD in DIIS.\nincrease number of iterations in 2D-CCSD IAS test.\ninterface to libcint_jll has been implemented. The basis set library is added (in Molpro format), and basis sets are parsed to a BasisSet object. GaussianBasis.jl dependency is removed.","category":"page"},{"location":"release-notes/#Added","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Expand README\namdmkl() function to speed up MKL on AMD machines.\nCROP-DIIS option (JCTC 11, 1518 (2015)) which is less sensitive to the DIIS dimension. To activate, set diis option crop=true, the DIIS dimension can be changed using maxcrop (default is 3).\nAn option print_init is added to the @print_input macro (default is false). If set to true, the ElemCo.jl info is printed again (useful if the output is redirected in julia to a file).\nA simple DMRG routine is added based on ITensors (adapted from ITensorChemistry.jl).\nA Molpro interface to import matrop matrices (orbitals or overlap).","category":"page"},{"location":"release-notes/#Fixed","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Get rid of error message from git if .git is not available (e.g., in the case of the released version).\nSort orblist, which fixes issues if user occupations are not provided in a sorted list.\nFix amplitudes before Hylleraas energy calculation for FR-CC, which will properly report the energy in a (2,2) (single iteration) calculation.","category":"page"},{"location":"release-notes/#Version-[v0.11.1](https://github.com/fkfest/ElemCo.jl/releases/tag/v0.11.1)-2024.04.12","page":"Release notes","title":"Version v0.11.1 - 2024.04.12","text":"","category":"section"},{"location":"release-notes/#Changed-2","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Remove ArgParse dependency and set [compat] section in Project.toml.","category":"page"},{"location":"release-notes/#Version-[v0.11.0](https://github.com/fkfest/ElemCo.jl/releases/tag/v0.11.0)-2024.04.12","page":"Release notes","title":"Version v0.11.0 - 2024.04.12","text":"","category":"section"},{"location":"release-notes/#Breaking-2","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"EC.ms (previously of type MSys) in ECInfo is renamed to EC.system (of type AbstractSystem).\nECdriver routine is moved to CCDriver module and renamed to ccdriver. The fcidump keyword-argument is now empty by default. It doesn't accept list of methods anymore, only one method at a time. \nThe driver routines and macros return energies as NamedTuple.\nThe SVD methods have to be called now as SVD-<methodname>, e.g., svd-dcsd.\nThe @svdcc macro is renamed to @dfcc macro and calls the dfccdriver routine, which is intended as a driver routine for all DF-based correlation methods (i.e., methods which don't use the EC.fd integrals).","category":"page"},{"location":"release-notes/#Changed-3","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Renamed function active_orbitals to oss_active_orbitals.\nRenamed function calc_ccsd_resid to calc_cc_resid.\nECdriver and oss_active_orbitals now return named tuples.\nImproved documentation of occupation strings syntax.\nSwitched to Atom and FlexibleSystem from AtomsBase as the internal representation of the molecular system. The basis set is stored for each atom as :basis property (as Dict{String,String}, e.g., system[1][:basis][\"ao\"]). One can also set :basis property for the whole system. \nRenamed macro @opt to @set. @opt is now an alias of @set.","category":"page"},{"location":"release-notes/#Added-2","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"The automatically generated UCCSDT and UDC-CCSDT methods have been added to the docs.\nSCS-MP2, SCS-CCSD and SCS-DCSD","category":"page"},{"location":"release-notes/#Version-[v0.10.0](https://github.com/fkfest/ElemCo.jl/releases/tag/v0.10.0)-2024.02.21","page":"Release notes","title":"Version v0.10.0 - 2024.02.21","text":"","category":"section"},{"location":"release-notes/#Breaking-3","page":"Release notes","title":"Breaking","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Cholesky threshold thr is used for integral decomposition only. Threshold for elimination of redundancies is now called thred.\nFiles for amplitudes and multipliers are now called ..._1, ..._2,... for singles, doubles, etc.","category":"page"},{"location":"release-notes/#Changed-4","page":"Release notes","title":"Changed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Option ignore_error is moved from ECInfo structure to wf options.","category":"page"},{"location":"release-notes/#Added-3","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"UCCSD(T), ΛUCCSD(T), ΛUDCSD have been implemented.\nPseudo-canonicalization of the FCIDUMP file (instead of full SCF calculation).\nGenerated UCCSDT and UDC-CCSDT methods.\nMacro @print_input to print the source of the input file to the output.","category":"page"},{"location":"release-notes/#Fixed-2","page":"Release notes","title":"Fixed","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Fix dressing of a three-internal integral (which slightly affected the energy of CCSD/DCSD with use_kext=false).","category":"page"},{"location":"release-notes/#Version-[v0.9.0](https://github.com/fkfest/ElemCo.jl/releases/tag/v0.9.0)-2024.01.20","page":"Release notes","title":"Version v0.9.0 - 2024.01.20","text":"","category":"section"},{"location":"release-notes/#Added-4","page":"Release notes","title":"Added","text":"","category":"section"},{"location":"release-notes/","page":"Release notes","title":"Release notes","text":"Add various methods (DF-[U]HF, BO-[U]HF, [U/R]CCSD, [U/R]DCSD, SVD-DCSD, SVD-DC-CCSDT, CCSD(T), ΛCCSD(T), ΛDCSD...).\nSetup macros, options etc.\n...","category":"page"},{"location":"dump/#FCIDump-files","page":"FCIDump files","title":"FCIDump files","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"CurrentModule = ElemCo.FciDump","category":"page"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"FciDump","category":"page"},{"location":"dump/#ElemCo.FciDump","page":"FCIDump files","title":"ElemCo.FciDump","text":"Read and write fcidump format integrals. Individual arrays of integrals can also be in *.npy format\n\n\n\n\n\n","category":"module"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"The FCIDump file format is a simple text file format for storing molecular integrals. It is used by many quantum chemistry programs. ","category":"page"},{"location":"dump/#Storage-of-molecular-integrals","page":"FCIDump files","title":"Storage of molecular integrals","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"FDump","category":"page"},{"location":"dump/#ElemCo.FciDump.FDump","page":"FCIDump files","title":"ElemCo.FciDump.FDump","text":"FDump\n\nMolecular integrals \n\nThe 2-e integrals are stored in the physicists' notation: int2[pqrs] = pqrs=v_pq^rs   and for triang the last two indices are stored as a single upper triangular index (r <= s)\n\nint2::Array{Float64}:  2-e⁻ integrals for restricted orbitals fcidump.\nint2aa::Array{Float64}:  αα 2-e⁻ integrals for unrestricted orbitals fcidump.\nint2bb::Array{Float64}:  ββ 2-e⁻ integrals for unrestricted orbitals fcidump.\nint2ab::Array{Float64}:  αβ 2-e⁻ integrals for unrestricted orbitals fcidump.\nint1::Array{Float64}:  1-e⁻ integrals for restricted orbitals fcidump.\nint1a::Array{Float64}:  α 1-e⁻ integrals for unrestricted orbitals fcidump.\nint1b::Array{Float64}:  β 1-e⁻ integrals for unrestricted orbitals fcidump.\nint0::Float64:  core energy\nhead::Dict:  header of fcidump file, a dictionary of arrays.\ntriang::Bool: ⟨true⟩ use an upper triangular index for last two indices of 2e⁻ integrals.\nuhf::Bool: ⟨false⟩ a convinience variable, has to coincide with head[\"IUHF\"][1] > 0.\n\n\n\n\n\n","category":"type"},{"location":"dump/#Exported-functions","page":"FCIDump files","title":"Exported functions","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"Modules = [FciDump]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dump/#ElemCo.FciDump.fd_exists-Tuple{ElemCo.FciDump.FDump}","page":"FCIDump files","title":"ElemCo.FciDump.fd_exists","text":"fd_exists(fd::FDump)\n\nReturn true if the object is a non-empty FDump\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.headvar-Tuple{Dict, String}","page":"FCIDump files","title":"ElemCo.FciDump.headvar","text":"headvar(head::Dict, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.headvar-Tuple{ElemCo.FciDump.FDump, String}","page":"FCIDump files","title":"ElemCo.FciDump.headvar","text":"headvar(fd::FDump, key::String)\n\nCheck header for key, return value if a list,    or the element or nothing if not there.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.integ1","page":"FCIDump files","title":"ElemCo.FciDump.integ1","text":"integ1(fd::FDump, spincase::Symbol=:α)\n\nReturn 1-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α or :β.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.integ2","page":"FCIDump files","title":"ElemCo.FciDump.integ2","text":"integ2(fd::FDump, spincase::Symbol=:α)\n\nReturn 2-e⁻ integrals (for UHF fcidump: for spincase).   spincase can be :α, :β or :αβ.\n\n\n\n\n\n","category":"function"},{"location":"dump/#ElemCo.FciDump.modify_header!-Tuple{ElemCo.FciDump.FDump, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.modify_header!","text":"modify_header!(fd::FDump, norb, nelec; ms2=-1, isym=-1, orbsym=[])\n\nModify header of FDump object\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_fcidump-Tuple{String}","page":"FCIDump files","title":"ElemCo.FciDump.read_fcidump","text":"read_fcidump(fcidump::String)\n\nRead ascii file (possibly with integrals in npy files).\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.reorder_orbs_int2-Tuple{AbstractArray, Any}","page":"FCIDump files","title":"ElemCo.FciDump.reorder_orbs_int2","text":"reorder_orbs_int2(int2::AbstractArray, orbs)\n\nReorder orbitals in 2-e integrals according to orbs.\n\norbscan be a subset of orbitals or a permutation of orbitals.   Return int2[orbs[p],orbs[q],orbs[r],orbs[s]] or the triangular version.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_fcidump-Tuple{ElemCo.FciDump.FDump, AbstractArray, AbstractArray}","page":"FCIDump files","title":"ElemCo.FciDump.transform_fcidump","text":"transform_fcidump(fd::FDump, Tl::AbstractArray, Tr::AbstractArray)\n\nTransform integrals to new basis using Tl and Tr transformation matrices.    For UHF fcidump, Tl and Tr are arrays of matrices for α and β spin.   If Tl and Tr are arrays of arrays, then the function transforms rhf fcidump to uhf fcidump.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular-Tuple{Any, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular","text":"uppertriangular(i1, i2, i3)\n\nReturn upper triangular index from three indices i1 <= i2 <= i3.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular-Tuple{Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular","text":"uppertriangular(i1, i2)\n\nReturn upper triangular index from two indices i1 <= i2.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular_range-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular_range","text":"uppertriangular_range(i2)\n\nReturn range for the upper triangular index (i1 <= i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_fcidump","page":"FCIDump files","title":"ElemCo.FciDump.write_fcidump","text":"write_fcidump(fd::FDump, fcidump::String, tol=1e-12)\n\nWrite fcidump file.\n\n\n\n\n\n","category":"function"},{"location":"dump/#Internal-functions","page":"FCIDump files","title":"Internal functions","text":"","category":"section"},{"location":"dump/","page":"FCIDump files","title":"FCIDump files","text":"Modules = [FciDump]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dump/#ElemCo.FciDump.mmap_integrals-Tuple{ElemCo.FciDump.FDump, AbstractString, AbstractString}","page":"FCIDump files","title":"ElemCo.FciDump.mmap_integrals","text":"mmap_integrals(fd::FDump, dir::AbstractString, key::AbstractString)\n\nMemory-map integral file (from head[key])\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.print_int_value-NTuple{6, Any}","page":"FCIDump files","title":"ElemCo.FciDump.print_int_value","text":"print_int_value(fdf, integ, i1, i2, i3, i4)\n\nPrint integral value to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_header-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.read_header","text":"read_header(fdfile::IOStream)\n\nRead header of fcidump file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_integrals!-Tuple{ElemCo.FciDump.FDump, AbstractString}","page":"FCIDump files","title":"ElemCo.FciDump.read_integrals!","text":"read_integrals!(fd::FDump, dir::AbstractString)\n\nRead integrals from npy files.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.read_integrals!-Tuple{ElemCo.FciDump.FDump, IOStream}","page":"FCIDump files","title":"ElemCo.FciDump.read_integrals!","text":"read_integrals!(fd::FDump, fdfile::IOStream)\n\nRead integrals from fcidump file\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.set_int2!-Tuple{AbstractArray, Vararg{Any, 8}}","page":"FCIDump files","title":"ElemCo.FciDump.set_int2!","text":"set_int2!(int2::AbstractArray, i1, i2, i3, i4, integ, triang, simtra, ab)\n\nSet 2-e integral in int2 array to integ considering permutational symmetries.\n\nFor not ab: particle symmetry is assumed.   Integrals are stored in physicists' notation.   If triang: the last two indices are stored as a single upper triangular index.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.strict_uppertriangular_range-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.strict_uppertriangular_range","text":"strict_uppertriangular_range(i2)\n\nReturn range for the upper triangular index (i1 <= i2) without diagonal (i1 < i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_int1-Tuple{AbstractArray, AbstractArray, AbstractArray}","page":"FCIDump files","title":"ElemCo.FciDump.transform_int1","text":"transform_int1(int1::AbstractArray, Tl::AbstractArray,  Tr::AbstractArray)\n\nTransform 1-e integrals to new basis using Tl and Tr transformation matrices.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.transform_int2-Tuple{AbstractArray, AbstractArray, AbstractArray, AbstractArray, AbstractArray, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.transform_int2","text":"transform_int2(int2::AbstractArray, Tl::AbstractArray, Tl2::AbstractArray, \n               Tr::AbstractArray, Tr2::AbstractArray, triang_in, triang_out)\n\nTransform 2-e integrals to new basis using Tl/Tl2 and Tr/Tr2 transformation matrices.\n\nv_pq^rs = v_pq^rs* Tl[p',p] * Tl2[q',q] * Tr[r',r] * Tr2[s',s]\n\nIf triang: the last two indices are stored as a single upper triangular index.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.uppertriangular_diagonal-Tuple{Any}","page":"FCIDump files","title":"ElemCo.FciDump.uppertriangular_diagonal","text":"uppertriangular_diagonal(i2)\n\nReturn index of diagonal of upper triangular index (i1 <= i2) for a given i2. \n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_header-Tuple{ElemCo.FciDump.FDump, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_header","text":"write_header(fd::FDump, fdf)\n\nWrite header of fcidump file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals-Tuple{ElemCo.FciDump.FDump, Any, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals","text":"write_integrals(fd::FDump, fdf, tol)\n\nWrite integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals1-NTuple{4, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals1","text":"write_integrals1(int1, fdf, tol, simtra)\n\nWrite 1-e integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"dump/#ElemCo.FciDump.write_integrals2-NTuple{5, Any}","page":"FCIDump files","title":"ElemCo.FciDump.write_integrals2","text":"write_integrals2(int2, fdf, tol, triang, simtra)\n\nWrite 2-e integrals to fdf file.\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#Driver-for-conventional-coupled-cluster-methods","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"","category":"section"},{"location":"ccdriver/","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"CurrentModule = ElemCo.CCDriver","category":"page"},{"location":"ccdriver/","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"CCDriver","category":"page"},{"location":"ccdriver/#ElemCo.CCDriver","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver","text":"CCDriver\n\nModule for coupled-cluster drivers.\n\n\n\n\n\n","category":"module"},{"location":"ccdriver/","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"The CCDriver module contains the main driver routines for running coupled-cluster calculations.","category":"page"},{"location":"ccdriver/#Exported-functions","page":"Driver for conventional coupled-cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"ccdriver/","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"Modules = [CCDriver]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"ccdriver/#ElemCo.CCDriver.ccdriver-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.ccdriver","text":"ccdriver(EC::ECInfo, method; fcidump=\"\", occa=\"-\", occb=\"-\")\n\nRun electronic structure calculation for EC::ECInfo using method::String.\n\nThe integrals are read from fcidump::String.   If fcidump::String is empty, the integrals from EC.fd are used.   The occupied α orbitals are given by occa::String (default: \"-\").   The occupied β orbitals are given by occb::String (default: \"-\").   If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).   The occupation strings can be given as a + separated list, e.g. occa = 1+2+3 or equivalently 1-3.    Additionally, the spatial symmetry of the orbitals can be specified with the syntax orb.sym, e.g. occa = \"-5.1+-2.2+-4.3\".\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.dfccdriver-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.dfccdriver","text":"dfccdriver(EC::ECInfo, method)\n\nRun electronic structure calculation for EC::ECInfo using method::String.\n\nThe integrals are calculated using density fitting.\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#Internal-functions","page":"Driver for conventional coupled-cluster methods","title":"Internal functions","text":"","category":"section"},{"location":"ccdriver/","page":"Driver for conventional coupled-cluster methods","title":"Driver for conventional coupled-cluster methods","text":"Modules = [CCDriver]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"ccdriver/#ElemCo.CCDriver.check_fcidump-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.check_fcidump","text":"check_fcidump(EC::ECInfo, fcidump)\n\nRead the integrals from fcidump if it is not empty. \n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.check_occs-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.check_occs","text":"check_occs(EC::ECInfo, occa, occb)\n\nCheck the occupation strings occa and occb and set the corresponding options in    WfOptions.   Return the previous values of occa and occb.\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.checkset_unrestricted_closedshell!-Tuple{ElemCo.ECMethods.ECMethod, Any, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.checkset_unrestricted_closedshell!","text":"checkset_unrestricted_closedshell!(ecmethod::ECMethod, closed_shell, unrestricted)\n\nCheck if the method is unrestricted/closed-shell and if necessary set    the corresponding options in ECMethod.   Return closed_shell_method::Bool.\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_cc_groundstate-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod, NamedTuple}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_cc_groundstate","text":"eval_cc_groundstate(EC::ECInfo, ecmethod::ECMethod, energies::NamedTuple; save_pert_t3=false)\n\nEvaluate the coupled-cluster ground-state energy for the integrals in EC.fd.   Fock matrix and HF energy must be calculated before.   Return the updated energies::NamedTuple with the correlation energy (method*\"c\") and    the total energy (field method) (with - in method replaced by _).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_df_mo_integrals-Tuple{ElemCo.ECInfos.ECInfo, NamedTuple}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_df_mo_integrals","text":"eval_df_mo_integrals(EC::ECInfo, energies::NamedTuple)\n\nEvaluate the density-fitted integrals in MO basis    and store in the correct file.\n\nReturn the reference energy as HF field in NamedTuple and    true if the integrals are calculated using unresctricted orbitals.\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_dfcc_groundstate-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod, NamedTuple}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_dfcc_groundstate","text":"eval_dfcc_groundstate(EC::ECInfo, ecmethod::ECMethod, energies::NamedTuple)\n\nEvaluate the coupled-cluster ground-state energy for the DF integrals,   which have to be calculated before.   Return the updated energies::NamedTuple with the correlation energy (method*\"c\") and    the total energy (field method) (with - in method replaced by _).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_dmrg_groundstate-Tuple{ElemCo.ECInfos.ECInfo, NamedTuple}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_dmrg_groundstate","text":"eval_dmrg_groundstate(EC::ECInfo, energies::NamedTuple)\n\nEvaluate the DMRG ground-state energy for the integrals in EC.fd.   HF energy must be calculated before.   Return the updated energies::NamedTuple with the correlation energy (\"DMRGc\") and    the total energy (field DMRG).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_hf_energy-Tuple{ElemCo.ECInfos.ECInfo, NamedTuple, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_hf_energy","text":"eval_hf_energy(EC::ECInfo, energies::NamedTuple, closed_shell)\n\nEvaluate the Hartree-Fock energy for the integrals in EC.fd.   Return the updated energies::NamedTuple with the Hartree-Fock energy (field HF).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_mp2_energy-Tuple{ElemCo.ECInfos.ECInfo, NamedTuple, Any, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_mp2_energy","text":"eval_mp2_energy(EC::ECInfo, energies::NamedTuple, closed_shell, restricted)\n\nEvaluate the MP2 energy for the integrals in EC.fd.    Fock matrix and HF energy must be calculated before.   Return the updated energies::NamedTuple with    same-spin(MP2SS), opposite-spin(MP2OS), open-shell(MP2O) components,    SCS-MP2 energy (SCSMP2), correlation energy (MP2c) and   the MP2 energy (field MP2).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.eval_svd_dc_ccsdt-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod, NamedTuple}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.eval_svd_dc_ccsdt","text":"eval_svd_dc_ccsdt(EC::ECInfo, ecmethod::ECMethod, energies::NamedTuple)\n\nEvaluate the coupled-cluster ground-state energy for the integrals in EC.fd using SVD-Triples.   Fock matrix and HF energy must be calculated before.   Return the updated energies::NamedTuple with the correlation energy (method*\"c\") and    the total energy (field method) (with - in method replaced by _).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.output_2d_energy-Tuple{ElemCo.ECInfos.ECInfo, Any, NamedTuple, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.output_2d_energy","text":"output_2d_energy(EC::ECInfo, En, energies::NamedTuple, method; print=true)\n\nPrint the energy components for 2D methods and return the updated energies::NamedTuple with    singlet(\"SING\"*method), triplet(\"TRIP\"*method), singlet correlation(\"SING\"*method*\"c\") and    triplet correlation(\"TRIP\"*method*\"c\") components (with - in method replaced by _).\n\n\n\n\n\n","category":"method"},{"location":"ccdriver/#ElemCo.CCDriver.output_energy-Tuple{ElemCo.ECInfos.ECInfo, NamedTuple, NamedTuple, Any}","page":"Driver for conventional coupled-cluster methods","title":"ElemCo.CCDriver.output_energy","text":"output_energy(EC::ECInfo, En::NamedTuple, energies::NamedTuple, mname; print=true)\n\nPrint the energy components and return the updated energies::NamedTuple with    correction to the correlation energy (mname*\"correction\", e.g., ΔMP2, if available),   same-spin(mname*\"SS\"), opposite-spin(mname*\"OS\"), open-shell(mname*\"O\") components,    SCS energy (\"SCS\"*mname), correlation energy (mname*\"c\") and    the total energy (field mname) (with - in mname replaced by _).\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#Generation-of-integrals-using-density-fitting","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"CurrentModule = ElemCo.DfDump","category":"page"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"DfDump","category":"page"},{"location":"dfdump/#ElemCo.DfDump","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump","text":"generate fcidump using df integrals and store in dumpfile \n\n\n\n\n\n","category":"module"},{"location":"dfdump/#Exported-functions","page":"Generation of integrals using density fitting","title":"Exported functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"Modules = [DfDump]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfdump/#ElemCo.DfDump.dfdump-Tuple{ElemCo.ECInfos.ECInfo}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.dfdump","text":"dfdump(EC::ECInfo)\n\nGenerate fcidump using df integrals and store in IntOptions.fcidump.   If IntOptions.fcidump is empty, don't write to fcidump file, store in EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#Internal-functions","page":"Generation of integrals using density fitting","title":"Internal functions","text":"","category":"section"},{"location":"dfdump/","page":"Generation of integrals using density fitting","title":"Generation of integrals using density fitting","text":"Modules = [DfDump]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfdump/#ElemCo.DfDump.generate_integrals-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.FciDump.FDump, Any, Any, Any}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.generate_integrals","text":"generate_integrals(EC::ECInfo, fdump::FDump, cMOa, cMOb, full_spaces)\n\nGenerate int2aa, int2bb, int2ab, int1a, int1b and int0 integrals for fcidump using density fitting.\n\nmpfit basis is used for int2 integrals, and jkfit basis-correction is   used for int1 and int0 integrals.    full_spaces is a dictionary with spaces without frozen orbitals.\n\n\n\n\n\n","category":"method"},{"location":"dfdump/#ElemCo.DfDump.generate_integrals-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.FciDump.FDump, Any, Any}","page":"Generation of integrals using density fitting","title":"ElemCo.DfDump.generate_integrals","text":"generate_integrals(EC::ECInfo, fdump::FDump, cMO, full_spaces)\n\nGenerate int2, int1 and int0 integrals for fcidump using density fitting.\n\nmpfit basis is used for int2 integrals, and jkfit basis-correction is   used for int1 and int0 integrals.    full_spaces is a dictionary with spaces without frozen orbitals.\n\n\n\n\n\n","category":"method"},{"location":"dmrg/#DMRG","page":"DMRG","title":"DMRG","text":"","category":"section"},{"location":"dmrg/","page":"DMRG","title":"DMRG","text":"ElemCo.DMRG","category":"page"},{"location":"dmrg/#ElemCo.DMRG","page":"DMRG","title":"ElemCo.DMRG","text":"DMRG\n\nDensity Matrix Renormalization Group (DMRG) calculations using ITensors.jl package.\n\n\n\n\n\n","category":"module"},{"location":"dmrg/#Exported-functions","page":"DMRG","title":"Exported functions","text":"","category":"section"},{"location":"dmrg/","page":"DMRG","title":"DMRG","text":"Modules = [ElemCo.DMRG]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dmrg/#ElemCo.DMRG.calc_dmrg-Tuple{ElemCo.ECInfos.ECInfo}","page":"DMRG","title":"ElemCo.DMRG.calc_dmrg","text":"calc_dmrg(EC::ECInfo)\n\nPerform DMRG calculation\n\n\n\n\n\n","category":"method"},{"location":"dmrg/#Internal-functions","page":"DMRG","title":"Internal functions","text":"","category":"section"},{"location":"dmrg/","page":"DMRG","title":"DMRG","text":"Modules = [ElemCo.DMRG]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dmrg/#ElemCo.DMRG.gen_hamiltonian","page":"DMRG","title":"ElemCo.DMRG.gen_hamiltonian","text":"gen_hamiltonian(EC::ECInfo)\n\nGenerate the Hamiltonian tensor for the DMRG calculation.\n\n\n\n\n\n","category":"function"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"CurrentModule = ElemCo.Utils","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"Utils","category":"page"},{"location":"utils/#ElemCo.Utils","page":"Utils","title":"ElemCo.Utils","text":"various utilities \n\n\n\n\n\n","category":"module"},{"location":"utils/#Exported-functions","page":"Utils","title":"Exported functions","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"utils/#ElemCo.Utils.amdmkl","page":"Utils","title":"ElemCo.Utils.amdmkl","text":"amdmkl(reset::Bool=false)\n\nCreate a modified libmkl_rt.so and libmkl_core.so to make MKL work   fast on \"Zen\" AMD machines (e.g., Ryzen series). Solution is based on   this forum post.\n\nThis function is only needed on AMD machines. In order to execute it,   call amdmkl() in a separate Julia session (not in the same session   where you want to run calculations).   For example, your workflow could look like this:\n\n> julia -e 'using ElemCo; ElemCo.amdmkl()'\n> julia input.jl\n\nwhere input.jl is your script that uses ElemCo.jl.   The changes can be reverted by calling amdmkl(true).\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.argmaxN-Tuple{Any, Any}","page":"Utils","title":"ElemCo.Utils.argmaxN","text":"argmaxN(vals, N; by::Function=identity)\n\nReturn the indices of the N largest elements in vals.\n\nThe order of equal elements is preserved.   The keyword argument by can be used to specify a function to compare the elements, i.e.,   the function is applied to the elements before comparison.\n\nExample\n\njulia   julia> argmaxN([1,2,3,4,5,6,7,8,9,10], 3)   3-element Vector{Int64}:    10     9     8   julia> argmaxN([1,2,3,4,5,-6,-7,-8,-9,-10], 3; by=abs)   3-element Vector{Int64}:    10     9     8   julia> argmaxN([1.0, 1.10, 1.112, -1.113, 1.09], 3; by=x->round(abs(x),digits=2))   3-element Vector{Int64}:    3    4    2\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.draw_endline","page":"Utils","title":"ElemCo.Utils.draw_endline","text":"draw_endline()\n\nPrint a line of ═.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.draw_line","page":"Utils","title":"ElemCo.Utils.draw_line","text":"draw_line(n = 63)\n\nPrint a thick line of n characters.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.kwarg_provided_in_macro-Tuple{Any, Symbol}","page":"Utils","title":"ElemCo.Utils.kwarg_provided_in_macro","text":"kwarg_provided_in_macro(kwargs, key::Symbol)\n\nCheck whether key is in kwargs. \n\nThis is used in macros to check whether a keyword argument is passed.   The keyword argument in question key is passed as a symbol, e.g. :thr.   kwargs is the keyword argument list passed to the macro.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.mainname-Tuple{String}","page":"Utils","title":"ElemCo.Utils.mainname","text":"mainname(file::String)\n\nReturn the main name of a file, i.e. the part before the last dot and the extension.\n\nExamples:\n\njulia> mainname(\"~/test.xyz\")\n(\"test\", \"xyz\")\n\njulia> mainname(\"test\")\n(\"test\", \"\")\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.print_info","page":"Utils","title":"ElemCo.Utils.print_info","text":"print_info(info::AbstractString, additional_info::AbstractString=\"\")\n\nPrint info between two lines.\n\nIf additional not empty: additional info after main.\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.print_time-Tuple{ElemCo.AbstractEC.AbstractECInfo, Any, AbstractString, Int64}","page":"Utils","title":"ElemCo.Utils.print_time","text":"print_time(EC::AbstractECInfo, t1, info::AbstractString, verb::Int)\n\nPrint time with message info if verbosity verb is smaller than EC.verbosity.\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.reshape_buf-Tuple{Array, Vararg{Any}}","page":"Utils","title":"ElemCo.Utils.reshape_buf","text":"reshape_buf(buf::Array, dims...; start=1)\n\nReshape (part of) a buffer to given dimensions (without copying),   starting at start.\n\nIt can be used, e.g., for itermediates in tensor contractions.\n\nExample\n\njulia> buf = Array{Float64}(undef, 100000)\njulia> A = reshape_buf(buf, 10, 10, 20) # 10x10x20 tensor\njulia> B = reshape_buf(buf, 10, 10, 10, start=2001) # 10x10x10 tensor starting at 2001\njulia> B = rand(10,10,10)\njulia> C = rand(10,20)\njulia> @tensor A[i,j,k] = B[i,j,l] * C[l,k]\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.subspace_in_space-Tuple{Any, Any}","page":"Utils","title":"ElemCo.Utils.subspace_in_space","text":"subspace_in_space(subspace, space)\n\nReturn the positions of subspace in space    (with respect to space)\n\nsubspace and space are lists of indices    with respect to the full space (e.g., 1:norb).\n\nExamples\n\njulia> get_subspace_of_space([1,3,5], [1,3,4,5])\n3-element Array{Int64,1}:\n  1\n  2 \n  4\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.subspace_in_space-Tuple{UnitRange{Int64}, UnitRange{Int64}}","page":"Utils","title":"ElemCo.Utils.subspace_in_space","text":"subspace_in_space(subspace::UnitRange{Int}, space::UnitRange{Int})\n\nReturn the positions of subspace in space    (with respect to space)\n\nsubspace and space are ranges of indices    with respect to the full space (e.g., 1:norb).\n\nExamples\n\njulia> get_subspace_of_space(4:6, 2:7)\n3:5\n\n\n\n\n\n","category":"method"},{"location":"utils/#ElemCo.Utils.substr","page":"Utils","title":"ElemCo.Utils.substr","text":"substr(string::AbstractString, start::Int, len::Int=-1)\n\nReturn substring of string  starting at start spanning len characters    (including unicode).   If len is not given, the substring spans to the end of string.\n\nExample:   julia   julia> substr(\"λabδcd\", 2, 3)   \"abδ\"\n\n\n\n\n\n","category":"function"},{"location":"utils/#ElemCo.Utils.substr-Tuple{AbstractString, UnitRange{Int64}}","page":"Utils","title":"ElemCo.Utils.substr","text":"substr(string::AbstractString, range::UnitRange{Int})\n\nReturn substring of string defined by range (including unicode).\n\nExample:   julia   julia> substr(\"λabδcd\", 2:4)   \"abδ\"\n\n\n\n\n\n","category":"method"},{"location":"utils/#Internal-functions","page":"Utils","title":"Internal functions","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"Modules = [Utils]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"utils/#ElemCo.Utils.draw_thin_line","page":"Utils","title":"ElemCo.Utils.draw_thin_line","text":"draw_thin_line(n = 63)\n\nPrint a thin line of n characters.\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#Density-fitted-Coupled-Cluster-methods","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"ElemCo.DFCoupledCluster","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster","text":"DFCoupledCluster\n\nDensity-fitted coupled-cluster methods.\n\n\n\n\n\n","category":"module"},{"location":"dfcc/#Exported-functions","page":"Density-fitted Coupled Cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"Modules = [ElemCo.DFCoupledCluster]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_dressed_3idx-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_dressed_3idx","text":"calc_dressed_3idx(EC::ECInfo, T1)\n\nCalculate dressed integrals for 3-index integrals from file mmL.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dc-Tuple{ElemCo.ECInfos.ECInfo, AbstractString}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dc","text":"calc_svd_dc(EC::ECInfo, method::AbstractString)\n\nCalculate decomposed closed-shell DCSD or DCD with   T^ij_ab=U^iX_a U^jY_b T_XY.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dc","text":"calc_svd_dc(EC::ECInfo, method::ECMethod)\n\nCalculate decomposed closed-shell DCSD or DCD with   T^ij_ab=U^iX_a U^jY_b T_XY.\n\nCurrently only DC methods are supported.    DF integrals are used (have to be calculated before).   The starting guess for SVD-coefficients is calculated without doubles,   see calc_doubles_decomposition_without_doubles.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#Internal-functions","page":"Density-fitted Coupled Cluster methods","title":"Internal functions","text":"","category":"section"},{"location":"dfcc/","page":"Density-fitted Coupled Cluster methods","title":"Density-fitted Coupled Cluster methods","text":"Modules = [ElemCo.DFCoupledCluster]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_3idx_svd_decomposition-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_3idx_svd_decomposition","text":"calc_3idx_svd_decomposition(EC::ECInfo, full_voL::AbstractArray)\n\nCalculate U^iX_a from v_a^iL using SVD.\n\nVersion without holding all v_a^iL integrals in memory.   full_voL is the full 3-index integral v_a^iL (can be mmaped).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_MP2_amplitudes_from_3idx-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_MP2_amplitudes_from_3idx","text":"calc_MP2_amplitudes_from_3idx(EC::ECInfo, voL::AbstractArray, ishift)\n\nCalculate MP2 amplitudes from v_a^iL.\n\nThe imaginary shift ishift is used in the denominator in the calculation of the MP2 amplitudes.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_MP2_from_3idx-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_MP2_from_3idx","text":"calc_MP2_from_3idx(EC::ECInfo, voL::AbstractArray, ishift)\n\nCalculate MP2 energy from v_a^iL.\n\nThe imaginary shift ishift is used in the denominator in the calculation of the MP2 amplitudes.   Returns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_deco_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_deco_doubles_energy","text":"calc_deco_doubles_energy(EC::ECInfo, T2)\n\nCalculate closed-shell doubles energy   using decomposed doubles amplitudes T2=T_XY   or T2=T^ij_ab using density-fitted integrals.\n\nReturns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_deco_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_deco_hylleraas","text":"calc_deco_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy   using contravariant decomposed doubles amplitudes T2=T_XY   or full contravariant doubles amplitude T2=T^ij_ab.\n\nReturns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_df_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_df_doubles_energy","text":"calc_df_doubles_energy(EC::ECInfo, T2)\n\nCalculate closed-shell doubles energy using DF integrals    and T2[a,b,i,j] = T^ij_ab.\n\nReturns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition","text":"calc_doubles_decomposition(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition_with_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition_with_doubles","text":"calc_doubles_decomposition_with_doubles(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY using explicit doubles amplitudes T^ij_ab.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_doubles_decomposition_without_doubles-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_doubles_decomposition_without_doubles","text":"calc_doubles_decomposition_without_doubles(EC::ECInfo)\n\nDecompose T^ij_ab=U^iX_a U^jY_b T_XY without explicit   calculation of T^ij_ab.\n\nThe decomposition is done in two steps:\n\nbar U^ibar X_a is calculated from v_a^iL using SVD (with threshold CcOptions.ampsvdtol×CcOptions.ampsvdfac);\nMP2 doubles T^i_aX are calculated from v_a^iL and U^iX_a and again decomposed using SVD and threshold CcOptions.ampsvdtol.\n\nThe SVD-basis is rotated to pseudocanonical basis to diagonalize    orbital-energy differences, ϵ_X = U^iX_a(ϵ_a-ϵ_i)U^iX_a.   The imaginary shift CcOptions.deco_ishiftp is used in the denominator in the calculation of the MP2 amplitudes.   The orbital energy differences are saved in file e_X.   The SVD-coefficients U^iX_a are saved in file C_voX.   The starting guess for doubles T_XY is saved in file T_XX.   Return full MP2 correlation energy, SS, OS, and Openshell(0.0) (using the imaginary shift)   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_svd_dcsd_residual-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_svd_dcsd_residual","text":"calc_svd_dcsd_residual(EC::ECInfo, T1, T2)\n\nCalculate decomposed closed-shell DCSD residual with   T^ij_ab=U^iX_a U^jY_b T_XY and   R_XY=U^iX_a U^jY_b R^ij_ab.   T2 contains decomposed amplitudes T_XY or full amplitudes T^ij_ab.\n\nIf T2 is T^ij_ab, the residual is also returned in full form.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.calc_voX-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.calc_voX","text":"calc_voX(EC::ECInfo; calc_vᵥᵒˣ=false, calc_vᵛₒₓ=false)\n\nCalculate hat v_a^iX = hat v_ak^ci U^kX_c    and/or hat v^c_kX = hat v_ak^ci U^a_kX   with hat v_ak^ci = hat v_a^cL hat v_k^iL    and U^kX_c from file C_voX.\n\nReturn a tuple (vᵥᵒˣ, vᵛₒₓ) (not calculated intermediates are empty arrays).\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.contravariant_deco_doubles","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.contravariant_deco_doubles","text":"contravariant_deco_doubles(EC::ECInfo, T2, projx=false)\n\nCalculate contravariant doubles amplitudes   T^ij_ab = 2T^ij_ab - T^ij_ba    with   T^ij_ab = U^iX_a U^jY_b T_XY.   If projx is true, the projected exchange is returned:   T_XY = U^a_iX U^b_jY T^ij_ab\n\n\n\n\n\n","category":"function"},{"location":"dfcc/#ElemCo.DFCoupledCluster.dress_df_fock-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.dress_df_fock","text":"dress_df_fock(EC::ECInfo, T1)\n\nDress DF fock matrix with DF 3-index integrals.\n\nThe dress-contribution is added to the original fock matrix   from file f_mm. The dressed fock matrix is stored in file df_mm.   Additionally, the coulomb and exchange dressing contributions to hat f_k^c    are stored in files dfc_ov and dfe_ov.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.gen_vₓˣᴸ-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.gen_vₓˣᴸ","text":"gen_vₓˣᴸ(EC::ECInfo)\n\nGenerate v_X^XL = v_a^cL U^a_kX U^kX_c using bare integrals.\n\nThe integrals and the SVD-coefficients are read from files mmL and C_voX,   and the result is stored in file X^XL.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.get_ssv_osvˣˣ-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.get_ssv_osvˣˣ","text":"get_ssv_osvˣˣ(EC::ECInfo)\n\nReturn ssv^XY = U^kX_c U^lX_d (v_kl^cd - v_lk^cd )   and osv^XY = U^kX_c U^lX_d v_kl^cd   with v_kl^cd = v_k^cL v_l^dLδ_LL. \n\nThe integrals will be read from files ssd_^XX and osd_^XX.    If the files do not exist, the integrals will be calculated   and stored in files ssd_^XX and osd_^XX.   vk^{cL} and U^{kX}c are read from files d_ovL and C_voX.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.save_pseudo_dress_df_fock-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.save_pseudo_dress_df_fock","text":"save_pseudo_dress_df_fock(EC::ECInfo)\n\nSave non-dressed DF fock matrix from file f_mm to dressed file df_mm.\n\n\n\n\n\n","category":"method"},{"location":"dfcc/#ElemCo.DFCoupledCluster.save_pseudodressed_3idx-Tuple{ElemCo.ECInfos.ECInfo}","page":"Density-fitted Coupled Cluster methods","title":"ElemCo.DFCoupledCluster.save_pseudodressed_3idx","text":"save_pseudodressed_3idx(EC::ECInfo)\n\nSave non-dressed 3-index integrals from file mmL to dressed files.\n\n\n\n\n\n","category":"method"},{"location":"elements/#Elements","page":"Elements","title":"Elements","text":"","category":"section"},{"location":"elements/","page":"Elements","title":"Elements","text":"ElemCo.Elements","category":"page"},{"location":"elements/#ElemCo.Elements","page":"Elements","title":"ElemCo.Elements","text":"Elements\n\nModule for handling elements and their electron configurations.\n\n\n\n\n\n","category":"module"},{"location":"elements/#Exported-constants,-types,-and-functions","page":"Elements","title":"Exported constants, types, and functions","text":"","category":"section"},{"location":"elements/","page":"Elements","title":"Elements","text":"Modules = [ElemCo.Elements]\nPrivate = false\nOrder = [:constant, :type, :function]","category":"page"},{"location":"elements/#ElemCo.Elements.ELEMENTS","page":"Elements","title":"ElemCo.Elements.ELEMENTS","text":"Elements with corresponding atomic numbers,    atomic masses, name, electron configuration, large core, small core (w/o semi-core).\n\n\n\n\n\n","category":"constant"},{"location":"elements/#ElemCo.Elements.SUBSHELLS_NAMES","page":"Elements","title":"ElemCo.Elements.SUBSHELLS_NAMES","text":"SUBSHELLS_NAMES\n\nNames of the subshells (s,p,d,f,g,h,i,k,l,m).\n\n\n\n\n\n","category":"constant"},{"location":"elements/#ElemCo.Elements.electron_distribution4element-Tuple{AbstractString, Vector{Int64}}","page":"Elements","title":"ElemCo.Elements.electron_distribution4element","text":"electron_distribution4element(elem::AbstractString, nsh4l::Vector{Int})\n\nDistribute electrons among first atomic orbitals in nsh4l[1]s nsh4l[2]p nsh4l[3]d nsh4l[4]f... order   considering the Hund's rule and electron configuration of the atom.   Average occupations to account for the spin degeneracy and hybridization.\n\n\n\n\n\n","category":"method"},{"location":"elements/#ElemCo.Elements.element_name_from_symbol-Tuple{AbstractString}","page":"Elements","title":"ElemCo.Elements.element_name_from_symbol","text":"element_name_from_symbol(elem::AbstractString)\n\nReturn the element name\n\n\n\n\n\n","category":"method"},{"location":"elements/#ElemCo.Elements.ncoreorbs","page":"Elements","title":"ElemCo.Elements.ncoreorbs","text":"ncoreorbs(elem::AbstractString, coretype::Symbol=:large)\n\nGuess the number of core orbitals in the element.\n\ncoretype:\n\n:large - large core (w/o semi-core)\n:small - small core (w/ semi-core)\n:none - no core\n\n\n\n\n\n","category":"function"},{"location":"elements/#ElemCo.Elements.nuclear_charge_of_center-Tuple{AbstractString}","page":"Elements","title":"ElemCo.Elements.nuclear_charge_of_center","text":"nuclear_charge_of_center(elem::AbstractString)\n\nReturn the nuclear charge of the element.\n\n\n\n\n\n","category":"method"},{"location":"elements/#Internal-constants,-types,-and-functions","page":"Elements","title":"Internal constants, types, and functions","text":"","category":"section"},{"location":"elements/","page":"Elements","title":"Elements","text":"Modules = [ElemCo.Elements]\nPublic = false\nOrder = [:type, :function]","category":"page"},{"location":"elements/#ElemCo.Elements.SubShell","page":"Elements","title":"ElemCo.Elements.SubShell","text":"Occupation of the subshell with quantum numbers n and l.\n\nn::Int64:  n-quantum number of the subshell.\nl::Int64:  l-quantum number of the subshell.\nnel::Int64:  Number of electrons in the subshell.\n\n\n\n\n\n","category":"type"},{"location":"elements/#ElemCo.Elements.n_orbitals_in_subshell-Tuple{Char}","page":"Elements","title":"ElemCo.Elements.n_orbitals_in_subshell","text":"n_orbitals_in_subshell(shell::Char)\n\nReturn the number of orbitals in the subshell.\n\n\n\n\n\n","category":"method"},{"location":"elements/#ElemCo.Elements.parse_electron_configuration-Tuple{AbstractString}","page":"Elements","title":"ElemCo.Elements.parse_electron_configuration","text":"parse_electron_configuration(e::AbstractString)\n\nParse the electron configuration string and return the number of electrons in each subshell.   e.g. \"[He] 2s^2 2p^6 3s^2 3p^6\" -> [SubShell(1,0,2), SubShell(2,0,2), SubShell(2,1,6), SubShell(3,0,2), SubShell(3,1,6)] \n\n\n\n\n\n","category":"method"},{"location":"msystem/#Molecular-system","page":"Molecular system","title":"Molecular system","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"CurrentModule = ElemCo.MSystem","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"MSystem","category":"page"},{"location":"msystem/#ElemCo.MSystem","page":"Molecular system","title":"ElemCo.MSystem","text":"Info about molecular system (geometry/basis).\n\nAtom and FlexibleSystem from AtomsBase package are used for the atoms and the molecular system, respectively.\n\n\n\n\n\n","category":"module"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The molecular system is the core of the simulation. It contains all the information about the molecule, including the geometry and basis sets. The molecular system is an instance of FlexibleSystem from the AtomsBase.jl package, and the basis set information is stored in :basis field of the molecular system and each atom. The molecular system is defined using the parse_geometry function:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"parse_geometry(geometry, basis)","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"where geometry is a string containing the molecular geometry in the XYZ format (or a xyz-file), and basis is a dictionary containing the basis set information (or a string defining the AO basis).","category":"page"},{"location":"msystem/#Geometry","page":"Molecular system","title":"Geometry","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The geometry of the molecule is defined using the geometry argument of the parse_geometry function. The geometry is defined in the XYZ format. Here's an example of how you can define the geometry of a water molecule:","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"geometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The first line of the geometry string contains the units of the coordinates. The supported units are bohr and angstrom (default is bohr). If the first line contains the number of atoms (as in the standard XYZ format), then the next line is skipped, and the default units are angstrom. The coordinates of the atoms are specified in the following lines. Each line contains the atomic symbol and the coordinates of the atom. The coordinates are separated by spaces or tabs.","category":"page"},{"location":"msystem/#Basis-set","page":"Molecular system","title":"Basis set","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"see Basis set","category":"page"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"The basis set is defined using the basis argument of the parse_geometry function.","category":"page"},{"location":"msystem/#Exported-functions-and-types","page":"Molecular system","title":"Exported functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"Modules = [MSystem]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"msystem/#ElemCo.MSystem.bond_length-Tuple{AtomsBase.Atom, AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.bond_length","text":"bond_length(cen1::Atom, cen2::Atom)\n\nCalculate bond length in bohr between two centers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.electron_distribution-Tuple{AtomsBase.AbstractSystem, AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.electron_distribution","text":"electron_distribution(ms::AbstractSystem, minbas::AbstractString)\n\nReturn the averaged number of electrons in the orbitals in the minimal basis set.\n\nNumber of orbitals in the minimal basis set has to be specified in minbas.jl.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_SYMBOL-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.element_SYMBOL","text":"element_SYMBOL(name::AbstractString)\n\nReturn element symbol in all caps and without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_SYMBOL-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.element_SYMBOL","text":"element_SYMBOL(atom::Atom)\n\nReturn element symbol in all caps and without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_name-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.element_name","text":"element_name(atom::Atom)\n\nReturn element name.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.element_symbol-Tuple{AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.element_symbol","text":"element_symbol(name::AbstractString)\n\nReturn element symbol without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.genxyz-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ms::AbstractSystem; unit=u\"angstrom\")\n\nGenerate xyz string with elements without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.genxyz-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.genxyz","text":"genxyz(ac::Atom; unit=u\"angstrom\")\n\nGenerate xyz string with element without numbers.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_ncore","page":"Molecular system","title":"ElemCo.MSystem.guess_ncore","text":"guess_ncore(ms::AbstractSystem, coretype::Symbol=:large)\n\nGuess the number of core orbitals in the system.\n\ncoretype as in Elements.ncoreorbs.\n\n\n\n\n\n","category":"function"},{"location":"msystem/#ElemCo.MSystem.guess_nelec-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.guess_nelec","text":"guess_nelec(ms::AbstractSystem)\n\nGuess the number of electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.is_dummy-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.is_dummy","text":"is_dummy(ac::Atom)\n\nCheck whether the atom is a dummy atom.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.nuclear_repulsion-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.nuclear_repulsion","text":"nuclear_repulsion(ms::AbstractSystem)\n\nCalculate nuclear repulsion energy.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.parse_geometry-Tuple{AbstractString, AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.parse_geometry","text":"parse_geometry(geometry::AbstractString, basis::AbstractString)\n\nParse geometry geometry and return FlexibleSystem object.   The geometry can be in xyz format or in a file.   The basis set can be defined for each element in the geometry.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.parse_geometry-Tuple{AbstractString, Dict}","page":"Molecular system","title":"ElemCo.MSystem.parse_geometry","text":"parse_geometry(geometry::AbstractString, basis::Dict)\n\nParse geometry geometry and return FlexibleSystem object.   The geometry can be in xyz format or in a file.   The basis set can be defined for each element in the geometry.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.set_dummy!-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.set_dummy!","text":"set_dummy!(ac::Atom)\n\nSet the atom as a dummy atom.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.system_exists-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.system_exists","text":"system_exists(ms::AbstractSystem)\n\nCheck whether the system is not empty.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.unset_dummy!-Tuple{AtomsBase.Atom}","page":"Molecular system","title":"ElemCo.MSystem.unset_dummy!","text":"unset_dummy!(ac::Atom)\n\nUnset the atom as a dummy atom.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#Internal-functions-and-types","page":"Molecular system","title":"Internal functions and types","text":"","category":"section"},{"location":"msystem/","page":"Molecular system","title":"Molecular system","text":"Modules = [MSystem]\nPublic = false\nOrder = [:type, :function]","category":"page"},{"location":"msystem/#ElemCo.MSystem.genbasis4element-Tuple{Dict, AbstractString}","page":"Molecular system","title":"ElemCo.MSystem.genbasis4element","text":"genbasis4element(basis::Dict,elem::AbstractString)\n\nSet element specific basis from, e.g., Dict(\"ao\"=>\"cc-pVDZ; o=aug-cc-pVDZ\",\"jkfit\"=>\"cc-pvdz-jkfit\")\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nalpha-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.guess_nalpha","text":"guess_nalpha(ms::AbstractSystem)\n\nGuess the number of alpha electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nbeta-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.guess_nbeta","text":"guess_nbeta(ms::AbstractSystem)\n\nGuess the number of beta electrons in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.guess_nocc-Tuple{AtomsBase.AbstractSystem}","page":"Molecular system","title":"ElemCo.MSystem.guess_nocc","text":"guess_nocc(ms::AbstractSystem)\n\nGuess the number of alpha and beta occupied orbitals in the neutral system.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.nshell4l_minbas-Tuple{Any, String}","page":"Molecular system","title":"ElemCo.MSystem.nshell4l_minbas","text":"nshell4l_minbas(nnum, basis::String)\n\nReturn the number of shells for each angular momentum in the minimal basis set. \n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.parse_xyz_geometry-Tuple{AbstractArray, Dict}","page":"Molecular system","title":"ElemCo.MSystem.parse_xyz_geometry","text":"parse_xyz_geometry(xyz_lines::AbstractArray, basis::Dict)\n\nParse xyz geometry xyz_lines stored as a vector of strings.   Return array of Atoms and an empty string in case of success.\n\nEmpty lines are skipped.   The default units are bohr. If the line is bohr or angstrom: change the units.   If the first line is a number: assume xyz format and skip the second line   (in this case, the default units are angstroms).   If parsing fails: return empty array and the line that failed.\n\n\n\n\n\n","category":"method"},{"location":"msystem/#ElemCo.MSystem.try2create_atom","page":"Molecular system","title":"ElemCo.MSystem.try2create_atom","text":"try2create_atom(line::AbstractString, basis::Dict, unit=u\"bohr\")\n\nCreate Atom from a line <Atom> x y z. \n\nunit is the unit of the coordinates.   Returns the center and a bool success variable.    If the line has a different format: return dummy center and false.\n\n\n\n\n\n","category":"function"},{"location":"mnpy/#Memory-maping-of-NPY-files","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"CurrentModule = ElemCo.MNPY","category":"page"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"MNPY","category":"page"},{"location":"mnpy/#ElemCo.MNPY","page":"Memory-maping of NPY files","title":"ElemCo.MNPY","text":"A simplified version of NPZ.jl for mmaping npy files\n\nNPY file format is described in https://github.com/numpy/numpy/blob/v1.7.0/numpy/lib/format.py\n\n\n\n\n\n","category":"module"},{"location":"mnpy/#Exported-functions","page":"Memory-maping of NPY files","title":"Exported functions","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"Modules = [MNPY]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"mnpy/#ElemCo.MNPY.mnpymmap-Tuple{AbstractString}","page":"Memory-maping of NPY files","title":"ElemCo.MNPY.mnpymmap","text":"mnpymmap(filename::AbstractString)\n\nMmap a variable from filename.  The input needs to be an npy file.\n\nnote: Zero-dimensional arrays\nZero-dimensional arrays are stripped while being read in, and the values that they contain are returned. This is a notable difference from numpy, where  numerical values are written out and read back in as zero-dimensional arrays.\n\nExamples\n\njulia> using NPZ\njulia> npzwrite(\"temp.npy\", ones(3))\njulia> mnpymmap(\"temp.npy\") # Mmaps the variable\n3-element Vector{Float64}:\n 1.0\n 1.0\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"mnpy/#Internal-functions","page":"Memory-maping of NPY files","title":"Internal functions","text":"","category":"section"},{"location":"mnpy/","page":"Memory-maping of NPY files","title":"Memory-maping of NPY files","text":"Modules = [MNPY]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"mnpy/#ElemCo.MNPY.readheader-Tuple{AbstractString}","page":"Memory-maping of NPY files","title":"ElemCo.MNPY.readheader","text":"readheader(filename)\n\nReturn a header corresponding to the variable contained in filename.  The header contains information about the eltype and size of the array that may be extracted using  the corresponding accessor functions.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#Bi-orthogonal-Hartree-Fock","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"CurrentModule = ElemCo.BOHF","category":"page"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"BOHF","category":"page"},{"location":"bohf/#ElemCo.BOHF","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF","text":"bi-orthogonal Hartree-Fock method     (using a similarity-transformed FciDump)\n\n\n\n\n\n","category":"module"},{"location":"bohf/#Exported-functions","page":"Bi-orthogonal Hartree-Fock","title":"Exported functions","text":"","category":"section"},{"location":"bohf/","page":"Bi-orthogonal Hartree-Fock","title":"Bi-orthogonal Hartree-Fock","text":"Modules = [BOHF]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"bohf/#ElemCo.BOHF.bohf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bohf","text":"bohf(EC::ECInfo)\n\nPerform BO-HF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#ElemCo.BOHF.bouhf-Tuple{ElemCo.ECInfos.ECInfo}","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.bouhf","text":"bouhf(EC::ECInfo)\n\nPerform BO-UHF using integrals from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"bohf/#ElemCo.BOHF.guess_boorb","page":"Bi-orthogonal Hartree-Fock","title":"ElemCo.BOHF.guess_boorb","text":"guess_boorb(EC::ECInfo, guess::Symbol, uhf=false)\n\nCalculate starting guess for BO-MO coefficients (left and right).   Type of initial guess for MO coefficients is given by guess.   uhf indicates whether the calculation is restricted or unrestricted.\n\nSee ScfOptions.guess for possible values.   (Note: :SAD` is not possible here and will be replaced by identity matrix!)\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.jl-global-information","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"CurrentModule = ElemCo.ECInfos","category":"page"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ECInfos","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos","page":"ElemCo.jl global information","title":"ElemCo.ECInfos","text":"Various global infos \n\n\n\n\n\n","category":"module"},{"location":"ecinfos/#Main-structure","page":"ElemCo.jl global information","title":"Main structure","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"ECInfo","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.ECInfo","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.ECInfo","text":"ECInfo\n\nGlobal information for ElemCo.\n\nscr::String: ⟨\"system-tmpdir/elemcojlscr/jl_*\"⟩ path to scratch directory.\next::String: ⟨\".bin\"⟩ extension of temporary files.\nverbosity::Int64: ⟨2⟩ verbosity level.\noptions::ElemCo.ECInfos.Options:  options.\nsystem::AtomsBase.AbstractSystem:  molecular system.\nfd::ElemCo.FciDump.FDump:  fcidump.\nfiles::Dict{String, String}:  information about (temporary) files. The naming convention is: prefix_ + name (+extension EC.ext added automatically). prefix can be:\nd for dressed integrals\nS for overlap matrix\nf for Fock matrix\ne for orbital energies\nD for density matrix\nh for core Hamiltonian\nC for transformation from one basis to another\nT for amplitudes\nU for trial vectors or Lagrange multipliers\nname is given by the subspaces involved:\no for occupied\nv for virtual\nO for occupied-β\nV for virtual-β\nm for (full) MO space\nM for (full) β-MO space\nA for AO basis\na for active orbitals\nd for doubly-occupied (closed-shell) orbitals\ns for singly-occupied (open-shell) orbitals\nS for singly-occupied with β electron (open-shell) orbitals\nP for auxiliary orbitals (fitting basis)\nL for auxiliary orbitals (Cholesky decomposition, orthogonal)\nX for auxiliary orbitals (amplitudes decomposition)\nThe order of subspaces is important, e.g., ov is occupied-virtual, vo is virtual-occupied. Normally, the first subspaces correspond to subscripts of the tensor. For example, T_vo contains the singles amplitudes T_a^i. Disambiguity can be resolved by introducing ^ to separate the subscripts from the superscripts, e.g., d_XX contains hat v_XY and d_^XX contains hat v^XY integrals.\n\nspace::Dict{Char, Any}:  subspaces: 'o'ccupied, 'v'irtual, 'O'ccupied-β, 'V'irtual-β, ':'/'m'/'M' full MO.\n\n\n\n\n\n","category":"type"},{"location":"ecinfos/#Exported-functions","page":"ElemCo.jl global information","title":"Exported functions","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"Modules = [ECInfos]\nPrivate = false\nOrder = [:function]\nFilter = t -> t ∉ [ElemCo.file_exists, ElemCo.add_file!, ElemCo.copy_file!, ElemCo.delete_file!, ElemCo.delete_files!, ElemCo.delete_temporary_files!]","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.file_description-Tuple{ElemCo.ECInfos.ECInfo, String}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.file_description","text":"file_description(EC::ECInfo, name::String)\n\nReturn description of file name in ECInfo.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.flipspin-Tuple{Char}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.flipspin","text":"flipspin(sp::Char)\n\nFlip spin for a given space character.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_core!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_core!","text":"freeze_core!(EC::ECInfo, core::Symbol, freeze_nocc::Int, freeze_orbs=[])\n\nFreeze freeze_nocc occupied orbitals or orbitals on the freeze_orbs list.    If freeze_nocc is negative and freeze_orbs is empty: guess the number of core orbitals.\n\ncore as in MSystem.guess_ncore.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_nocc!-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_nocc!","text":"freeze_nocc!(EC::ECInfo, freeze)\n\nFreeze occupied orbitals from the freeze list.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.freeze_nvirt!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.freeze_nvirt!","text":"freeze_nvirt!(EC::ECInfo, nfreeze::Int, freeze_orbs=[])\n\nFreeze nfreeze virtual orbitals or orbitals on the freeze_orbs list.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.get_occvirt-Tuple{ElemCo.ECInfos.ECInfo, String, String, Any, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.get_occvirt","text":"get_occvirt(EC::ECInfo, occas::String, occbs::String, norb, nelec; ms2=0, orbsym=Vector{Int})\n\nUse a +/- string to specify the occupation. If occbs==\"-\", the occupation from occas is used (closed-shell).   If both are \"-\", the occupation is deduced from nelec and ms2.   The optional argument orbsym is a vector with length norb of orbital symmetries (1 to 8) for each orbital.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.is_closed_shell-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.is_closed_shell","text":"is_closed_shell(EC::ECInfo)\n\nCheck if the system is closed-shell    according the to the reference occupation and FCIDump.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.isalphaspin-Tuple{Char, Char}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.isalphaspin","text":"isalphaspin(sp1::Char,sp2::Char)\n\nTry to guess spin of an electron: lowcase α, uppercase β, non-letters skipped.   Return true for α spin.  Throws an error if cannot decide.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.len_spaces-Tuple{ElemCo.ECInfos.ECInfo, String}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.len_spaces","text":"len_spaces(EC::ECInfo, spaces::String)\n\nReturn lengths of spaces (e.g., \"vo\" for occupied and virtual orbitals).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_occ_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occ_orbs","text":"n_occ_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (for UHF: α).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_occb_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_occb_orbs","text":"n_occb_orbs(EC::ECInfo)\n\nReturn number of occupied orbitals (β).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_orbs","text":"n_orbs(EC::ECInfo)\n\nReturn number of orbitals.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_virt_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virt_orbs","text":"n_virt_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (for UHF: α).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.n_virtb_orbs-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.n_virtb_orbs","text":"n_virtb_orbs(EC::ECInfo)\n\nReturn number of virtual orbitals (β).\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.parse_orbstring-Tuple{String}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.parse_orbstring","text":"parse_orbstring(orbs::String; orbsym=Vector{Int})\n\nParse a string specifying some list of orbitals, e.g.,    -3+5-8+10-12 → [1 2 3 5 6 7 8 10 11 12]   or use ':' and ';' instead of '-' and '+', respectively.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.reset_wf_info!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.reset_wf_info!","text":"reset_wf_info!(EC::ECInfo)\n\nReset ECInfos.WfOptions to default.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.restore_space!-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.restore_space!","text":"restore_space!(EC::ECInfo, space)\n\nRestore the space.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.save_space-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.save_space","text":"save_space(EC::ECInfo)\n\nSave the current subspaces of space.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!-Tuple{Any, Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt, allopts)\n\nSet options for option opt from allopts.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.set_options!-Tuple{Any}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.set_options!","text":"set_options!(opt; kwargs...)\n\nSet options for option opt using keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space!-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space!","text":"setup_space!(EC::ECInfo, norb, nelec, ms2, orbsym)\n\nSetup EC.space from norb, nelec, ms2, orbsym or occa/occb.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space_fd!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space_fd!","text":"setup_space_fd!(EC::ECInfo)\n\nSetup EC.space from fcidump EC.fd.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.setup_space_system!-Tuple{ElemCo.ECInfos.ECInfo}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.setup_space_system!","text":"setup_space_system(EC::ECInfo)\n\nSetup EC.space from molecular system EC.system.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.space4spin-Tuple{Char, Bool}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.space4spin","text":"space4spin(sp::Char, alpha::Bool)\n\nReturn the space character for a given spin.   sp on input has to be lowercase.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#ElemCo.ECInfos.spin4space-Tuple{Char}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.spin4space","text":"spin4space(sp::Char)\n\nReturn spin for a given space character.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#File-management","page":"ElemCo.jl global information","title":"File management","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"file_exists\nadd_file!\ncopy_file!\ndelete_file!\ndelete_files!\ndelete_temporary_files!","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.file_exists","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.file_exists","text":"file_exists(EC::ECInfo, name::String)\n\nCheck if file name exists in ECInfo.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.add_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.add_file!","text":"add_file!(EC::ECInfo, name::String, descr::String; overwrite=false)\n\nAdd file name to ECInfo with (space-separated) descriptions descr.   Possible description: tmp (temporary).\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.copy_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.copy_file!","text":"copy_file!(EC::ECInfo, from::AbstractString, to::AbstractString; overwrite=false)\n\nCopy file from to to.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_file!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_file!","text":"delete_file!(EC::ECInfo, name::AbstractString)\n\nDelete file name from ECInfo.\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_files!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_files!","text":"delete_files!(EC::ECInfo, which::AbstractString)\n\nDelete files in ECInfo which match description in which.\n\nwhich can be a space-separated string of descriptions (then all descriptions have to match)   Examples: \n\ndelete_files!(EC, \"tmp\") deletes all temporary files.\ndelete_files!(EC, \"tmp orbs\") deletes all temporary files with additional description \"orbs\"\n\n\n\n\n\ndelete_files!(EC::ECInfo, which::AbstractArray{String})\n\nDelete files in ECInfo which match any description in array which.\n\nExamples: \n\ndelete_files!(EC, [\"tmp\",\"orbs\"]) deletes all temporary files and all files with description \"orbs\".\ndelete_files!(EC, [\"tmp orbs\",\"tmp2\"]) deletes all temporary files with description \"orbs\" and all files with description \"tmp2\".\n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#ElemCo.ECInfos.delete_temporary_files!","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.delete_temporary_files!","text":"delete_temporary_files!(EC::ECInfo)\n\nDelete all temporary files in ECInfo.  \n\n\n\n\n\n","category":"function"},{"location":"ecinfos/#Internal-functions","page":"ElemCo.jl global information","title":"Internal functions","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"Modules = [ECInfos]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"ecinfos/#ElemCo.ECInfos.symorb2orb-Tuple{SubString, Vector{Int64}}","page":"ElemCo.jl global information","title":"ElemCo.ECInfos.symorb2orb","text":"symorb2orb(symorb::SubString, symoffset::Vector{Int})\n\nConvert a symorb (like 1.3 [orb.sym]) to an orbital number.   If no sym given, just return the orbital number converted to Int.\n\n\n\n\n\n","category":"method"},{"location":"ecinfos/#Abstract-types","page":"ElemCo.jl global information","title":"Abstract types","text":"","category":"section"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"CurrentModule = ElemCo.AbstractEC","category":"page"},{"location":"ecinfos/","page":"ElemCo.jl global information","title":"ElemCo.jl global information","text":"AbstractEC","category":"page"},{"location":"ecinfos/#ElemCo.AbstractEC","page":"ElemCo.jl global information","title":"ElemCo.AbstractEC","text":"Abstract types to resolve circular dependencies\n\n\n\n\n\n","category":"module"},{"location":"decomptools/#Tensor-decomposition-tools","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"ElemCo.DecompTools","category":"page"},{"location":"decomptools/#ElemCo.DecompTools","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools","text":"This module contains functions for tensor decomposition methods.\n\n\n\n\n\n","category":"module"},{"location":"decomptools/#Exported-functions","page":"Tensor-decomposition tools","title":"Exported functions","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"Modules = [ElemCo.DecompTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"decomptools/#ElemCo.DecompTools.calc_integrals_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.calc_integrals_decomposition","text":"calc_integrals_decomposition(EC::ECInfo)\n\nDecompose v_pr^qs as v_p^qL v_r^sL and store as mmL.\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.eigen_decompose","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.eigen_decompose","text":"eigen_decompose(T2mat, nvirt, nocc, tol=1e-6)\n\nEigenvector-decompose symmetric doubles T2[ai,bj] matrix:    T^ij_ab = U^iX_a T_XY U^jY_b δ_XY.   Return U^iX_a as U[a,i,X] for T_XX > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#ElemCo.DecompTools.iter_svd_decompose-NTuple{4, Any}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.iter_svd_decompose","text":"iter_svd_decompose(Amat, nvirt, nocc, naux)\n\nIteratively decompose A[ai,ξ] as U^iX_a Σ_X δ_XY V^Y_ξ.   Return U^iX_a as U[a,i,X] for first naux Σ_X\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.rotate_U2pseudocanonical-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.rotate_U2pseudocanonical","text":"rotate_U2pseudocanonical(EC::ECInfo, UaiX)\n\nDiagonalize ϵv - ϵo transformed with UaiX (for update).   Return eigenvalues and rotated UaiX\n\n\n\n\n\n","category":"method"},{"location":"decomptools/#ElemCo.DecompTools.svd_decompose","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.svd_decompose","text":"svd_decompose(Amat, tol=1e-6)\n\nSVD-decompose A[ξ,ξ'] as U^X_ξ Σ_X δ_XY V^Y_ξ.   Return U^X_ξ as U[ξ,X] for Σ_X > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#ElemCo.DecompTools.svd_decompose-2","page":"Tensor-decomposition tools","title":"ElemCo.DecompTools.svd_decompose","text":"svd_decompose(Amat, nvirt, nocc, tol=1e-6)\n\nSVD-decompose A[ai,ξ] as U^iX_a Σ_X δ_XY V^Y_ξ.   Return U^iX_a as U[a,i,X] for Σ_X > tol\n\n\n\n\n\n","category":"function"},{"location":"decomptools/#Internal-functions","page":"Tensor-decomposition tools","title":"Internal functions","text":"","category":"section"},{"location":"decomptools/","page":"Tensor-decomposition tools","title":"Tensor-decomposition tools","text":"Modules = [ElemCo.DecompTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#MCSCF-program","page":"MCSCF program","title":"MCSCF program","text":"","category":"section"},{"location":"dfmcscf/#Exported-functions","page":"MCSCF program","title":"Exported functions","text":"","category":"section"},{"location":"dfmcscf/","page":"MCSCF program","title":"MCSCF program","text":"Modules = [ElemCo.DFMCSCF]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dfmcscf-Tuple{ElemCo.ECInfos.ECInfo}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dfmcscf","text":"dfmcscf(EC::ECInfo; direct=false)\n\nMain body of Density-Fitted Multi-Configurational Self-Consistent-Field method\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#Internal-functions","page":"MCSCF program","title":"Internal functions","text":"","category":"section"},{"location":"dfmcscf/","page":"MCSCF program","title":"MCSCF program","text":"Modules = [ElemCo.DFMCSCF]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dfmcscf/#ElemCo.DFMCSCF.G_risj_calc-Tuple{Integer, Integer, Any, Any, Matrix, Any}","page":"MCSCF program","title":"ElemCo.DFMCSCF.G_risj_calc","text":"G_risj_calc(typer::Integer, types::Integer, num_MO, index_MO, fock_MO::Matrix, DFint_MO)\n\nCalculate the Grisj tensor for the given type of indices r and s. Typer and types are the type of indices r and s, respectively: 1 for doubly occupied orbitals, 2 for singly occupied orbitals, 3 for virtual orbitals. indexMO is the index of the given type of orbitals. DFintMO is the density fitting integrals in molecular orbital basis. Return Grisj tensor.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.G_rtsj_calc-Tuple{Integer, Integer, Any, Any, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.G_rtsj_calc","text":"function G_rtsj_calc(typer::Integer,types::Integer, num_MO, DFint_MO, D1::Matrix)\n\nCalculate the Grtsj tensor for the given type of indices r and s. Return Grtsj tensor.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.G_rtsu_calc-Tuple{Integer, Integer, Any, Any, Any, Matrix, Any, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.G_rtsu_calc","text":"G_rtsu_calc(typer::Integer,types::Integer, num_MO, index_MO, DFint_MO, D1::Matrix, D2, fockClosed_MO::Matrix)\n\nCalculate the Grtsu tensor for the given type of indices r and s. Return Grtsu tensor.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.H_multiply-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix, Matrix, Vector, Any, Vector, Number, NTuple{10, Matrix{Float64}}, Symbol}","page":"MCSCF program","title":"ElemCo.DFMCSCF.H_multiply","text":"H_multiply(EC::ECInfo, fock_MO::Matrix, cMO::Matrix, D1::Matrix, v::Vector, num_MO, g::Vector, λ::Number, h_block::NTuple{10, Matrix{Float64}}, HessianType::Symbol)\n\nDo the H * x calculation Depending on the Hessian type, do the calculation from unsimplified and simplified parts of blocks seperatly Calculate the first element of Hv vector, and the part of Hv from the multiplying of first element of v and g vector(first column of Hessian Matrix) Assembly the matrix the Hessian Matrix is  | 0           g21'*λ   g31'λ   g_22'λ   g32'*λ |                                       | g21λ  h2121        h2131        h2122        h2132      |                        | g_31λ  h3121        h3131        h3122        h3132      |                        | g22*λ  h2221        h2231        h2222        h2232      |                        | g32*λ  h3221        h3231        h3222        h3232      | Return vector σ in the order of [σ[1];σ21;σ31;σ22;σ32]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.Hx_SCI-Tuple{ElemCo.ECInfos.ECInfo, Matrix, Matrix, Vector, Any, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.Hx_SCI","text":"Hx_SCI(EC::ECInfo, fock_MO::Matrix, cMO::Matrix, x::Vector, num_MO, D1::Matrix)\n\nCalculate the SCI part of σ which are from 3 blocks which are zero from the Hessian caclulation funcion. SOSCI, SOSCI_original, SCI Hessians need this function Return vector σ in the order of [σ21;σ31;σ22;σ32]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.Hx_SO-NTuple{5, Any}","page":"MCSCF program","title":"ElemCo.DFMCSCF.Hx_SO","text":"Hx_SO(h_3131, h_3231, h_3121, x, num_MO)\n\nCalculate the SO part of σ which are from the 3 non-zero blocks of SO Hessian. Return vector σ in the order of [σ21;σ31;σ22;σ32]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.Hx_common-NTuple{8, Any}","page":"MCSCF program","title":"ElemCo.DFMCSCF.Hx_common","text":"Hx_common(h_2121, h_2221, h_3221, h_2231, h_2222, h_3222, h_3232, x)\n\nCalculate the common part of the σ which are from the 7 non-zero blocks for both SO and other simplified Hessian. Return vector σ in the order of [σ21;σ31;σ22;σ32]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_U-Tuple{ElemCo.ECInfos.ECInfo, Integer, Vector}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_U","text":"calc_U(EC::ECInfo, N_MO::Integer, x::Vector)\n\ncalculate orbital-rotational matrix U (approximately unitary because of the anti-hermitian property of the R which is constructed from x).\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_g-Tuple{ElemCo.ECInfos.ECInfo, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_g","text":"calc_g(EC::ECInfo, A::Matrix)\n\nCalculate the orbital gradient g by antisymmetrizing the matrix A and rearranging the elements. The order of the elements in vector gblockwise is vectorized g21, g31, g22, g32, among which g21 = g[occ1o,occ2], g31 = g[occv,occ2], g22 = g[occ1o,occ1o], g32 = g[occv,occ1o] return vector gblockwise\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_h_SCI","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_h_SCI","text":"calc_h_SCI(EC::ECInfo, μjL, μuL, cMO::Matrix, D1::Matrix, D2, fock_MO::Matrix, fockClosed_MO::Matrix, A::Matrix, HessianType::Symbol=:SCI)\n\nCalculate the SCI Hessian and modified SOSCI Hessian. Modified SOSCI method includes fixed part 4 blocks, the SO part 2 blocks, the SCI version of the rest 4 blocks(including h3232), among which 3(except h3232) are caculated in Hmultiply SCI Hessian includes fixed part 4 blocks, SCI special part 6 blocks, among which 3 blocks are caculated in this function, and 3 are caculated in Hmultiply Return h2121, h3121, h3131, h2221, h2231, h2222, h3221, h3231, h3222, h3232\n\n\n\n\n\n","category":"function"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_h_SO-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Matrix, Matrix, Any, Matrix, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_h_SO","text":"calc_h_SO(EC::ECInfo, μjL, μuL, abL, cMO::Matrix, D1::Matrix, D2, fock_MO::Matrix, fockClosed_MO::Matrix, A::Matrix)\n\nCalculate the Second Order Hessian. Second Order Hessian includes fixed part 4 blocks,  2 SO part blocks, the rest 4 blocks (including H3232) are calculated as SO special part, which are implemented in this function. Return h2121, h3121, h3131, h2221, h2231, h2222, h3221, h3231, h3222, h_3232\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_h_SO_SCI_original-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Matrix, Matrix, Any, Matrix, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_h_SO_SCI_original","text":"calc_h_SO_SCI_original(EC::ECInfo, μjL, μuL, abL, cMO::Matrix, D1::Matrix, D2, fock_MO::Matrix, fockClosed_MO::Matrix, A::Matrix)\n\nCalculate the original SOSCI Hessian. Original SOSCI Hessian includes fixed part 4 blocks, the SO part 3 blocks (including h3232), and the 3 SCI blocks. These 3 SCI blocks are returned as [1,1] zero matrix in this function, the calculation is done in the Hmultiply function. Return h2121, h3121, h3131, h2221, h2231, h2222, h3221, h3231, h3222, h3232\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.calc_realE-Tuple{ElemCo.ECInfos.ECInfo, Any, Matrix, Matrix, Any, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.calc_realE","text":"calc_realE(EC::ECInfo, μuL, fockClosed_MO::Matrix, D1::Matrix, D2, cMO::Matrix)\n\nCalculate the energy with the given density matrices and (updated) cMO,  E = (h_i^i + ^cf_i^i) + ^1D^t_u ^cf_t^u + 05 ^2D^tv_uw v_tv^uw.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.checkE_modifyTrust-Tuple{ElemCo.ECInfos.ECInfo, Number, Number, Number, Number, Bool}","page":"MCSCF program","title":"ElemCo.DFMCSCF.checkE_modifyTrust","text":"checkE_modifyTrust(E::Number, E_former::Number, E_2o::Number, trust::Number)\n\nCheck if the energy E is lower than the former energy E_former, if not, reject the update of coefficients and modify the trust region. Return reject::Bool and trust.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.denMatCreate-Tuple{ElemCo.ECInfos.ECInfo}","page":"MCSCF program","title":"ElemCo.DFMCSCF.denMatCreate","text":"denMatCreate(EC::ECInfo)\n\nCalculate the one particle density matrix and two particle density matrix of active electrons for high-spin determinant. D1[t,u] = ^1D^t_u = ΨhatE^t_uΨ  =  Ψ _σ hata^_tσ hata_uσΨ,  D2[t,u,v,w] = =^2D^tv_uw=05 ΨhatE^tv_uw+hatE^uv_twΨ,  in which hatE_tuvw = hatE^t_u hatE^v_w - δ_uv hatE^t_w = _στhata^_tσ hata^_vτ hata_wτ hata_uσ. Return D1 and D2.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dfACAS-Tuple{ElemCo.ECInfos.ECInfo, Any, Matrix, Matrix, Any, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dfACAS","text":"dfACAS(EC::ECInfo, μuL, cMO::Matrix, D1::Matrix, D2, fock_MO::Matrix, fockClosed_MO::Matrix)\n\nCalculate the A-intermediate matrix in molecular orbital basis. return matrix A[p,q]\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.dffockCAS-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.dffockCAS","text":"dffockCAS(EC::ECInfo, μνL, μjL, μuL, cMO::Matrix, D1::Matrix)\n\nCalculate fock matrices in molecular orbital basis. fockClosed[μ,ν] = ^cf_μ^ν = h_μ^ν + 2v_μi^νi - v_μi^iν,  fock[μ,ν] = f_μ^ν = ^cf_μ^ν + D^t_u (v_μt^νu - 05 v_μt^uν). fockMO and fockClosedMO are fock and fockClosed transformed into MO basis with coefficients cMO. Return matrix fockMO and fockClosedMO.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.h_calc_SOpart-Tuple{Any, Any, Any, Matrix, Any, Matrix, Matrix, Matrix}","page":"MCSCF program","title":"ElemCo.DFMCSCF.h_calc_SOpart","text":"h_calc_SOpart(num_MO, index_MO, DFint_MO, D1::Matrix, D2, fock_MO::Matrix, fockClosed_MO::Matrix, A::Matrix)\n\nCalculate the SO version of the h tensor, including h3221, h2121. This function is used in SO, SOSCIorigin, SOSCI Hessian calculation. Return h3221, h_2121.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.h_calc_fixed-Tuple{Any, Any, Matrix, Any, Matrix, Matrix, Any}","page":"MCSCF program","title":"ElemCo.DFMCSCF.h_calc_fixed","text":"h_calc_fixed(num_MO, index_MO, D1::Matrix, D2, fockClosed_MO::Matrix, A::Matrix, DFint_MO)\n\nCalculate the fixed part of the h tensor, including h2221, h2231, h2222, h3222. This function is used in all the Hessian calculation. Return h2221, h2231, h2222, h3222.\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.print_initial-Tuple{Float64, Symbol}","page":"MCSCF program","title":"ElemCo.DFMCSCF.print_initial","text":"print_initial(Enuc::Float64, HessianType::Symbol)\n\nPrint the information of the Hessian type\n\n\n\n\n\n","category":"method"},{"location":"dfmcscf/#ElemCo.DFMCSCF.λTuning-Tuple{ElemCo.ECInfos.ECInfo, Number, Integer, Number, Number, Vector, Vector, Vector{Int64}, NTuple{10, Matrix{Float64}}, Symbol, Matrix, Matrix, Symbol, Matrix, Bool}","page":"MCSCF program","title":"ElemCo.DFMCSCF.λTuning","text":"λTuning(EC::ECInfo, trust::Number, maxit4λ::Integer, λmax::Number, λ::Number, h::Matrix, g::Vector)\n\nFind the rotation parameters as the vector x in trust region, tuning λ with the norm of x in the iterations. Return λ and x.\n\n\n\n\n\n","category":"method"},{"location":"constants/#Constants-and-transformations-between-units","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"","category":"section"},{"location":"constants/","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"CurrentModule = ElemCo.Constants","category":"page"},{"location":"constants/","page":"Constants and transformations between units","title":"Constants and transformations between units","text":"Modules = [Constants]","category":"page"},{"location":"constants/#ElemCo.Constants","page":"Constants and transformations between units","title":"ElemCo.Constants","text":"Various constants for the package.\n\nIndividual constants are not exported. Use Constants.<name> to access them.\n\n\n\n\n\n","category":"module"},{"location":"constants/#ElemCo.Constants.A0","page":"Constants and transformations between units","title":"ElemCo.Constants.A0","text":"Bohr radius [m]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AMU","page":"Constants and transformations between units","title":"ElemCo.Constants.AMU","text":"atomic mass unit [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AMU2KG","page":"Constants and transformations between units","title":"ElemCo.Constants.AMU2KG","text":"atomic mass unit to kg [kgu^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.AU2DEBYE","page":"Constants and transformations between units","title":"ElemCo.Constants.AU2DEBYE","text":"au to Debye [Dau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.BOHR2ANGSTROM","page":"Constants and transformations between units","title":"ElemCo.Constants.BOHR2ANGSTROM","text":"Bohr to angstrom [AAau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.BOHR2METER","page":"Constants and transformations between units","title":"ElemCo.Constants.BOHR2METER","text":"Bohr to meter [mau^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.C","page":"Constants and transformations between units","title":"ElemCo.Constants.C","text":"speed of light in vacuum [ms^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.DEBYE","page":"Constants and transformations between units","title":"ElemCo.Constants.DEBYE","text":"Debye [Cm]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.E","page":"Constants and transformations between units","title":"ElemCo.Constants.E","text":"elementary charge [C]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.EPS0","page":"Constants and transformations between units","title":"ElemCo.Constants.EPS0","text":"vacuum electric permittivity [Fm^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.H","page":"Constants and transformations between units","title":"ElemCo.Constants.H","text":"Planck constant [Js]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE","text":"Hartree energy [J]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2CM","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2CM","text":"Hartree to cm^{-1} [cm^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2EV","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2EV","text":"Hartree to eV [eVE_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2K","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2K","text":"Hartree to Kelvin [KE_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2KCAL","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2KCAL","text":"Hartree to kcal/mol [kcalmol^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HARTREE2KJ","page":"Constants and transformations between units","title":"ElemCo.Constants.HARTREE2KJ","text":"Hartree to kJ/mol [kJmol^-1E_h^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.HBAR","page":"Constants and transformations between units","title":"ElemCo.Constants.HBAR","text":"reduced Planck constant [Js]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.KB","page":"Constants and transformations between units","title":"ElemCo.Constants.KB","text":"Boltzmann constant [JK^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.KCAL","page":"Constants and transformations between units","title":"ElemCo.Constants.KCAL","text":"kcal/mol [Jmol^-1]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.ME","page":"Constants and transformations between units","title":"ElemCo.Constants.ME","text":"electron mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MN","page":"Constants and transformations between units","title":"ElemCo.Constants.MN","text":"neutron mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MP","page":"Constants and transformations between units","title":"ElemCo.Constants.MP","text":"proton mass [kg]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.MU0","page":"Constants and transformations between units","title":"ElemCo.Constants.MU0","text":"vacuum magnetic permeability [NA^-2]\n\n\n\n\n\n","category":"constant"},{"location":"constants/#ElemCo.Constants.NA","page":"Constants and transformations between units","title":"ElemCo.Constants.NA","text":"Avogadro constant [mol^-1]\n\n\n\n\n\n","category":"constant"},{"location":"mio/#I/O-routines","page":"I/O routines","title":"I/O routines","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"CurrentModule = ElemCo.MIO","category":"page"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"MIO","category":"page"},{"location":"mio/#ElemCo.MIO","page":"I/O routines","title":"ElemCo.MIO","text":"EC-specific IO routines\n\nUse to store arrays in a file, and to load them back.   Use memory-maps to store and load large arrays.\n\n\n\n\n\n","category":"module"},{"location":"mio/#Exported-functions","page":"I/O routines","title":"Exported functions","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"Modules = [MIO]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"mio/#ElemCo.MIO.mioclosemmap-Tuple{IO, AbstractArray}","page":"I/O routines","title":"ElemCo.MIO.mioclosemmap","text":"mioclosemmap(io::IO, array::AbstractArray)\n\nClose memory-map file and flush to disk.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.mioload-Tuple{String}","page":"I/O routines","title":"ElemCo.MIO.mioload","text":"mioload(fname::String; array_of_arrays = false)\n\nLoad arrays from a file fname.\n\nReturn an array of arrays.   If there is only one array - return array itself   (unless array_of_arrays is set to true).\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.miommap-Tuple{String}","page":"I/O routines","title":"ElemCo.MIO.miommap","text":"miommap(fname::String)\n\nMemory-map an existing file for reading.   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.mionewmmap-Tuple{String, Any, Tuple{Vararg{Int64}}}","page":"I/O routines","title":"ElemCo.MIO.mionewmmap","text":"mionewmmap(fname::String, Type, dims::Tuple{Vararg{Int}})\n\nCreate a new memory-map file for writing (overwrites existing file).   Return a pointer to the file and the mmaped array.\n\n\n\n\n\n","category":"method"},{"location":"mio/#ElemCo.MIO.miosave-Union{Tuple{T}, Tuple{String, Vararg{AbstractArray{T}}}} where T","page":"I/O routines","title":"ElemCo.MIO.miosave","text":"miosave(fname::String,arrs::AbstractArray{T}...) where T\n\nSave arrays arrs in a file fname.\n\n\n\n\n\n","category":"method"},{"location":"mio/#Internal-functions","page":"I/O routines","title":"Internal functions","text":"","category":"section"},{"location":"mio/","page":"I/O routines","title":"I/O routines","text":"Modules = [MIO]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cc/#Coupled-cluster-methods","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"CurrentModule = ElemCo.CoupledCluster","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"CoupledCluster","category":"page"},{"location":"cc/#ElemCo.CoupledCluster","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster","text":"Coupled-cluster methods \n\nThe following coupled-cluster methods are implemented in ElemCo.jl:\n\nccsd - closed-shell implementation, for open-shell systems defaults to uccsd, \nuccsd - unrestricted implementation,\nrccsd - restricted implementation (for high-spin RHF reference only),\nccsd(t) - closed-shell implementation,\ndcsd - closed-shell implementation, for open-shell systems defaults to udcsd,\nudcsd - unrestricted implementation,\nrdcsd - restricted implementation (for high-spin RHF reference only),\nλccsd - calculation of Lagrange multipliers, closed-shell implementation,\nλccsd(t) - closed-shell implementation,\nλdcsd - calculation of Lagrange multipliers, closed-shell implementation.\n\nThe most efficient version of closed-shell CCSD/DCSD in ElemCo.jl combines the dressed factorization from [Kats2013] with  the cckext type of factorization from [Hampel1992] and is given by\n\nbeginalign*\nmathcalL = v_kl^cd tilde T^kl_cd + left(hat f_k^c + f_k^cright) T^k_c\n+ Λ_ij^ab left(hat v_kl^ij red+ v_kl^cd T^ij_cdright) T^kl_ab\n+ Λ_ij^ab R^ij_pq δ_a^p δ_b^q \nred+Λ_ij^ab v_kl^cdT^kj_adT^il_cb\n+ Λ_ij^ab mathcalP(aibj)leftleft(hat f_a^c - red2timesfrac12v_kl^cd tilde T^kl_adright)T^ij_cb\n- left(hat f_k^i + red2timesfrac12v_kl^cdtilde T^il_cdright)T^kj_ab right\n+ left(hat v_al^id\n+ frac12 v_kl^cdtilde T^ik_acright)tilde T^lj_db\n- hat v_ka^ic T^kj_cb -hat v_kb^ic T^kj_ac\nred-v_kl^cdT^ki_daleft(T^lj_cb-T^lj_bcright)\nleft- R^ij_pq left(δ_k^p δ_b^q - frac12 δ_k^p δ_l^q T^l_bright) T^k_a right\n+Λ_i^a R^ij_pqleft( 2δ_a^p δ_j^q - δ_j^p δ_a^q right)\n-Λ_i^a T^k_a R^ij_pqleft( 2δ_k^p δ_j^q - δ_j^p δ_k^q right)\n+Λ_i^a hat h_a^i + Λ_i^a hat f_j^b tilde T^ij_ab \n- Λ_i^a hat v_jk^ic tilde T^kj_ca\nendalign*\n\nwhere\n\nR^ij_pq = v_pq^rs left(left(T^ij_ab+T^i_a T^j_bright)δ_r^a δ_s^b \n+δ_r^i T^j_b δ_s^b + T^i_a δ_r^a δ_s^j + δ_r^i δ_s^j right) \n\nThe DCSD Lagrangian is obtained by removing terms in red. Integrals with hats are dressed integrals, i.e. they are obtained by dressing the integrals with the singles amplitudes, e.g., hat v_kl^id = v_kl^id + v_kl^cd T^i_c.\n\n[Kats2013]: D. Kats, and F.R. Manby, Sparse tensor framework for implementation of general local correlation methods, J. Chem. Phys. 138 (2013) 144101. doi:10.1063/1.4798940.\n\n[Hampel1992]: C. Hampel, K.A. Peterson, and H.-J. Werner, A comparison of the efficiency and accuracy of the quadratic configuration interaction (QCISD), coupled cluster (CCSD), and Brueckner coupled cluster (BCCD) methods, Chem. Phys. Lett. 190 (1992) 1. doi:10.1016/0009-2614(92)86093-W.\n\n\n\n\n\n","category":"module"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Lagrange multiplier equations for coupled cluster singles/doubles methods:","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nfracpartialmathcalLpartial T^m_e=\nleft(2 v_qm^pe - v_qm^epright) hat D_p^q + 2f_m^e \n- 2 Λ_ij^eb hat v_mb^ij\n+ 2 K_mj^rs delta_r^e left(delta_s^j + delta_s^b T^j_b right) \n+2 D_mj^kl hat v_kl^ej  \n- 2 Λ_ij^eb left(hat v_mb^cd T^ij_cdright)\n- D_d^e hat f_m^d + D_m^k hat f_k^e \n- 2 D_id^el hat v_ml^id \n+ 2 D_md^al hat v_al^ed\n+ 2bar D_ic^ek hat v_km^ic \n- 2bar D_mc^ak hat v_ka^ec \n- Λ_i^e hat f_m^i\n+ Λ_m^a hat f_a^e\n- Λ_i^e x_m^i - Λ_m^a x_a^e\nendaligned","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nfracpartialmathcalLpartial T^mn_ef=\ntilde v_mn^ef \n+ Λ_ij^ef left(hat v_mn^ij red+ v_mn^cd T^ij_cdright) \nred+ D_mn^kl v_kl^ef  + K_mn^rs delta_r^e delta_s^f\n+ mathcalP(emfn)left \nΛ_mn^af left(hat f_a^e - red2timesfrac12 x_a^eright)\n- Λ_in^ef left(hat f_m^i + red2timesfrac12 x_m^iright)\nright \n+ mathcalT(mn) leftred2timesfrac14 v_kn^ef D_m^k \n- red2timesfrac14 v_mn^cf D_c^e\n+ Λ_in^afleft(hat v_am^ie + v_km^cetilde T^ik_acright)right\nleft+ frac12 left(\n  Λ_m^e hat f_n^f \n+ Λ_n^a hat v_am^fe - Λ_i^f hat v_nm^ie right) right \n\nleft- Λ_in^af hat v_ma^ie - Λ_in^eb hat v_mb^if\nred-D_nc^fl v_ml^ce +bar D_nd^ekv_km^fd right\nendaligned","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"with","category":"page"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"beginaligned\nK_mn^rs = hat Lambda_mn^pq v_pq^rs \nhat Lambda_mn^pq = Λ_mn^abdelta_a^pdelta_b^q \n- Λ_mn^ab T^i_a  delta_i^p delta_b^q\n- Λ_mn^ab delta_a^p T^j_b delta_j^q\n+ Λ_mn^ab T^i_a T^j_b delta_i^p delta_j^q\nx_m^i = tilde T^il_cd v_ml^cd qquadqquad\nx_a^e = tilde T^kl_ac v_kl^ec\nmathcalT(mn) X_mn^ef = 2X_mn^ef - X_nm^ef\nD_ij^kl = Lambda_ij^cd T^kl_cd \nD_ib^aj = Lambda_ik^ac tilde T^kj_cb \nbar D_ib^aj = Lambda_ik^ac T^kj_cb + Lambda_ik^ca T^kj_bc \nendaligned","category":"page"},{"location":"cc/#Exported-functions","page":"Coupled-cluster methods","title":"Exported functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Modules = [CoupledCluster]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.calc_1RDM-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_1RDM","text":"calc_1RDM(EC::ECInfo, U1, U2, T1, T2)\n\nCalculate the 1RDM for the closed-shell CCSD or DCSD equations.\n\nReturn D1[p,q]=D_p^q, the 1RDM without T1 singles terms,  and dD1[p,q]=hat D_p^q, the 1RDM with all T1 terms included.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_1RDM-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 8}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_1RDM","text":"calc_1RDM(EC::ECInfo, U1, U1os, U2, U2ab, T1, T2, T2ab, spin)\n\nCalculate the spin-1RDM for the unrestricted CCSD or DCSD equations.\n\nU1, U2, T1, T2 are the Lagrange multipliers and amplitudes for spin∈{:α,:β}, U1os are the singles Lagrange multipliers for opposite spin, and U2ab, T2ab are the αβ Lagrange multipliers and amplitudes.\n\nReturn D1[p,q]=D_p^q, the 1RDM without T1 singles terms,  and dD1[p,q]=hat D_p^q, the 1RDM with all T1 terms included.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_MP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_MP2","text":"calc_MP2(EC::ECInfo, addsingles=true)\n\nCalculate closed-shell MP2 energy and amplitudes.    The amplitudes are stored in T_vvoo file.   If addsingles: singles are also calculated and stored in T_vo file.   Return EMp2 NamedTuple (E, ESS, EOS, EO).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2","text":"calc_UMP2(EC::ECInfo, addsingles=true)\n\nCalculate unrestricted MP2 energy and amplitudes.    The amplitudes are stored in T_vvoo, T_VVOO, and T_vVoO files.   If addsingles: singles are also calculated and stored in T_vo and T_VO files.   Return EMp2 NamedTuple (E, ESS, EOS, EO).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_UMP2_energy","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_UMP2_energy","text":"calc_UMP2_energy(EC::ECInfo, addsingles=true)\n\nCalculate open-shell MP2 energy from precalculated amplitudes.    If addsingles: singles energy is also calculated.   Return EMp2 NamedTuple (E, ESS, EOS, EO).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc","text":"calc_cc(EC::ECInfo, method::ECMethod)\n\nCalculate coupled cluster amplitudes.\n\nExact specification of the method is given by method.   Returns an energies NamedTuple with the following fields:\n\nE - correlation energy\nESS - same-spin component\nEOS - opposite-spin component\nEO - open-shell component (defined as E_αα - E_ββ)\nEIAS - internal-active singles (for 2D methods)\nEW - singlet/triplet energy contribution (for 2D methods)\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_lm_cc-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_lm_cc","text":"calc_lm_cc(EC::ECInfo, method::ECMethod)\n\nCalculate coupled cluster Lagrange multipliers.\n\nExact specification of the method is given by method.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT-Tuple{ElemCo.ECInfos.ECInfo, ElemCo.ECMethods.ECMethod}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT","text":"calc_pertT(EC::ECInfo, method::ECMethod; save_t3=false)\n\nCalculate (T) correction for [Λ][U]CCSD(T)\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.    If save_t3 is true, the T3 amplitudes are saved in T_vvvooo file (only for closed-shell).\n\n\n\n\n\n","category":"method"},{"location":"cc/#Internal-functions","page":"Coupled-cluster methods","title":"Internal functions","text":"","category":"section"},{"location":"cc/","page":"Coupled-cluster methods","title":"Coupled-cluster methods","text":"Modules = [CoupledCluster]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"cc/#ElemCo.CoupledCluster.add_to_singles_and_doubles_residuals-Tuple{Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.add_to_singles_and_doubles_residuals","text":"add_to_singles_and_doubles_residuals(EC, R1, R2)\n\nAdd contributions from triples to singles and doubles residuals.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_3ext_times_T2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_3ext_times_T2","text":"calc_3ext_times_T2(EC::ECInfo, T2::AbstractArray, o1::Char='o', v1::Char='v', o2::Char='o', v2::Char='v')\n\nCalculate hat v_mb^cd T^ij_cd intermediate    required in calc_ccsd_vector_times_Jacobian    and store as vT_ovoo[m,b,i,j].\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_3ext_times_T2-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, AbstractArray}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_3ext_times_T2","text":"calc_3ext_times_T2(EC::ECInfo, T2a::AbstractArray, T2b::AbstractArray, T2ab::AbstractArray)\n\nCalculate hat v_mb^cd T^ij_cd intermediates    required in calc_ccsd_vector_times_Jacobian    for αα, ββ, and αβ amplitudes    and store as vT_ovoo[m,b,i,j], vT_OVOO[M,B,I,J],    vT_oVoO[m,B,i,J] and vT_OvOo[M,b,I,j].\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_4idx_T3T3_XY-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_4idx_T3T3_XY","text":"calc_4idx_T3T3_XY(EC::ECInfo, T2, UvoX, ϵX)\n\nCalculate D^ij_ab = T^i_aXY T^j_bXY using half-decomposed imaginary-shifted perturbative triple amplitudes    T^i_aXY from T2 (and UvoX)\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, scalepp=false)\n\nCalculate D^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl.   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation).\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2","text":"calc_D2(EC::ECInfo, T1, T2, spin::Symbol)\n\nCalculate ^σσD^ij_pq = T^ij_cd + P_ij(T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl)   with P_ij X_ij = X_ij - X_ji.   Return as D[pqij] \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_D2ab","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_D2ab","text":"calc_D2ab(EC::ECInfo, T1a, T1b, T2ab, scalepp=false)\n\nCalculate ^αβD^ij_pq = T^ij_cd + T^i_c T^j_d +δ_ik T^j_d + T^i_c δ_jl + δ_ik δ_jl   Return as D[pqij] \n\nIf scalepp: D[ppij] elements are scaled by 0.5 (for triangular summation)\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc_resid-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc_resid","text":"calc_cc_resid(EC::ECInfo, T1, T2; dc=false, tworef=false, fixref=false)\n\nCalculate CCSD or DCSD closed-shell residual.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc_resid-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc_resid","text":"calc_cc_resid(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab; dc=false, tworef=false, fixref=false)\n\nCalculate UCCSD or UDCSD residual.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_cc_resid-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 9}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_cc_resid","text":"calc_cc_resid(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, T3aaa, T3bbb, T3abb, T3aab; dc=false)\n\nCalculate UCCSDT or UDC-CCSDT residual.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian","text":"calc_ccsd_vector_times_Jacobian(EC::ECInfo, U1, U2; dc=false)\n\nCalculate the vector times the Jacobian for the closed-shell CCSD or DCSD equations.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian","text":"calc_ccsd_vector_times_Jacobian(EC::ECInfo, U1a, U1b, U2a, U2b, U2ab; dc=false)\n\nCalculate the vector times the Jacobian for the unresticted CCSD or DCSD equations.\n\nReturn R1a, R1b, R2a, R2b, R2ab\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian4ab-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 7}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian4ab","text":"calc_ccsd_vector_times_Jacobian4ab(EC::ECInfo, U1a, U1b, U2a, U2b, U2ab, D1a, D1b; dc=false)\n\nCalculate the left vector times the CCSD/DCSD Jacobian for αβ component.  Additionally, remaining contributions to the singles residual are calculated.\n\nReturn ΔR1a, ΔR1b, R2ab\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian4spin-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 7}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsd_vector_times_Jacobian4spin","text":"calc_ccsd_vector_times_Jacobian4spin(EC::ECInfo, U1a, U1b, U2a, U2b, U2ab, D1, dD1, dD1os, spin; dc=false)\n\nCalculate the vector times the CCSD/DCSD Jacobian for the given spin (same-spin residual for doubles). The singles residual is missing some terms which are added in calc_ccsd_vector_times_Jacobian4ab.\n\nReturn R1 and R2 \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ccsdt","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ccsdt","text":"calc_ccsdt(EC::ECInfo, useT3=false, cc3=false)\n\nCalculate decomposed closed-shell DC-CCSDT amplitudes.\n\nIf useT3: (T) amplitudes from a preceding calculations will be used as starting guess.   If cc3: calculate CC3 amplitudes.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_correlation_norm-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_correlation_norm","text":"calc_correlation_norm(EC::ECInfo, U1, U2)\n\nCalculate the norm of the correlation part of the CCSD or DCSD equations   using Lagrange multipliers and amplitudes.\n\nReturn ΛΨ = Λ_1T_1 + Λ_2T_2+frac12T_1 T_1.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_correlation_norm-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 5}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_correlation_norm","text":"calc_correlation_norm(EC::ECInfo, U1a, U1b, U2a, U2b, U2ab)\n\nCalculate the norm of the correlation part of the UCCSD or UDCSD equations   using Lagrange multipliers and amplitudes.\n\nReturn ΛΨ = Λ_1T_1 + Λ_2T_2+frac12T_1 T_1.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_dU2","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dU2","text":"calc_dU2(EC::ECInfo, T1, T12, U2, o1='o', v1='v', o2='o', v2='v')\n\nCalculate the \"dressed\" Λ_2 for CCSD/DCSD.\n\nT12 is the T1 amplitude for the second electron of U2 (=T1 for closed-shell and same-spin U2).  Return dU2[p,q,m,n]=Λ_mn^abδ_a^p δ_b^q - Λ_mn^abT^i_a δ_i^p δ_b^q - Λ_mn^abδ_a^p T^j_b δ_j^q + Λ_mn^abT^i_a T^j_b δ_i^p δ_j^q.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2a, T2b, T2ab)\n\nCalculate energy for αα (T2a), ββ (T2b) and αβ (T2ab) doubles amplitudes.   Returns total energy, SS, OS and Openshell contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_doubles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_doubles_energy","text":"calc_doubles_energy(EC::ECInfo, T2)\n\nCalculate coupled-cluster closed-shell doubles energy.   Returns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1a, T1b=Float64[];\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nDress integrals with singles.\n\nhat v_ab^cd, hat v_ab^ci, hat v_ak^cd and hat v_ab^ij are only    calculated if requested in EC.options.cc or using keyword-arguments.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_dressed_ints-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Vararg{Char, 4}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_dressed_ints","text":"calc_dressed_ints(EC::ECInfo, T1, T12, o1::Char, v1::Char, o2::Char, v2::Char;\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nDress integrals with singles amplitudes. \n\nThe singles and orbspaces for first and second electron are T1, o1, v1 and T12, o2, v2, respectively.   The integrals from EC.fd are used and dressed integrals are stored as d_????.   hat v_ab^cd, hat v_ab^ci, hat v_ak^cd and hat v_ab^ij are only    calculated if requested in EC.options.cc or using keyword-arguments.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_focklike_vT2-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, AbstractArray}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_focklike_vT2","text":"calc_focklike_vT2(EC::ECInfo, T2a::AbstractArray, T2b::AbstractArray, T2ab::AbstractArray)\n\nCalculate the fock-like intermediates v_kl^cd T^il_cd and v_{kl}^{cd} T^{kl}_{ad}    required in calc_ccsd_vector_times_Jacobian    for αα/ββ, and αβ amplitudes.   Store as vT_oo[ki], vT_vv[ac], vT_OO[ki] and vT_VV[ac].\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 10}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1a, T1b, T2a, T2b, T2ab, R1a, R1b, R2a, R2b, R2ab)\n\nCalculate singles and doubles Hylleraas energy.   Returns total energy, SS, OS and Openshell contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 4}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas","text":"calc_hylleraas(EC::ECInfo, T1, T2, R1, R2)\n\nCalculate closed-shell singles and doubles Hylleraas energy.   Returns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_hylleraas4spincase-Tuple{ElemCo.ECInfos.ECInfo, Vararg{Any, 10}}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_hylleraas4spincase","text":"calc_hylleraas4spincase(EC::ECInfo, o1, v1, o2, v2, T1, T1OS, T2, R1, R2, fov)\n\nCalculate singles and doubles Hylleraas energy for one spin case.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT_closed_shell-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT_closed_shell","text":"calc_pertT_closed_shell(EC::ECInfo; save_t3=false)\n\nCalculate (T) correction for closed-shell CCSD.\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT_mixedspin-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT_mixedspin","text":"calc_pertT_mixedspin(EC::ECInfo, T1, T2, T1os, T2mix, spin::Symbol)\n\nCalculate mixed-spin (T) correction for UCCSD(T) (i.e., ααβ or ββα).\n\nspin ∈ (:α,:β)   T1 and T2 are same-spin amplitudes, T1os are opposite-spin amplitudes,   and T2mix are mixed-spin amplitudes with the second electron being spin,   i.e., Tβα for spin == :α and Tαβ for spin == :β.   Return ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT_samespin-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT_samespin","text":"calc_pertT_samespin(EC::ECInfo, T1, T2, spin::Symbol)\n\nCalculate same-spin (T) correction for UCCSD(T) (i.e., ααα or βββ).   spin ∈ (:α,:β)\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_pertT_unrestricted-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_pertT_unrestricted","text":"calc_pertT_unrestricted(EC::ECInfo)\n\nCalculate (T) correction for UCCSD.\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_rings_vT2-Tuple{ElemCo.ECInfos.ECInfo, AbstractArray, AbstractArray, AbstractArray}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_rings_vT2","text":"calc_rings_vT2(EC::ECInfo, T2a::AbstractArray, T2b::AbstractArray, T2ab::AbstractArray; dc=false)\n\nCalculate the ring intermediates required in calc_ccsd_vector_times_Jacobian   hat y_am^ie = hat v_am^ie - hat v_am^ei + 2x_am^ie + v_mL^eD T^iL_aD   and   hat y_Bn^Jf = hat v_nB^fJ + 2x_Bn^Jf + v_nL^fD T^LJ_DB   and the spin-flip version of them,   with    2x_am^ie = T^il_ad (v_lm^de red- v_ml^de)   and   2x_Am^Ie = T^Il_Ad (v_lm^de red- v_ml^de)\n\nThe intermediates are stored as vT_voov[amie], vT_VOOV[AMIE], vT_VoOv[BnJf], vT_vOoV[bNjF],\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1a, T1b; fock_only=false)\n\nCalculate energy for α (T1a) and β (T1b) singles amplitudes.   Returns total energy, SS, OS and Openshell contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_singles_energy-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_singles_energy","text":"calc_singles_energy(EC::ECInfo, T1; fock_only=false)\n\nCalculate coupled-cluster closed-shell singles energy.   Returns total energy, SS, OS and Openshell (0.0) contributions   as a NamedTuple (E,ESS,EOS,EO).\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_decomposition-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_decomposition","text":"calc_triples_decomposition(EC::ECInfo)\n\nDecompose T^ijk_abc as U^iX_a U^jY_b U^kZ_c T_XYZ.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_decomposition_without_triples-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_decomposition_without_triples","text":"calc_triples_decomposition_without_triples(EC::ECInfo, T2)\n\nDecompose T^ijk_abc as U^iX_a U^jY_b U^kZ_c T_XYZ    without explicit calculation of T^ijk_abc.\n\nCompute perturbative T^i_aXY and decompose D^ij_ab = (T^i_aXY T^j_bXY) to get U^iX_a.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_triples_residuals","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_triples_residuals","text":"calc_triples_residuals(EC::ECInfo, T1, T2, cc3 = false)\n\nCalculate decomposed triples DC-CCSDT or CC3 residuals.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.calc_vT2_intermediates-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_vT2_intermediates","text":"calc_vT2_intermediates(EC::ECInfo, T2a, T2b, T2ab; dc=false)\n\nCalculate intermediates required in unrestricted calc_ccsd_vector_times_Jacobian\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_vT2_intermediates-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_vT2_intermediates","text":"calc_vT2_intermediates(EC::ECInfo, T2; dc=false)\n\nCalculate intermediates required in closed-shell calc_ccsd_vector_times_Jacobian\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ΛpertT_closed_shell-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ΛpertT_closed_shell","text":"calc_ΛpertT_closed_shell(EC::ECInfo)\n\nCalculate (T) correction for closed-shell ΛCCSD(T).\n\nThe amplitudes are stored in T_vvoo file,    and the Lagrangian multipliers are stored in U_vvoo file.   Return ( ET3=(T) energy, ET3b=[T] energy) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ΛpertT_mixedspin-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Any, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ΛpertT_mixedspin","text":"calc_ΛpertT_mixedspin(EC::ECInfo, T2, T2mix, U1, U2, U1os, U2mix, spin::Symbol)\n\nCalculate mixed-spin (T) correction for ΛUCCSD(T) (i.e., ααβ or ββα).\n\nspin ∈ (:α,:β)   U1 and U2/T2 are same-spin Lagrange multipliers/amplitudes,   U1os are opposite-spin Lagrange multipliers,   and U2mix/T2mix are mixed-spin Lagrange multipliers/amplitudes    with the second electron being spin,   i.e., Tβα for spin == :α and Tαβ for spin == :β.   Return ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ΛpertT_samespin-Tuple{ElemCo.ECInfos.ECInfo, Any, Any, Any, Symbol}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ΛpertT_samespin","text":"calc_ΛpertT_samespin(EC::ECInfo, T2, U1, U2, spin::Symbol)\n\nCalculate same-spin (T) correction for ΛUCCSD(T) (i.e., ααα or βββ).   spin ∈ (:α,:β)\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.calc_ΛpertT_unrestricted-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.calc_ΛpertT_unrestricted","text":"calc_ΛpertT_unrestricted(EC::ECInfo)\n\nCalculate (T) correction for ΛUCCSD(T).\n\nReturn ( ET3=(T)-energy, ET3b=[T]-energy)) NamedTuple.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_closedshell-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_closedshell","text":"dress_fock_closedshell(EC::ECInfo, T1)\n\nDress the fock matrix (closed-shell). The dressed fock matrix is stored as df_mm.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_oppositespin-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_oppositespin","text":"dress_fock_oppositespin(EC::ECInfo)\n\nAdd the dressed opposite-spin part to the dressed Fock matrix. \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.dress_fock_samespin-Tuple{ElemCo.ECInfos.ECInfo, Any, Char, Char}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.dress_fock_samespin","text":"dress_fock_samespin(EC::ECInfo, T1, o1::Char, v1::Char)\n\nDress the fock matrix (same-spin part). \n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.oss_active_orbitals-Tuple{ElemCo.ECInfos.ECInfo}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.oss_active_orbitals","text":"oss_active_orbitals(EC::ECInfo)\n\nReturn the four active orbitals of an (2e,2o) open-shell singlet problem based on a single determinant reference.\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.pseudo_dressed_ints","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.pseudo_dressed_ints","text":"pseudo_dressed_ints(EC::ECInfo, unrestricted=false;\n          calc_d_vvvv=EC.options.cc.calc_d_vvvv, calc_d_vvvo=EC.options.cc.calc_d_vvvo,\n          calc_d_vovv=EC.options.cc.calc_d_vovv, calc_d_vvoo=EC.options.cc.calc_d_vvoo)\n\nSave non-dressed integrals in files instead of dressed integrals.\n\n\n\n\n\n","category":"function"},{"location":"cc/#ElemCo.CoupledCluster.test_UaiX-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_UaiX","text":"test_UaiX(EC, UaiX)\n\nTest UaiX\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_add_to_singles_and_doubles_residuals-NTuple{4, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_add_to_singles_and_doubles_residuals","text":"test_add_to_singles_and_doubles_residuals(R1, R2, T1, T2)\n\nTest R1(T3) and R2(T3)\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_calc_pertT_from_T3-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_calc_pertT_from_T3","text":"test_calc_pertT_from_T3(EC, T3)\n\nTest [T]\n\n\n\n\n\n","category":"method"},{"location":"cc/#ElemCo.CoupledCluster.test_dressed_ints-Tuple{Any, Any}","page":"Coupled-cluster methods","title":"ElemCo.CoupledCluster.test_dressed_ints","text":"test_dressed_ints(EC, T1)\n\nCompare 3-idx dressed integrals to 4-idx dressed integrals.\n\n\n\n\n\n","category":"method"},{"location":"options/#Options","page":"Options","title":"Options","text":"","category":"section"},{"location":"options/","page":"Options","title":"Options","text":"CurrentModule = ElemCo.ECInfos","category":"page"},{"location":"options/","page":"Options","title":"Options","text":"Options","category":"page"},{"location":"options/#ElemCo.ECInfos.Options","page":"Options","title":"ElemCo.ECInfos.Options","text":"Options for ElemCo.jl.\n\nwf::ElemCo.ECInfos.WfOptions:  Wavefunction options (WfOptions).\nscf::ElemCo.ECInfos.ScfOptions:  SCF options (ScfOptions).\nint::ElemCo.ECInfos.IntOptions:  Integral options (IntOptions).\ncc::ElemCo.ECInfos.CcOptions:  Coupled-Cluster options (CcOptions).\ndmrg::ElemCo.ECInfos.DmrgOptions:  DMRG options (DmrgOptions).\ncholesky::ElemCo.ECInfos.CholeskyOptions:  Cholesky options (CholeskyOptions).\ndiis::ElemCo.ECInfos.DiisOptions:  DIIS options (DiisOptions).\n\n\n\n\n\n","category":"type"},{"location":"options/","page":"Options","title":"Options","text":"Modules = [ECInfos]\nPages = [\"options.jl\"]\nFilter = t -> typeof(t) !== DataType || !(t <: ElemCo.ECInfos.Options)","category":"page"},{"location":"options/#ElemCo.ECInfos.CcOptions","page":"Options","title":"ElemCo.ECInfos.CcOptions","text":"Options for Coupled-Cluster calculation.\n\nthr::Float64: ⟨1.e-10⟩ convergence threshold.\nmaxit::Int64: ⟨50⟩ maximum number of iterations.\nshifts::Float64: ⟨0.15⟩ level shift for singles.\nshiftp::Float64: ⟨0.2⟩ level shift for doubles.\nshiftt::Float64: ⟨0.2⟩ level shift for triples.\nproperties::Bool: ⟨false⟩ calculate properties.\nampsvdtol::Float64: ⟨1.e-3⟩ amplitude decomposition threshold.\nampsvdfac::Float64: ⟨1.e-2⟩ tightening amplitude decomposition factor (for the two-step decomposition).\nuse_kext::Bool: ⟨true⟩ use kext for doubles residual.\ncalc_d_vvvv::Bool: ⟨false⟩ calculate dressed <vv|vv>.\ncalc_d_vvvo::Bool: ⟨false⟩ calculate dressed <vv|vo>.\ncalc_d_vovv::Bool: ⟨false⟩ calculate dressed <vo|vv>.\ncalc_d_vvoo::Bool: ⟨false⟩ calculate dressed <vv|oo>.\ntriangular_kext::Bool: ⟨true⟩ use a triangular kext if possible.\ncalc_t3_for_decomposition::Bool: ⟨false⟩ calculate (T) for decomposition.\ndeco_ishiftp::Float64: ⟨0.0⟩ imaginary shift for denominator in doubles decomposition.\ndeco_ishiftt::Float64: ⟨0.0⟩ imaginary shift for denominator in triples decomposition.\nuse_projx::Bool: ⟨false⟩ use a projected exchange for contravariant doubles amplitudes in SVD-DCSD, tilde T_XY = U^a_iX U^b_jY tilde T^ij_ab.\nuse_full_t2::Bool: ⟨false⟩ use full doubles amplitudes in SVD-DCSD. The decomposition is used only for N^6 scaling terms.\nproject_vovo_t2::Int64: ⟨2⟩ what to project in v_ak^ci T^kj_cb in SVD-DCSD: 0: both, 1: amplitudes, 2: residual, 3: robust fit.\ndecompose_full_doubles::Bool: ⟨false⟩ decompose full doubles amplitudes in SVD-DCSD (slow).\nstart::String: ⟨\"cc_amplitudes\"⟩ main part of filename for start amplitudes. For example, the singles amplitudes are read from start*\"_1\".\nsave::String: ⟨\"cc_amplitudes\"⟩ main part of filename to save amplitudes. For example, the singles amplitudes are saved to save*\"_1\".\nstart_lm::String: ⟨\"cc_multipliers\"⟩ main part of filename for start Lagrange multipliers. For example, the singles Lagrange multipliers are read from start_lm*\"_1\".\nsave_lm::String: ⟨\"cc_multipliers\"⟩ main part of filename to save Lagrange multipliers. For example, the singles Lagrange multipliers are saved to save_lm*\"_1\".\nnomp2::Int64: ⟨0⟩ Don't use MP2 amplitudes as starting guess for the CC amplitudes.\nmp2_ssfac::Float64: ⟨0.33⟩ Factor for same-spin component in SCS-MP2.\nmp2_osfac::Float64: ⟨1.2⟩ Factor for opposite-spin component in SCS-MP2.\nmp2_ofac::Float64: ⟨0.0⟩ Factor for open-shell component in SCS-MP2.\nccsd_ssfac::Float64: ⟨1.13⟩ Factor for same-spin component in SCS-CCSD.\nccsd_osfac::Float64: ⟨1.27⟩ Factor for opposite-spin component in SCS-CCSD.\nccsd_ofac::Float64: ⟨0.0⟩ Factor for open-shell component in SCS-CCSD.\ndcsd_ssfac::Float64: ⟨1.15⟩ Factor for same-spin component in SCS-DCSD.\ndcsd_osfac::Float64: ⟨1.05⟩ Factor for opposite-spin component in SCS-DCSD.\ndcsd_ofac::Float64: ⟨0.15⟩ Factor for open-shell component in SCS-DCSD.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.CholeskyOptions","page":"Options","title":"ElemCo.ECInfos.CholeskyOptions","text":"Options for Cholesky decomposition.\n\nthred::Float64: ⟨1.e-6⟩ threshold for elimination of redundancies in the auxiliary basis.\nthr::Float64: ⟨1.e-4⟩ threshold for integral decomposition.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.DiisOptions","page":"Options","title":"ElemCo.ECInfos.DiisOptions","text":"Options for DIIS.\n\nmaxdiis::Int64: ⟨6⟩ maximum number of DIIS vectors.\nresthr::Float64: ⟨10.0⟩ DIIS residual threshold.\ncrop::Bool: ⟨false⟩ CROP-DIIS (see JCTC 11, 1518 (2015)). Usually the DIIS dimension maxcrop=3 is sufficient.\nmaxcrop::Int64: ⟨3⟩ DIIS dimension for CROP-DIIS.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.DmrgOptions","page":"Options","title":"ElemCo.ECInfos.DmrgOptions","text":"Options for DMRG calculation.\n\nnsweeps::Int64: ⟨10⟩ number of sweeps.\nmaxdim::Vector{Int64}: ⟨[100, 200]⟩ maximum size for the bond dimension.\ncutoff::Float64: ⟨1e-6⟩ cutoff for the singular value decomposition.\nnoise::Vector{Float64}: ⟨[1e-6, 1e-7, 1e-8, 0.0]⟩ strength of the noise term used to aid convergence.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.IntOptions","page":"Options","title":"ElemCo.ECInfos.IntOptions","text":"Options for integral calculation.\n\ndf::Bool: ⟨true⟩ use density-fitted integrals.\nfcidump::String: ⟨\"\"⟩ store integrals in FCIDump format.\ncartesian::Bool: ⟨false⟩ use Cartesian subshells instead of Spherical.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.ScfOptions","page":"Options","title":"ElemCo.ECInfos.ScfOptions","text":"Options for SCF calculation.\n\nthr::Float64: ⟨1.e-10⟩ convergence threshold.\nthren::Float64: ⟨sqrt(thr)*0.1⟩ energy convergence threshold (used additionally to thr).\nmaxit::Int64: ⟨50⟩ maximum number of iterations.\nimagtol::Float64: ⟨1.e-8⟩ tolerance for imaginary part of MO coefs (for biorthogonal).\ndirect::Bool: ⟨false⟩ direct calculation without storing integrals.\nguess::Symbol: ⟨:SAD⟩ orbital guess:\n:HCORE from core Hamiltonian\n:SAD from atomic densities\n:GWH not implemented yet\n:ORB from previous orbitals stored in file WfOptions.orb\n\nbisecdamp::Float64: ⟨0.5⟩ damping factor for bisection search in augmented Hessian tuning.\nmaxit4lambda::Int64: ⟨3⟩ maximum number of iterations for searching for lambda value to get a reasonalbe guess within trust radius for MCSCF.\nHessianType::Symbol: ⟨:SO_SCI⟩ Hessian Type for MCSCF:\n:SO Second Order Approximation\n:SCI Super CI\n:SO_SCI Second Order Approximation combing Super CI\n\ninitVecType::Symbol: ⟨:GRADIENT_SETPLUS⟩ Initial Vectors Type for MCSCF:\n:RANDOM one random vector\n:INHERIT from last macro/micro iterations\n:GRADIENT_SET b0 as [1,0,0,...], b1 as gradient\n:GRADIENT_SETPLUS b0, b1 as GRADIENT_SET, b2 as zeros but 1 at the first closed-virtual rotation parameter\n\ntemperature_guess::Float64:  ⟨0.0⟩ Fermi-Dirac temperature for starting guess (at the moment works only for BO-HF).\ngamaDavScale::Float64:  ⟨0.1⟩ the threshold of davidson convergence residure norm scaled to norm of g the gradient, for MCSCF.\nSO_SCI_origin::Any:  ⟨true⟩ if true then use the original SO_SCI Hessian\ntrustScale::Any:  ⟨0.8⟩ the trust region of sqrt(sum(x.^2)) should be [trustScale,1] * trust\nlambdaMax::Any:  ⟨1000.0⟩ the maximum number of lambda when adjusting the level shift\ndavErrorMin::Any:  ⟨1e-6⟩ the minmum convergence threshold for davidson algorithm\niniDavMatSize::Any:  ⟨200⟩ the size of initial Davidson projected matrix\ntrustShrinkScale::Any:  ⟨0.7⟩ the shrink scale of trust region\ntrustExpandScale::Any:  ⟨1.2⟩ the expand scale of trust region\nenerQuotientLowerBound::Any:  ⟨0.25⟩ when energy quotient is lower than this value, the trust value should be smaller\nenerQuotientUpperBound::Any:  ⟨0.75⟩ when energy quotient is higher than this value, the trust value should be larger\npseudo::Bool: ⟨false⟩ Generate pseudo-canonical basis instead of solving the SCF problem, i.e., build and block-diagonalize the Fock matrix without changing the Fermi level. At the moment, it works only for BO-HF.\n\n\n\n\n\n","category":"type"},{"location":"options/#ElemCo.ECInfos.WfOptions","page":"Options","title":"ElemCo.ECInfos.WfOptions","text":"Options for wavefunction/orbitals.\n\nms2::Int64: ⟨-1⟩ spin magnetic quantum number times two (2×mₛ) of the system.\nnelec::Int64: ⟨-1⟩ number of electrons. If < 0, the number of electrons is read from the FCIDump file or guessed for the neutral system.\ncharge::Int64: ⟨0⟩ charge of the system (relative to nelec/FCIDump/neutral system!).\norb::String: ⟨\"C_Am\"⟩ filename of MO coefficients. Used by all programs to read and write orbitals from/to file.\nleft::String: ⟨\"-left\"⟩ addition to the filename for left orbitals (for biorthogonal calculations).\ncore::Symbol: ⟨:large⟩ core type for frozen-core approximation:\n:none no frozen-core approximation,\n:small semi-core orbitals correlated,\n:large semi-core orbitals frozen.\nfreeze_nocc::Int64: ⟨-1⟩ number of occupied (core) orbitals to freeze (overwrites core).\nfreeze_nvirt::Int64: ⟨0⟩ number of virtual (highest) orbitals to freeze.\nocca::String: ⟨\"-\"⟩ occupied α (or closed-shell) orbitals. The occupation strings can be given as a + separated list, e.g. occa = 1+2+3 or equivalently 1-3. Additionally, the spatial symmetry of the orbitals can be specified with the syntax orb.sym, e.g. occa = \"-5.1+-2.2+-4.3\".\noccb::String: ⟨\"-\"⟩ occupied β orbitals. If occb::String is empty, the occupied β orbitals are the same as the occupied α orbitals (closed-shell case).\nignore_error::Bool: ⟨false⟩ ignore various errors in sanity checks.\nprint_nlargest::Int64: ⟨5⟩ number of largest orbitals to print.\nprint_thr::Float64: ⟨0.1⟩ threshold for orbital coefficients to print.\n\n\n\n\n\n","category":"type"},{"location":"basisset/#Basis-set","page":"Basis set","title":"Basis set","text":"","category":"section"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"CurrentModule = ElemCo.BasisSets","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"The basis set is defined as a dictionary, where the keys are the types of the basis sets, and the values are the basis set:","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"basis = Dict(\"ao\"=>\"cc-pVTZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mpfit\"=>\"cc-pvtz-mpfit\")","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"The basis set dictionary contains three keys: ao, jkfit, and mpfit. The ao key contains the basis set for the AO integrals, the jkfit key contains the basis set for the density fitting integrals in the Hartree-Fock calculations, and the mpfit key contains the fitting basis set for the correlated calculations.","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"Alternatively, you can define the basis set using a string that defines the AO basis. In this case, the jkfit and mpfit basis names will be generated automatically. Here's an example of how you can define the basis set using a string:","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"basis = \"cc-pVDZ\"","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"Common acronyms are also supported for the basis set names, e.g., cc-pVDZ can be written as vdz, and aug-cc-pVTZ can be written as avtz.","category":"page"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"BasisSets","category":"page"},{"location":"basisset/#ElemCo.BasisSets","page":"Basis set","title":"ElemCo.BasisSets","text":"BasisSets\n\nModule for working with basis sets.\n\nThe basis set is stored in the BasisSet instance.   The basis set can be generated using the generate_basis function.\n\n\n\n\n\n","category":"module"},{"location":"basisset/#Exported-functions-and-types","page":"Basis set","title":"Exported functions and types","text":"","category":"section"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"Modules = [BasisSets]\nPrivate = false\nOrder = [:type, :function]","category":"page"},{"location":"basisset/#ElemCo.BasisSets.AbstractAngularShell","page":"Basis set","title":"ElemCo.BasisSets.AbstractAngularShell","text":"AbstractAngularShell\n\nAbstract type for angular shells, i.e, subshells with the same angular momentum.   For general contracted basis sets, the angular shell is a collection of all subshells    with the same l quantum number.    TODO For some other basis sets (e.g., the def2-family), the angular shell can be a   single subshell with a specific l quantum number.   See SphericalAngularShell and CartesianAngularShell.   id is the index of the angular shell in the basis set.\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.BasisCenter","page":"Basis set","title":"ElemCo.BasisSets.BasisCenter","text":"BasisCenter\n\nA basis center (atom) with basis functions.\n\nname::String:  basis center name (e.g., \"H1\")\nposition::StaticArraysCore.SVector{3, Float64}:  atomic position in Bohr (3D vector)\natomic_number::Int64:  atomic number\nbasis::String:  name of the basis set (e.g., \"cc-pVDZ\")\nshells::Vector{ElemCo.BasisSets.AbstractAngularShell}:  array of angular shells\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.BasisContraction","page":"Basis set","title":"ElemCo.BasisSets.BasisContraction","text":"BasisContraction{N, T}\n\nA basis contraction with N primitives and coefficients of type T.   exprange is the range of primitives (from exponents in the angular shell).\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.BasisSet","page":"Basis set","title":"ElemCo.BasisSets.BasisSet","text":"BasisSet\n\nA basis set with basis centers (atoms) and basis functions.\n\ncenters::Vector{ElemCo.BasisSets.BasisCenter}:  array of basis centers (atoms) with basis functions.\nshell_indices::Vector{CartesianIndex{2}}:  indices for angular shells.\ncenter_ranges::Vector{UnitRange{Int64}}:  center ranges for each basis set in a combined set.\nshell_ranges::Vector{UnitRange{Int64}}:  angular shell ranges for each basis sets in a combined set.\nlib::ElemCo.BasisSets.AbstractILib:  infos for integral library.\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.CartesianAngularShell","page":"Basis set","title":"ElemCo.BasisSets.CartesianAngularShell","text":"CartesianAngularShell\n\nType for cartesian angular shells, i.e, subshells with the same angular momentum.   For general contracted basis sets, the angular shell is a collection of all subshells    with the same l quantum number.    For some other basis sets (e.g., the def2-family), the angular shell can be a   single subshell with a specific l quantum number.   id is the index of the angular shell in the basis set.\n\nelement::String:  element symbol (e.g., \"H\")\nl::Int64:  angular momentum\nexponents::StaticArraysCore.SVector:  array of exponents\nsubshells::Vector{ElemCo.BasisSets.BasisContraction}:  array of subshells (contractions)\nid::Int64:  index of the angular shell in the basis set\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.ILibcint5","page":"Basis set","title":"ElemCo.BasisSets.ILibcint5","text":"ILibcint5\n\nInfos for Libcint5 integral library.\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.ILibcint5-Tuple{Vector{ElemCo.BasisSets.BasisCenter}}","page":"Basis set","title":"ElemCo.BasisSets.ILibcint5","text":"ILibcint5(atoms::Vector{BasisCenter})\n\nPrepare the infos for Libcint5 integral library.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.SphericalAngularShell","page":"Basis set","title":"ElemCo.BasisSets.SphericalAngularShell","text":"SphericalAngularShell\n\nType for spherical angular shells, i.e, subshells with the same angular momentum.   For general contracted basis sets, the angular shell is a collection of all subshells    with the same l quantum number.    For some other basis sets (e.g., the def2-family), the angular shell can be a   single subshell with a specific l quantum number.   id is the index of the angular shell in the basis set.\n\nelement::String:  element symbol (e.g., \"H\")\nl::Int64:  angular momentum\nexponents::StaticArraysCore.SVector:  array of exponents\nsubshells::Vector{ElemCo.BasisSets.BasisContraction}:  array of subshells (contractions)\nid::Int64:  index of the angular shell in the basis set\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.ao_list","page":"Basis set","title":"ElemCo.BasisSets.ao_list","text":"ao_list(basis::BasisSet, ibas=1)\n\nReturn the list of atomic orbitals in the basis set.\n\nFor a combined basis set, use ibas to select the basis set.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#ElemCo.BasisSets.basis_name","page":"Basis set","title":"ElemCo.BasisSets.basis_name","text":"basis_name(atoms, type=\"ao\")\n\nReturn the name of the basis set (or unknown if not found).   atoms can be a single atom ::Atom or a system ::AbstractSystem.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#ElemCo.BasisSets.center_range-Tuple{ElemCo.BasisSets.BasisSet, Int64}","page":"Basis set","title":"ElemCo.BasisSets.center_range","text":"center_range(bs::BasisSet, i::Int)\n\nReturn the range of centers for the ith basis set.\n\nThe range is used to access the centers in the basis set, e.g.,   bs.centers[i] for i in center_range(bs, 1) gives the centers of the first basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.coefficients_1mat","page":"Basis set","title":"ElemCo.BasisSets.coefficients_1mat","text":"coefficients_1mat(ashell::AbstractAngularShell)\n\nReturn a single contraction matrix of the coefficients in the angular shell    (nprimitives × nsubshells). The contractions are normalized.\n\nThe missing coefficients are set to zero in the matrix.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#ElemCo.BasisSets.combine-Tuple{ElemCo.BasisSets.BasisSet, ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.combine","text":"combine(bs1::BasisSet, bs2::BasisSet)\n\nCombine two basis sets. \n\nThe centers are concatenated.    The center/shell ranges (center_ranges/shell_ranges) corresponding to the centers/shells    for each basis set   can be used to access the centers/shells in the combined basis set, e.g.   bs.centers[i] for i in bs.center_ranges[1] gives the centers of the first basis set    in the combined set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.generate_basis","page":"Basis set","title":"ElemCo.BasisSets.generate_basis","text":"generate_basis(ms::AbstractSystem, type=\"ao\"; cartesian=false, basisset::AbstractString=\"\")\n\nGenerate basis sets for integral calculations.\n\nThe basis set is stored in BasisSet object.   type can be \"ao\", \"mpfit\" or \"jkfit\".   If basisset is provided, it is used as the basis set.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#ElemCo.BasisSets.generate_basis-2","page":"Basis set","title":"ElemCo.BasisSets.generate_basis","text":"generate_basis(EC::ECInfo, type=\"ao\"; basisset::AbstractString=\"\")\n\nGenerate basis sets for integral calculations.\n\nThe basis set is stored in BasisSet object.   type can be \"ao\", \"mpfit\" or \"jkfit\".   If basisset is provided, it is used as the basis set.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#ElemCo.BasisSets.guess_norb-Tuple{ElemCo.AbstractEC.AbstractECInfo}","page":"Basis set","title":"ElemCo.BasisSets.guess_norb","text":"guess_norb(EC::AbstractECInfo)\n\nGuess the number of orbitals in the system.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.is_cartesian-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.is_cartesian","text":"is_cartesian(bs::BasisSet)\n\nCheck if the basis set is Cartesian.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_angularshells-Tuple{ElemCo.BasisSets.BasisCenter}","page":"Basis set","title":"ElemCo.BasisSets.n_angularshells","text":"n_angularshells(atom::BasisCenter)\n\nReturn the number of angular shells in the basis set for atom.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_angularshells-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.n_angularshells","text":"n_angularshells(atoms::BasisSet)\n\nReturn the number of angular shells in the basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_ao-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_ao","text":"n_ao(ashell::AbstractAngularShell)\n\nReturn the number of atomic orbitals in the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_ao-Tuple{ElemCo.BasisSets.BasisCenter}","page":"Basis set","title":"ElemCo.BasisSets.n_ao","text":"n_ao(atom::BasisCenter)\n\nReturn the number of atomic orbitals in the basis set for atom.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_ao-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.n_ao","text":"n_ao(atoms::BasisSet)\n\nReturn the number of atomic orbitals in the basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_coefficients-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_coefficients","text":"n_coefficients(ashell::AbstractAngularShell)\n\nReturn the total number of coefficients in the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_coefficients-Tuple{ElemCo.BasisSets.BasisContraction}","page":"Basis set","title":"ElemCo.BasisSets.n_coefficients","text":"n_coefficients(subshell::BasisContraction)\n\nReturn the number of coefficients for the subshell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_coefficients_1mat-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_coefficients_1mat","text":"n_coefficients_1mat(ashell::AbstractAngularShell)\n\nReturn the number of coefficients in the angular shell for a single contraction matrix.\n\nThe missing coefficients will be set to zero.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_primitives-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_primitives","text":"n_primitives(ashell::AbstractAngularShell)\n\nReturn the total number of primitives in the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_primitives-Tuple{ElemCo.BasisSets.BasisCenter}","page":"Basis set","title":"ElemCo.BasisSets.n_primitives","text":"n_primitives(atom::BasisCenter)\n\nReturn the number of primitives in the basis set for atom.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_primitives-Tuple{ElemCo.BasisSets.BasisContraction}","page":"Basis set","title":"ElemCo.BasisSets.n_primitives","text":"n_primitives(subshell::BasisContraction)\n\nReturn the number of primitives for the subshell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_primitives-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.n_primitives","text":"n_primitives(atoms::BasisSet)\n\nReturn the number of primitives in the basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_subshells-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_subshells","text":"n_subshells(ashell::AbstractAngularShell)\n\nReturn the number of subshells in the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_subshells-Tuple{ElemCo.BasisSets.BasisCenter}","page":"Basis set","title":"ElemCo.BasisSets.n_subshells","text":"n_subshells(atom::BasisCenter)\n\nReturn the number of subshells in the basis set for atom.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_subshells-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.n_subshells","text":"n_subshells(atoms::BasisSet)\n\nReturn the number of subshells in the basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.print_ao-Tuple{ElemCo.BasisSets.AbstractAtomicOrbital, ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"ElemCo.BasisSets.print_ao","text":"print_ao(ao::AbstractAtomicOrbital, basis::BasisSet)\n\nPrint the atomic orbital.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.shell_range-Tuple{ElemCo.BasisSets.BasisSet, Int64}","page":"Basis set","title":"ElemCo.BasisSets.shell_range","text":"shell_range(bs::BasisSet, i::Int)\n\nReturn the range of angular shells for the ith basis set.\n\nThe range is used to access the angular shells in the basis set, e.g.,   bs[i] for i in shell_range(bs, 1) gives the angular shells of the first basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#Internal-functions-and-types","page":"Basis set","title":"Internal functions and types","text":"","category":"section"},{"location":"basisset/","page":"Basis set","title":"Basis set","text":"Modules = [BasisSets]\nPublic = false\nOrder = [:type, :function]","category":"page"},{"location":"basisset/#ElemCo.BasisSets.AbstractILib","page":"Basis set","title":"ElemCo.BasisSets.AbstractILib","text":"AbstractILib\n\nAbstract type for infos for integral libraries.\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.CartesianAtomicOrbital","page":"Basis set","title":"ElemCo.BasisSets.CartesianAtomicOrbital","text":"CartesianAtomicOrbital\n\nRepresents an atomic orbital in a cartesian basis set.\n\nicenter::UInt16:  index of the center in the basis set object\niangularshell::UInt16:  index of the angular shell in the basis set object\nisubshell::UInt8:  index of the subshell in the angular shell\nn::UInt8:  principal quantum number\nl::UInt8:  orbital angular momentum quantum number\nml::Int8:  magnetic \"quantum number\" (ml = -l:l(l+1)/2)\n\n\n\n\n\n","category":"type"},{"location":"basisset/#ElemCo.BasisSets.SphericalAtomicOrbital","page":"Basis set","title":"ElemCo.BasisSets.SphericalAtomicOrbital","text":"SphericalAtomicOrbital\n\nRepresents an atomic orbital in a spherical basis set.\n\nicenter::UInt16:  index of the center in the basis set object\niangularshell::UInt16:  index of the angular shell in the basis set object\nisubshell::UInt8:  index of the contraction in the angular shell\nn::UInt8:  principal quantum number\nl::UInt8:  orbital angular momentum quantum number\nml::Int8:  magnetic quantum number (ml = -l:l)\n\n\n\n\n\n","category":"type"},{"location":"basisset/#Base.getindex-Tuple{ElemCo.BasisSets.BasisSet, CartesianIndex{2}}","page":"Basis set","title":"Base.getindex","text":"Base.getindex(bs::BasisSet, i::CartesianIndex{2})\n\nReturn the the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#Base.getindex-Tuple{ElemCo.BasisSets.BasisSet, Int64, Int64}","page":"Basis set","title":"Base.getindex","text":"Base.getindex(bs::BasisSet, i::Int, j::Int)\n\nReturn the the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#Base.getindex-Tuple{ElemCo.BasisSets.BasisSet, Int64}","page":"Basis set","title":"Base.getindex","text":"Base.getindex(bs::BasisSet, i::Int)\n\nReturn the the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#Base.iterate","page":"Basis set","title":"Base.iterate","text":"Base.iterate(bs::BasisSet, state=1)\n\nIterate over the basis angular shells in the basis set.\n\n\n\n\n\n","category":"function"},{"location":"basisset/#Base.length-Tuple{ElemCo.BasisSets.BasisSet}","page":"Basis set","title":"Base.length","text":"Base.length(bs::BasisSet)\n\nReturn the number of angular shells in the basis set.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.add_subshell!-Tuple{ElemCo.BasisSets.AbstractAngularShell, Any, Any}","page":"Basis set","title":"ElemCo.BasisSets.add_subshell!","text":"add_subshell!(ashell::AbstractAngularShell, exprange, contraction)\n\nAdd a subshell to the angular shell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.basis_file-Tuple{AbstractString}","page":"Basis set","title":"ElemCo.BasisSets.basis_file","text":"basis_file(basis_name::AbstractString)\n\nReturn the full path to the basis set file.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.full_basis_name-Tuple{AbstractString}","page":"Basis set","title":"ElemCo.BasisSets.full_basis_name","text":"full_basis_name(basis_name::AbstractString)\n\nReturn the full basis name and version number    (if given as *.v[0-2], otherwise -1 is returned).\n\nI.e,\n\n[a][wc/c]vXz* -> [aug-]cc-p[wc/c]vXz*\nsvp* -> def2-svp*\n[tq]zvp* -> def2-[tq]zvp*\n\nAdditionally check for version number (e.g., vdz.v2)\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.generate_angularshell-Tuple{Any, Any, Any}","page":"Basis set","title":"ElemCo.BasisSets.generate_angularshell","text":"generate_angularshell(elem, l, exponents; cartesian=false)\n\nGenerate an angular shell with angular momentum l and exponents.   The contractions have to be added later.   Return an angular shell of type SphericalAngularShell or CartesianAngularShell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.guess_basis_name-Tuple{AtomsBase.Atom, Any}","page":"Basis set","title":"ElemCo.BasisSets.guess_basis_name","text":"guess_basis_name(atom::Atom, type)\n\nGuess the name of the basis set.   type can be \"ao\", \"mpfit\" or \"jkfit\".\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_ao4subshell-Tuple{ElemCo.BasisSets.CartesianAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_ao4subshell","text":"n_ao4subshell(ashell::CartesianAngularShell)\n\nReturn the number of atomic orbitals for the subshell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.n_ao4subshell-Tuple{ElemCo.BasisSets.SphericalAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.n_ao4subshell","text":"n_ao4subshell(ashell::SphericalAngularShell)\n\nReturn the number of atomic orbitals for the subshell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.normalize_cartesian_contraction-Tuple{Any, Any, Any}","page":"Basis set","title":"ElemCo.BasisSets.normalize_cartesian_contraction","text":"normalize_cartesian_contraction(contraction, exponents, l)\n\nNormalize the subshell.\n\nReturn the normalized contraction.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.normalize_spherical_contraction-Tuple{Any, Any, Any}","page":"Basis set","title":"ElemCo.BasisSets.normalize_spherical_contraction","text":"normalize_spherical_contraction(contraction, exponents, l)\n\nNormalize the spherical subshell.\n\nReturn the normalized contraction.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.parse_basis-Tuple{String, AtomsBase.Atom}","page":"Basis set","title":"ElemCo.BasisSets.parse_basis","text":"parse_basis(basis_name::String, atom::Atom; cartesian=false)\n\nSearch and parse the basis set for a given atom.\n\nReturn a list of subshells AbstractSubShell.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.parse_basis_block-Tuple{AbstractString, AtomsBase.Atom}","page":"Basis set","title":"ElemCo.BasisSets.parse_basis_block","text":"parse_basis_block(basisblock::AbstractString, atom::Atom; cartesian=false)\n\nParse the basis block for a given atom.\n\nReturn a list of angular shells AbstractAngularShell.   The basis block is in the Molpro format:\n\n! comments\ns,p,d,f,g,h angular momentum\nc, <from>.<to> contraction coefficients for primitives\n\nExample cc-pVDZ for H atom:\n\ns, H , 13.0100000, 1.9620000, 0.4446000, 0.1220000\nc, 1.4, 0.0196850, 0.1379770, 0.4781480, 0.5012400\nc, 4.4, 1.0000000\np, H , 0.7270000\nc, 1.1, 1.0000000\n\nFor generally-contracted basis sets (like the one above), one angular shell   is created for each angular momentum type s,p,d,f,g,h with the corresponding   exponents and contraction coefficients. For other basis sets, like the def2-SVP,   each contraction is a separate angular shell:\n\n! hydrogen             (4s,1p) -> [2s,1p]\ns, H , 13.0107010, 1.9622572, 0.44453796, 0.12194962\nc, 1.3, 0.19682158E-01, 0.13796524, 0.47831935\nc, 4.4, 1.0000000\np, H , 0.8000000\nc, 1.1, 1.0000000\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.parse_contraction-Tuple{AbstractString}","page":"Basis set","title":"ElemCo.BasisSets.parse_contraction","text":"parse_contraction(conline::AbstractString)\n\nParse contraction coefficients from a line in the basis block.\n\nReturn the range of exponents and the contraction coefficients as a tuple.   The line is in the Molpro format:   c, 1.4, 0.0196850, 0.1379770, 0.4781480, 0.5012400   where c is the contraction, 1.4 is the exponent range,   and the rest are the coefficients.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.parse_exponents-Tuple{AbstractString}","page":"Basis set","title":"ElemCo.BasisSets.parse_exponents","text":"parse_exponents(expline::AbstractString)\n\nParse exponents from a line in the basis block.\n\nReturn the angular momentum and exponents as a tuple.   The line is in the Molpro format:   s, H , 13.0100000, 1.9620000, 0.4446000, 0.1220000   where s is the angular momentum, H is the element symbol,   and the rest are the exponents.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.read_basis_block-Tuple{AbstractString, AtomsBase.Atom}","page":"Basis set","title":"ElemCo.BasisSets.read_basis_block","text":"read_basis_block(basisfile::AbstractString, atom::Atom)\n\nRead the basis block for a given atom.\n\nThe basis library is in the Molpro format:\n\n! comments\nbasis block starts with ! <elementname>  ....\nbasis block ends with ! or }\nbasis block contains:\ns,p,d,f,g,h angular momentum\nc, <from>.<to> contraction coefficients for primitives\n\nExample cc-pVDZ for H atom:\n\n!\n! hydrogen             (4s,1p) -> [2s,1p]\ns, H , 13.0100000, 1.9620000, 0.4446000, 0.1220000\nc, 1.4, 0.0196850, 0.1379770, 0.4781480, 0.5012400\nc, 4.4, 1.0000000\np, H , 0.7270000\nc, 1.1, 1.0000000\n!\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.set_id!-Tuple{AbstractArray{ElemCo.BasisSets.AbstractAngularShell}, Any}","page":"Basis set","title":"ElemCo.BasisSets.set_id!","text":"set_id!(ashells::AbstractArray{AbstractAngularShell}, start_id)\n\nSet the id for each angular shell in the array.   Return the next id.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.set_id!-Tuple{AbstractArray{ElemCo.BasisSets.BasisCenter}, Any}","page":"Basis set","title":"ElemCo.BasisSets.set_id!","text":"set_id!(centers::AbstractArray{BasisCenter}, start_id)\n\nSet the id for each angular shell in the array of centers.   Return the next id.\n\n\n\n\n\n","category":"method"},{"location":"basisset/#ElemCo.BasisSets.split_angular_shell-Tuple{ElemCo.BasisSets.AbstractAngularShell}","page":"Basis set","title":"ElemCo.BasisSets.split_angular_shell","text":"split_angular_shell(ashell::AbstractAngularShell; cartesian=false)\n\nIf the ranges of exponents do not overlap, split the angular shell   into separate angular shells for each subshell.   The shells are kept together only if one is a subset of the other.\n\n\n\n\n\n","category":"method"},{"location":"#ElemCo.jl-Documentation","page":"Home","title":"ElemCo.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ElemCo.jl is a Julia package for computing electronic structure properties of molecules and materials. It provides a set of tools for performing quantum chemical calculations, including Hartree-Fock and post-HF methods.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install ElemCo.jl using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\njulia> Pkg.add(\"ElemCo\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a development version of ElemCo.jl, clone the ElemCo.jl-devel repository and create an alias to set the project to the ElemCo.jl directory,","category":"page"},{"location":"","page":"Home","title":"Home","text":"alias jlm='julia --project=<path_to_ElemCo.jl>'","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now the command jlm can be used to start the calculations,","category":"page"},{"location":"","page":"Home","title":"Home","text":"jlm input.jl","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#Input-file","page":"Home","title":"Input file","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The input file is a Julia script that contains the calculation details. The script should start with the following lines,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ElemCo\n@print_input","category":"page"},{"location":"","page":"Home","title":"Home","text":"The @print_input macro prints the input file to the standard output. The calculation details are specified using the macros provided by ElemCo.jl.","category":"page"},{"location":"#Macros","page":"Home","title":"Macros","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following macros are available in ElemCo.jl (see the documentation for more details and macros),","category":"page"},{"location":"","page":"Home","title":"Home","text":"@dfhf - Performs a density-fitted Hartree-Fock calculation.\n@cc<method> - Performs a coupled cluster calculation.\n@dfcc<method> - Performs a coupled cluster calculation using density fitting.\n@set<option> <setting> - Sets the options(ElemCo.ECInfos.Options) for the calculation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Default scratch directory path on Windows is the first environment variable found in the ordered list TMP, TEMP, USERPROFILE. On all other operating systems TMPDIR, TMP, TEMP, and TEMPDIR. If none of these are found, the path /tmp is used. Default scratch folder name is elemcojlscr.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Variable names fcidump, geometry and basis are reserved for the file name of FCIDUMP, geometry specification and basis sets, respectively.","category":"page"},{"location":"#Computing-density-fitted-Hartree-Fock-and-Coupled-Cluster-methods","page":"Home","title":"Computing density-fitted Hartree-Fock and Coupled Cluster methods","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To compute density-fitted Hartree-Fock (DF-HF) using ElemCo.jl, you can use the @dfhf macro. In order to run post-HF calculations, the integrals have to be transformed to the MO basis (using the @dfints macro), and the coupled cluster calculations can be performed using @cc macro.  The @dfints macro is optional, @cc macro will automatically call @dfints if it has not been called before. Here's an example of how you can use these macros:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ElemCo\n\n# Print input to the output file\n@print_input\n# Define the molecule\ngeometry=\"bohr\n     O      0.000000000    0.000000000   -0.130186067\n     H1     0.000000000    1.489124508    1.033245507\n     H2     0.000000000   -1.489124508    1.033245507\"\n\n\nbasis = Dict(\"ao\"=>\"cc-pVDZ\",\n             \"jkfit\"=>\"cc-pvtz-jkfit\",\n             \"mpfit\"=>\"cc-pvdz-mpfit\")\n\n# Compute DF-HF \n@dfhf\n# Calculate MO integrals (optional)\n@dfints\n# Run CCSD(T) calculation\n@cc ccsd(t)","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code defines a water molecule, computes DF-HF using the cc-pVDZ basis set, calculates integrals using density fitting (mpfit basis) and computes CCSD(T) energy.","category":"page"},{"location":"#Setting-options","page":"Home","title":"Setting options","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To set options (ElemCo.ECInfos.Options) for the DF-HF, CC, etc calculations, you can use the @set macro. Here's an example of how you can use this macro:","category":"page"},{"location":"","page":"Home","title":"Home","text":"# Set the maximum number of iterations to 10\n@set scf maxit=10\n\n# Compute DF-HF using the new options\n@dfhf","category":"page"},{"location":"","page":"Home","title":"Home","text":"This code sets the maximum number of iterations for the SCF procedure to 10 using the @set macro, and then computes DF-HF using the new options using the @dfhf macro.","category":"page"},{"location":"#Using-AVX2-instructions-on-AMD-\"Zen\"-machines","page":"Home","title":"Using AVX2 instructions on AMD \"Zen\" machines","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MKL tends to be rather slow on AMD \"Zen\" machines (stand 2024). To use AVX2 instructions in MKL on AMD \"Zen\" machines, you can slightly modify the mkl libraries by running the ElemCo.amdmkl function, which will replace two symbolic links with compiled libraries that enforce the AVX2 instructions,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ElemCo\nElemCo.amdmkl()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note: this function has to be called in a separate script (separate Julia session) before running the calculations, i.e., your workflow can look like this:","category":"page"},{"location":"","page":"Home","title":"Home","text":"> julia -e 'using ElemCo; ElemCo.amdmkl()'\n> julia input.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"One can revert the changes by running the function with the argument true,","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ElemCo\nElemCo.amdmkl(true)","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Equations for the methods implemented in ElemCo.jl.","category":"page"},{"location":"dftools/#Density-fitting-tools","page":"Density-fitting tools","title":"Density-fitting tools","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"ElemCo.DFTools","category":"page"},{"location":"dftools/#ElemCo.DFTools","page":"Density-fitting tools","title":"ElemCo.DFTools","text":"This module contains various utils for density fitting.\n\n\n\n\n\n","category":"module"},{"location":"dftools/#Exported-functions","page":"Density-fitting tools","title":"Exported functions","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"Modules = [ElemCo.DFTools]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"dftools/#ElemCo.DFTools.generate_AO_DF_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_AO_DF_integrals","text":"generate_AO_DF_integrals(EC::ECInfo, fitbasis=\"mpfit\"; save3idx=true)\n\nGenerate AO integrals using DF + Cholesky.   If save3idx is true, save Cholesky-decomposed 3-index integrals,    otherwise save pseudo-square-root-inverse Cholesky decomposition.\n\n\n\n\n\n","category":"function"},{"location":"dftools/#ElemCo.DFTools.generate_DF_integrals-Tuple{ElemCo.ECInfos.ECInfo, Any}","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_DF_integrals","text":"generate_DF_integrals(EC::ECInfo, cMO)\n\nGenerate v_p^qL and f_p^q with   v_pr^qs = v_p^qL δ_LL v_r^sL.   The v_p^qL are generated using mpfit fitting basis, and   the f_p^q are generated using jkfit fitting basis.   The integrals are stored in files mmL and f_mm.\n\nReturn reference energy (calculated using jkfit fitting basis).\n\n\n\n\n\n","category":"method"},{"location":"dftools/#ElemCo.DFTools.get_auxblks","page":"Density-fitting tools","title":"ElemCo.DFTools.get_auxblks","text":"get_auxblks(naux, maxblocksize=128, strict=false)\n\nGenerate ranges for block indices for auxiliary basis (for loop over blocks).\n\nIf strict is true, the blocks will be of size maxblocksize (except for the last block).   Otherwise the actual block size will be as close as possible to blocksize such that   the resulting blocks are of similar size.\n\n\n\n\n\n","category":"function"},{"location":"dftools/#Internal-functions","page":"Density-fitting tools","title":"Internal functions","text":"","category":"section"},{"location":"dftools/","page":"Density-fitting tools","title":"Density-fitting tools","text":"Modules = [ElemCo.DFTools]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"dftools/#ElemCo.DFTools.generate_3idx_integrals","page":"Density-fitting tools","title":"ElemCo.DFTools.generate_3idx_integrals","text":"generate_3idx_integrals(EC::ECInfo, cMO, fitbasis=\"mpfit\")\n\nGenerate v_p^qL with   v_pr^qs = v_p^qL δ_LL v_r^sL   and store in file mmL.\n\n\n\n\n\n","category":"function"},{"location":"ecmethod/#ElemCo.jl-methods","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"CurrentModule = ElemCo.ECMethods","category":"page"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ECMethods","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods","page":"ElemCo.jl methods","title":"ElemCo.ECMethods","text":"Specify methods available for electron-correlation calculations\n\n\n\n\n\n","category":"module"},{"location":"ecmethod/#Main-structure","page":"ElemCo.jl methods","title":"Main structure","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"ECMethod","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods.ECMethod","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.ECMethod","text":"ECMethod\n\nDescription of the electron-correlation method\n\ntheory: theory level: \"MP\", \"CC\", \"DC\".\nprefix: prefix of the methods, e.g., \"EOM\", \"U\", \"R\", \"2D\", \"FRS\", \"FRT\".\nsuffix: suffix of the methods.\nexclevel:  excitation level for each class (exclevel[1] for singles etc.). Possible values: :none, :full, :pert, :pertiter.\npertlevel:  perturbation theory level (relevant for MP methods).\n\n\n\n\n\n","category":"type"},{"location":"ecmethod/#Exported-functions","page":"ElemCo.jl methods","title":"Exported functions","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"Modules = [ECMethods]\nPrivate = false\nOrder = [:function]","category":"page"},{"location":"ecmethod/#ElemCo.ECMethods.has_prefix-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.has_prefix","text":"has_prefix(method::ECMethod, spec::AbstractString)\n\nReturn true if method has prefix spec, e.g., \"EOM\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.has_suffix-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.has_suffix","text":"has_suffix(method::ECMethod, spec::AbstractString)\n\nReturn true if method has suffix spec, e.g., \"F12\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.is_unrestricted-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.is_unrestricted","text":"is_unrestricted(method::ECMethod)\n\nReturn true if method is unrestricted.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.max_full_exc-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.max_full_exc","text":"max_full_exc(method::ECMethod)\n\nReturn the highest full excitation level of the method.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.method_name-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.method_name","text":"method_name(method::ECMethod; main::Bool = true, root::Bool = false)\n\nReturn string representation of method.   If main is true, return only the main part of the name, i.e., without   perturbative corrections.   If root is true, return the root name of the method, i.e., without any   prefixes or suffixes.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.set_prefix!-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_prefix!","text":"set_prefix!(method::ECMethod, spec::AbstractString)\n\nSet method to have prefix spec, e.g., \"EOM\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.set_suffix!-Tuple{ElemCo.ECMethods.ECMethod, AbstractString}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_suffix!","text":"set_suffix!(method::ECMethod, spec::AbstractString)\n\nSet method to have suffix spec, e.g., \"F12\".\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.set_unrestricted!-Tuple{ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.set_unrestricted!","text":"set_unrestricted!(method::ECMethod)\n\nSet method to unrestricted.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#Internal-functions","page":"ElemCo.jl methods","title":"Internal functions","text":"","category":"section"},{"location":"ecmethod/","page":"ElemCo.jl methods","title":"ElemCo.jl methods","text":"Modules = [ECMethods]\nPublic = false\nOrder = [:function]","category":"page"},{"location":"ecmethod/#Base.show-Tuple{IO, ElemCo.ECMethods.ECMethod}","page":"ElemCo.jl methods","title":"Base.show","text":"show(io::IO, method::ECMethod)\n\nPrint method to io.\n\n\n\n\n\n","category":"method"},{"location":"ecmethod/#ElemCo.ECMethods.check_specs-Tuple{AbstractString, Any, Vector}","page":"ElemCo.jl methods","title":"ElemCo.ECMethods.check_specs","text":"check_specs(mname::AbstractString, pos, specs::Vector)\n\nCheck if starting from position pos, mname contains any of specs   and return a list of the matching ones (without dashes for multiple-letter specs!)    and the final position after specs.\n\n\n\n\n\n","category":"method"}]
}
